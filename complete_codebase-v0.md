# CLMSR Market System - Complete Codebase

_Generated: 2025-12-01 12:32:47_

---

## Smart Contracts


## contracts/core/CLMSRMarketCore.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "../interfaces/ICLMSRMarketCore.sol";
import "../interfaces/ICLMSRPosition.sol";
import "../fees/interfaces/ICLMSRFeePolicy.sol";
import {LazyMulSegmentTree} from "../libraries/LazyMulSegmentTree.sol";
import {FixedPointMathU} from "../libraries/FixedPointMath.sol";
import "../errors/CLMSRErrors.sol";
import {CLMSRErrors as CE} from "../errors/CLMSRErrors.sol";
import "./storage/CLMSRMarketCoreStorage.sol";
import "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol";

/// @title CLMSRMarketCore  
/// @notice Core implementation for CLMSR Daily-Market System
/// @dev UUPS upgradeable contract handling core trading logic and market state
contract CLMSRMarketCore is 
    Initializable,
    ICLMSRMarketCore, 
    CLMSRErrors,
    OwnableUpgradeable,
    UUPSUpgradeable,
    PausableUpgradeable,
    ReentrancyGuardUpgradeable,
    CLMSRMarketCoreStorage,
    RedstoneConstants
{
    using SafeERC20 for IERC20;
    using {
        FixedPointMathU.toWad,
        FixedPointMathU.wMul,
        FixedPointMathU.wMulNearest,
        FixedPointMathU.wDiv,
        FixedPointMathU.wDivUp,
        FixedPointMathU.wExp,
        FixedPointMathU.wLn
    } for uint256;

    // ========================================
    // CONSTANTS
    // ========================================
    
    /// @notice Maximum number of ticks per market (segment tree safety)
    uint32 public constant MAX_TICK_COUNT = 1_000_000;
    
    /// @notice Minimum liquidity parameter (alpha)
    uint256 public constant MIN_LIQUIDITY_PARAMETER = 1e15; // 0.001 
    
    /// @notice Maximum liquidity parameter (alpha)
    uint256 public constant MAX_LIQUIDITY_PARAMETER = 1e23; // 100000 
    
    /// @notice Maximum safe input for PRB-Math exp() function
    uint256 private constant MAX_EXP_INPUT_WAD = 1_000_000_000_000_000_000; // 1.0 * 1e18
    
    /// @notice Maximum number of chunks allowed per transaction to prevent gas DoS
    /// Increased to handle larger institutional trades while maintaining safety
    /// This allows for trades up to 500 * maxSafeQuantityPerChunk in size
    uint256 private constant MAX_CHUNKS_PER_TX = 1000;

    /// @notice Scaling factor between 18-decimal WAD and 6-decimal token amounts
    uint256 private constant SIX_DECIMAL_SCALE = 1_000_000_000_000;

    /// @dev Helper to derive a chunk size representable in 6-decimal units without exceeding raw bound
    function _maxSafeChunkQuantity(uint256 alpha) private pure returns (uint256) {
        uint256 raw = alpha.wMul(MAX_EXP_INPUT_WAD) - 1;
        if (raw == 0) {
            return 0;
        }

        uint256 quantized = raw - (raw % SIX_DECIMAL_SCALE);
        return quantized != 0 ? quantized : raw;
    }

    /// @dev Centralized debit rounding helper (ceil converts WAD to 6-decimal units)
    function _roundDebit(uint256 wadAmount) internal pure returns (uint256) {
        return FixedPointMathU.fromWadRoundUp(wadAmount);
    }

    /// @dev Centralized credit rounding helper (floor converts WAD to 6-decimal units)
    function _roundCredit(uint256 wadAmount) internal pure returns (uint256) {
        return FixedPointMathU.fromWad(wadAmount);
    }

    function _resolveFeeRecipient() internal view returns (address) {
        address recipient = feeRecipient;
        return recipient != address(0) ? recipient : owner();
    }

    function _quoteFee(
        bool isBuy,
        address trader,
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity,
        uint256 baseAmount
    ) internal view returns (uint256) {
        ICLMSRMarketCore.Market storage market = markets[marketId];
        address policyAddress = market.feePolicy;
        if (policyAddress == address(0)) {
            return 0;
        }

        ICLMSRFeePolicy.QuoteParams memory params = ICLMSRFeePolicy.QuoteParams({
            trader: trader,
            marketId: marketId,
            lowerTick: lowerTick,
            upperTick: upperTick,
            quantity: quantity,
            baseAmount: baseAmount,
            isBuy: isBuy,
            context: bytes32(0)
        });

        return ICLMSRFeePolicy(policyAddress).quoteFee(params);
    }


    // ========================================
    // STATE VARIABLES
    // ========================================

    /// @dev Í≥µÏú† Ïä§ÌÜ†Î¶¨ÏßÄÎäî CLMSRMarketCoreStorageÏóê Ï†ïÏùòÎêòÏñ¥ ManagerÏôÄ Ïä¨Î°ØÏùÑ ÏùºÏπòÏãúÌÇ®Îã§.
    


    // ========================================
    // MODIFIERS
    // ========================================
    
    /// @notice Market must exist
    modifier marketExists(uint256 marketId) {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        _;
    }

    // ========================================
    // INITIALIZER
    // ========================================
    
    /// @notice Initialize the upgradeable contract
    /// @param _paymentToken ERC20 token for payments
    /// @param _positionContract Position NFT contract
    function initialize(
        address _paymentToken,
        address _positionContract
    ) external initializer {
        require(
            _paymentToken != address(0) &&
                _positionContract != address(0),
            CE.ZeroAddress()
        );
        
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        __Pausable_init();
        __ReentrancyGuard_init();
        
        uint8 tokenDecimals = IERC20Metadata(_paymentToken).decimals();
        require(tokenDecimals == 6, CE.InvalidTokenDecimals(tokenDecimals, 6));

        paymentToken = IERC20(_paymentToken);
        positionContract = ICLMSRPosition(_positionContract);    
        
        // Initialize market ID counter
        _nextMarketId = 1;
        
        // Note: 6 decimals assumed for payment token (USDC)
    }

    // ========================================
    // MANAGER CONFIGURATION
    // ========================================

    /// @notice ÎùºÏù¥ÌîÑÏÇ¨Ïù¥ÌÅ¥ ÏúÑÏûÑ ÎåÄÏÉÅ Îß§ÎãàÏ†ÄÎ•º ÏÑ§Ï†ïÌïúÎã§.
    function setManager(address newManager) external onlyOwner {
        require(newManager != address(0), CE.ZeroAddress());
        require(newManager.code.length > 0, "ManagerNoCode");

        emit ManagerUpdated(manager, newManager);
        manager = newManager;
    }

    /// @notice Updates the fee policy for a specific market
    function setMarketFeePolicy(uint256 marketId, address newPolicy)
        external
        override
        onlyOwner
        whenNotPaused
        marketExists(marketId)
    {
        (marketId, newPolicy);
        _delegateToManager();
    }

    /// @notice Updates the fee recipient address (defaults to owner when unset)
    function setFeeRecipient(address newRecipient) external override onlyOwner {
        emit FeeRecipientUpdated(feeRecipient, newRecipient);
        feeRecipient = newRecipient;
    }

    /// @notice Returns the configured fee policy address for a specific market
    function getMarketFeePolicy(uint256 marketId)
        external
        view
        override
        marketExists(marketId)
        returns (address)
    {
        return markets[marketId].feePolicy;
    }

    /// @notice Returns the configured fee recipient (zero implies owner)
    function getFeeRecipient() external view override returns (address) {
        return feeRecipient;
    }

    /// @dev ÏÑ§Ï†ïÎêú Îß§ÎãàÏ†ÄÎ°ú delegatecall ÏàòÌñâ, Ïã§Ìå® Ïãú revert Îç∞Ïù¥ÌÑ∞Î•º Î≤ÑÎ∏îÎßÅÌïúÎã§.
    function _delegateToManager() private returns (bytes memory) {
        address implementation = manager;
        if (implementation == address(0)) {
            revert CE.ManagerNotSet();
        }

        (bool ok, bytes memory ret) = implementation.delegatecall(msg.data);
        if (!ok) {
            if (ret.length == 0) revert("ManagerDelegateFailed");
            assembly ("memory-safe") {
                revert(add(ret, 0x20), mload(ret))
            }
        }

        return ret;
    }
    

    // ========================================
    // MARKET MANAGEMENT FUNCTIONS
    // ========================================
    
    /// @inheritdoc ICLMSRMarketCore
    function createMarket(
        int256 minTick,
        int256 maxTick,
        int256 tickSpacing,
        uint64 startTimestamp,
        uint64 endTimestamp,
        uint64 settlementTimestamp,
        uint256 liquidityParameter,
        address feePolicy
    ) external override onlyOwner whenNotPaused returns (uint256 marketId) {
        (minTick, maxTick, tickSpacing, startTimestamp, endTimestamp, settlementTimestamp, liquidityParameter, feePolicy);
        bytes memory ret = _delegateToManager();
        return abi.decode(ret, (uint256));
    }

    /// @inheritdoc ICLMSRMarketCore
    function settleMarket(uint256 marketId, int256 settlementValue) 
        external override onlyOwner marketExists(marketId) {
        (marketId, settlementValue);
        _delegateToManager();
    }

    /// @inheritdoc ICLMSRMarketCore
    function submitSettlement(
        uint256 marketId
    ) external override whenNotPaused marketExists(marketId) {
        (marketId);
        _delegateToManager();
    }

    /// @inheritdoc ICLMSRMarketCore
    function finalizeSettlement(uint256 marketId, bool markFailed)
        external
        override
        whenNotPaused
        marketExists(marketId)
    {
        (marketId, markFailed);
        _delegateToManager();
    }

    /// @inheritdoc ICLMSRMarketCore
    function reopenMarket(uint256 marketId) 
        external override onlyOwner marketExists(marketId) {
        marketId;
        _delegateToManager();
    }

    /// @inheritdoc ICLMSRMarketCore
    function setMarketActive(uint256 marketId, bool active)
        external
        override
        onlyOwner
        whenNotPaused
        marketExists(marketId)
    {
        (marketId, active);
        _delegateToManager();
    }


    /// @inheritdoc ICLMSRMarketCore
    function emitPositionSettledBatch(
        uint256 marketId,
        uint256 limit
    ) external override onlyOwner marketExists(marketId) {
        (marketId, limit);
        _delegateToManager();
    }

    /// @inheritdoc ICLMSRMarketCore
    function updateMarketTiming(
        uint256 marketId,
        uint64 newStartTimestamp,
        uint64 newEndTimestamp,
        uint64 newSettlementTimestamp
    ) external override onlyOwner marketExists(marketId) {
        (marketId, newStartTimestamp, newEndTimestamp, newSettlementTimestamp);
        _delegateToManager();
    }

    

    

    


    // ========================================
    // STATE QUERY FUNCTIONS
    // ========================================
    
        /// @inheritdoc ICLMSRMarketCore
    function getMarket(uint256 marketId) 
        external view override returns (Market memory market) {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        return markets[marketId];
    }

    /// @notice Preview overlay fee for opening or increasing positions
    function previewOpenFee(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity,
        uint256 cost
    ) external view override returns (uint256) {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        return _quoteFee(true, msg.sender, marketId, lowerTick, upperTick, quantity, cost);
    }

    /// @notice Preview overlay fee for decreasing or closing positions
    function previewSellFee(
        uint256 positionId,
        uint128 sellQuantity,
        uint256 proceeds
    ) external view override returns (uint256) {
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        return _quoteFee(
            false,
            msg.sender,
            position.marketId,
            position.lowerTick,
            position.upperTick,
            sellQuantity,
            proceeds
        );
    }
    
    /// @notice Get range sum for market ticks (public view function)
    /// @param marketId Market identifier
    /// @param lo Lower tick (inclusive)
    /// @param hi Upper tick (exclusive)
    /// @return sum Sum of values in range
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    // For a single-bin query, call with hi = lo + market.tickSpacing
    function getRangeSum(uint256 marketId, int256 lo, int256 hi)
        public
        view
        override
        marketExists(marketId)
        returns (uint256 sum)
    {
        Market memory market = markets[marketId];
        _validateTick(lo, market);
        _validateTick(hi, market);
        
        require(lo <= hi, CE.InvalidTickRange(lo, hi));
        
        (uint32 loBin, uint32 hiBin) = _rangeToBins(lo, hi, market);

        return LazyMulSegmentTree.getRangeSum(marketTrees[marketId], loBin, hiBin);
    }

    /// @notice Propagate lazy values for market ticks (Keeper only)
    /// @param marketId Market identifier
    /// @param lo Lower tick (inclusive)
    /// @param hi Upper tick (exclusive)
    /// @return sum Sum of values in range after propagation
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function propagateLazy(uint256 marketId, int256 lo, int256 hi)
        external
        override
        onlyOwner
        marketExists(marketId)
        returns (uint256 sum)
    {
        Market memory market = markets[marketId];
        _validateTick(lo, market);
        _validateTick(hi, market);
        
        require(lo <= hi, CE.InvalidTickRange(lo, hi));

        (uint32 loBin, uint32 hiBin) = _rangeToBins(lo, hi, market);

        return LazyMulSegmentTree.propagateLazy(marketTrees[marketId], loBin, hiBin);
    }

    /// @notice Apply range factor to market ticks (Keeper only)
    /// @param marketId Market identifier
    /// @param lo Lower tick (inclusive)
    /// @param hi Upper tick (exclusive)
    /// @param factor Multiplication factor in WAD format
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function applyRangeFactor(uint256 marketId, int256 lo, int256 hi, uint256 factor)
        external
        override
        onlyOwner
        marketExists(marketId)
    {
        Market memory market = markets[marketId];
        _validateTick(lo, market);
        _validateTick(hi, market);
        
        require(lo <= hi, CE.InvalidTickRange(lo, hi));

        (uint32 loBin, uint32 hiBin) = _rangeToBins(lo, hi, market);

        LazyMulSegmentTree.applyRangeFactor(marketTrees[marketId], loBin, hiBin, factor);
        emit RangeFactorApplied(marketId, lo, hi, factor);
    }

    /// @inheritdoc ICLMSRMarketCore
    function applyRangeFactorBatch(
        uint256 marketId,
        int256[] calldata lowers,
        int256[] calldata uppers,
        uint256[] calldata factors,
        bytes32 context
    ) external override onlyOwner whenNotPaused marketExists(marketId) {
        uint256 length = lowers.length;
        require(length == uppers.length && length == factors.length, CE.ArrayLengthMismatch());
        require(length != 0, CE.ArrayLengthMismatch());

        Market memory market = markets[marketId];

        for (uint256 i = 0; i < length; ++i) {
            int256 lo = lowers[i];
            int256 hi = uppers[i];
            uint256 factor = factors[i];

            _validateTick(lo, market);
            _validateTick(hi, market);
            require(lo <= hi, CE.InvalidTickRange(lo, hi));

            (uint32 loBin, uint32 hiBin) = _rangeToBins(lo, hi, market);
            LazyMulSegmentTree.applyRangeFactor(marketTrees[marketId], loBin, hiBin, factor);
            emit RangeFactorApplied(marketId, lo, hi, factor);
        }

        emit RangeFactorBatchApplied(marketId, length, context);
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function getPositionContract() external view override returns (address) {
        return address(positionContract);
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function getPaymentToken() external view override returns (address) {
        return address(paymentToken);
    }
    
    // ========================================
    // EMERGENCY FUNCTIONS
    // ========================================
    
    /// @inheritdoc ICLMSRMarketCore
    function pause(string calldata reason) external override onlyOwner {
        _pauseWithReason(reason);
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function unpause() external override onlyOwner {
        super._unpause();
        emit EmergencyUnpaused(msg.sender);
    }
    
    
    /// @inheritdoc ICLMSRMarketCore
    function isPaused() external view override returns (bool) {
        return paused();
    }

    // ========================================
    // EXECUTION FUNCTIONS
    // ========================================
    
    /// @inheritdoc ICLMSRMarketCore
    function openPosition(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity,
        uint256 maxCost
    ) external override whenNotPaused nonReentrant returns (uint256 positionId) {
        // Validate parameters
        require(quantity != 0, CE.InvalidQuantity(quantity));
        
        Market storage market = markets[marketId];
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        
        require(market.isActive, CE.MarketNotActive());
        
        // Validate market timing
        require(block.timestamp >= market.startTimestamp, CE.MarketNotStarted());
        
        require(block.timestamp <= market.endTimestamp, CE.MarketExpired());
        
        // Validate ticks are within market bounds and follow spacing
        _validateTick(lowerTick, market);
        _validateTick(upperTick, market);
        
        require(lowerTick <= upperTick, CE.InvalidTickRange(lowerTick, upperTick));
        
        // üö® NO POINT BETTING: Reject same tick betting
        require(lowerTick != upperTick, CE.InvalidTickRange(lowerTick, upperTick));
        
        // ‚úÖ RANGE BETTING: Allow any valid range (single or multiple intervals)
        // Must be aligned to tick spacing
        require(
            (upperTick - lowerTick) % market.tickSpacing == 0,
            CE.InvalidTickRange(lowerTick, upperTick)
        );
        
        // Calculate trade cost and convert to 6-decimal with round-up to prevent zero-cost attacks
        uint256 costWad = _calcCostInWad(marketId, lowerTick, upperTick, quantity);
        uint256 cost6 = _roundDebit(costWad);

        uint256 fee6 = _quoteFee(true, msg.sender, marketId, lowerTick, upperTick, quantity, cost6);
        uint256 totalCost = cost6 + fee6;
        require(totalCost <= maxCost, CE.CostExceedsMaximum(totalCost, maxCost));

        // Transfer payment from caller (msg.sender)
        _pullUSDC(msg.sender, cost6);
        if (fee6 > 0) {
            _pullUSDC(msg.sender, fee6);
            _pushUSDC(_resolveFeeRecipient(), fee6);
        }
        
        // Update market state using WAD quantity
        uint256 qtyWad = uint256(quantity).toWad();
        _applyFactorChunked(marketId, lowerTick, upperTick, qtyWad, market.liquidityParameter, true);
        
        // Mint position NFT to caller (msg.sender) with original 6-decimal quantity (storage unchanged)
        positionId = positionContract.mintPosition(
            msg.sender,
            marketId,
            lowerTick,
            upperTick,
            quantity
        );
        
        emit PositionOpened(
            positionId,
            msg.sender,
            marketId,
            lowerTick,
            upperTick,
            quantity,
            cost6
        );

        if (fee6 > 0) {
            emit TradeFeeCharged(
                msg.sender,
                marketId,
                positionId,
                true,
                cost6,
                fee6,
                market.feePolicy
            );
        }
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function increasePosition(
        uint256 positionId,
        uint128 additionalQuantity,
        uint256 maxCost
    ) external override whenNotPaused nonReentrant returns (uint128 newQuantity) {
        require(additionalQuantity != 0, CE.InvalidQuantity(additionalQuantity));
        
        // Get position data and validate market
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        address trader = positionContract.ownerOf(positionId);
        
        // Verify caller owns the position
        require(trader == msg.sender, CE.UnauthorizedCaller(msg.sender));
        
        _validateActiveMarket(position.marketId);
        Market storage market = markets[position.marketId];
        
        // Calculate cost with round-up to prevent zero-cost attacks
        uint256 costWad = _calculateTradeCostInternal(
            position.marketId,
            position.lowerTick,
            position.upperTick,
            uint256(additionalQuantity).toWad()
        );
        uint256 cost6 = _roundDebit(costWad);

        uint256 fee6 = _quoteFee(
            true,
            msg.sender,
            position.marketId,
            position.lowerTick,
            position.upperTick,
            additionalQuantity,
            cost6
        );
        uint256 totalCost = cost6 + fee6;
        require(totalCost <= maxCost, CE.CostExceedsMaximum(totalCost, maxCost));
        
        // Transfer payment from caller
        _pullUSDC(msg.sender, cost6);
        if (fee6 > 0) {
            _pullUSDC(msg.sender, fee6);
            _pushUSDC(_resolveFeeRecipient(), fee6);
        }
        
        // Update market state
        uint256 deltaWad = uint256(additionalQuantity).toWad();
        _applyFactorChunked(position.marketId, position.lowerTick, position.upperTick, deltaWad, market.liquidityParameter, true);
        
        // Update position quantity
        newQuantity = position.quantity + additionalQuantity;
        positionContract.updateQuantity(positionId, newQuantity);
        
        emit PositionIncreased(positionId, msg.sender, additionalQuantity, newQuantity, cost6);

        if (fee6 > 0) {
            emit TradeFeeCharged(
                msg.sender,
                position.marketId,
                positionId,
                true,
                cost6,
                fee6,
                market.feePolicy
            );
        }
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function decreasePosition(
        uint256 positionId,
        uint128 sellQuantity,
        uint256 minProceeds
    ) external override whenNotPaused nonReentrant returns (uint128 newQuantity, uint256 proceeds) {
        require(sellQuantity != 0, CE.InvalidQuantity(sellQuantity));
        
        // Get position data and validate market
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        address trader = positionContract.ownerOf(positionId);
        
        // Verify caller owns the position
        require(trader == msg.sender, CE.UnauthorizedCaller(msg.sender));
        
        _validateActiveMarket(position.marketId);
        Market storage market = markets[position.marketId];
        
        require(sellQuantity <= position.quantity, CE.InsufficientPositionQuantity(sellQuantity, position.quantity));
        
        // Calculate proceeds with round-up for fair treatment
        uint256 proceedsWad = _calculateSellProceeds(
            position.marketId,
            position.lowerTick,
            position.upperTick,
            uint256(sellQuantity).toWad()
        );
        uint256 baseProceeds = _roundCredit(proceedsWad);
        
        uint256 fee6 = _quoteFee(
            false,
            msg.sender,
            position.marketId,
            position.lowerTick,
            position.upperTick,
            sellQuantity,
            baseProceeds
        );

        if (fee6 > baseProceeds) {
            revert CE.FeeExceedsBase(fee6, baseProceeds);
        }
        uint256 netProceeds = baseProceeds - fee6;
        
        require(netProceeds >= minProceeds, CE.ProceedsBelowMinimum(netProceeds, minProceeds));
        
        // Update market state
        uint256 sellDeltaWad = uint256(sellQuantity).toWad();
        _applyFactorChunked(position.marketId, position.lowerTick, position.upperTick, sellDeltaWad, market.liquidityParameter, false);
        
        // Transfer proceeds to caller
        _pushUSDC(msg.sender, netProceeds);
        if (fee6 > 0) {
            _pushUSDC(_resolveFeeRecipient(), fee6);
        }
        
        // Update position quantity
        newQuantity = position.quantity - sellQuantity;
        if (newQuantity == 0) {
            // Burn position if quantity becomes zero
            positionContract.burn(positionId);
        } else {
            positionContract.updateQuantity(positionId, newQuantity);
        }
        
        emit PositionDecreased(positionId, msg.sender, sellQuantity, newQuantity, baseProceeds);

        if (fee6 > 0) {
            emit TradeFeeCharged(
                msg.sender,
                position.marketId,
                positionId,
                false,
                baseProceeds,
                fee6,
                market.feePolicy
            );
        }

        proceeds = netProceeds;
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function claimPayout(
        uint256 positionId
    ) external override whenNotPaused nonReentrant returns (uint256 payout) {
        // Get position data
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        address trader = positionContract.ownerOf(positionId);
        
        // Verify caller owns the position
        require(trader == msg.sender, CE.UnauthorizedCaller(msg.sender));
        
        Market memory market = markets[position.marketId];
        require(market.settled, CE.MarketNotSettled(position.marketId));

        uint64 T = market.settlementTimestamp == 0 ? market.endTimestamp : market.settlementTimestamp;
        uint64 claimOpen = T + SETTLEMENT_FINALIZE_DEADLINE;
        require(block.timestamp >= claimOpen, CE.SettlementTooEarly(claimOpen, uint64(block.timestamp)));
        
        // Calculate payout and emit PositionSettled once if not already
        payout = _calculateClaimAmount(positionId);
        bool isWin = payout > 0;
        if (!positionSettledEmitted[positionId]) {
            emit PositionSettled(positionId, trader, payout, isWin);
            positionSettledEmitted[positionId] = true;
        }

        // Transfer payout to caller
        _pushUSDC(msg.sender, payout);

        // Burn position NFT (position is claimed)
        positionContract.burn(positionId);

    emit PositionClaimed(positionId, msg.sender, payout);
}

    /// @inheritdoc ICLMSRMarketCore
    function closePosition(
        uint256 positionId,
        uint256 minProceeds
    ) external override whenNotPaused nonReentrant returns (uint256 proceeds) {
        // Get position data and validate market
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        address trader = positionContract.ownerOf(positionId);

        // Verify caller owns the position
        require(trader == msg.sender, CE.UnauthorizedCaller(msg.sender));

        _validateActiveMarket(position.marketId);
        Market storage market = markets[position.marketId];

        // Calculate proceeds from closing entire position with round-up for fair treatment
        uint256 positionQuantityWad = FixedPointMathU.toWad(uint256(position.quantity));
        uint256 proceedsWad = _calculateSellProceeds(
            position.marketId,
            position.lowerTick,
            position.upperTick,
            positionQuantityWad
        );
        uint256 baseProceeds = _roundCredit(proceedsWad);

        uint256 fee6 = _quoteFee(
            false,
            msg.sender,
            position.marketId,
            position.lowerTick,
            position.upperTick,
            position.quantity,
            baseProceeds
        );

        if (fee6 > baseProceeds) {
            revert CE.FeeExceedsBase(fee6, baseProceeds);
        }
        uint256 netProceeds = baseProceeds - fee6;

        require(netProceeds >= minProceeds, CE.ProceedsBelowMinimum(netProceeds, minProceeds));

        // Update market state (selling entire position)
        _applyFactorChunked(
            position.marketId,
            position.lowerTick,
            position.upperTick,
            positionQuantityWad,
            market.liquidityParameter,
            false
        );

        // Transfer proceeds to caller
        _pushUSDC(msg.sender, netProceeds);
        if (fee6 > 0) {
            _pushUSDC(_resolveFeeRecipient(), fee6);
        }

        // Burn position NFT
        positionContract.burn(positionId);

        emit PositionClosed(positionId, msg.sender, baseProceeds);

        if (fee6 > 0) {
            emit TradeFeeCharged(
                msg.sender,
                position.marketId,
                positionId,
                false,
                baseProceeds,
                fee6,
                market.feePolicy
            );
        }

        proceeds = netProceeds;
    }

    // ========================================
    // CALCULATION FUNCTIONS
    // ========================================
    
    /// @inheritdoc ICLMSRMarketCore
    function calculateOpenCost(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity
    ) external view override marketExists(marketId) returns (uint256 cost) {
        require(quantity != 0, CE.InvalidQuantity(quantity));
        
        Market memory market = markets[marketId];
        _validateTick(lowerTick, market);
        _validateTick(upperTick, market);
        
        require(lowerTick <= upperTick, CE.InvalidTickRange(lowerTick, upperTick));
        
        // üö® NO POINT BETTING: Reject same tick betting
        require(lowerTick != upperTick, CE.InvalidTickRange(lowerTick, upperTick));
        
        // ‚úÖ RANGE BETTING: Allow any valid range (single or multiple intervals)
        // Must be aligned to tick spacing
        require(
            (upperTick - lowerTick) % market.tickSpacing == 0,
            CE.InvalidTickRange(lowerTick, upperTick)
        );
        
        // Convert quantity to WAD for internal calculation
        uint256 quantityWad = uint256(quantity).toWad();
        uint256 costWad = _calculateTradeCostInternal(marketId, lowerTick, upperTick, quantityWad);
        // Convert cost back to 6-decimal for external interface with round-up
        return _roundDebit(costWad);
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function calculateIncreaseCost(
        uint256 positionId,
        uint128 additionalQuantity
    ) external view override returns (uint256 cost) {
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        uint256 quantityWad = uint256(additionalQuantity).toWad();
        uint256 costWad = _calculateTradeCostInternal(
            position.marketId,
            position.lowerTick,
            position.upperTick,
            quantityWad
        );
        return _roundDebit(costWad);
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function calculateDecreaseProceeds(
        uint256 positionId,
        uint128 sellQuantity
    ) external view override returns (uint256 proceeds) {
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        uint256 quantityWad = uint256(sellQuantity).toWad();
        uint256 proceedsWad = _calculateSellProceeds(
            position.marketId,
            position.lowerTick,
            position.upperTick,
            quantityWad
        );
        return _roundCredit(proceedsWad);
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function calculateCloseProceeds(
        uint256 positionId
    ) external view override returns (uint256 proceeds) {
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        uint256 quantityWad = uint256(position.quantity).toWad();
        uint256 proceedsWad = _calculateSellProceeds(
            position.marketId,
            position.lowerTick,
            position.upperTick,
            quantityWad
        );
        return _roundCredit(proceedsWad);
    }

    
    /// @inheritdoc ICLMSRMarketCore
    function calculateClaimAmount(
        uint256 positionId
    ) external view override returns (uint256 amount) {
        return _calculateClaimAmount(positionId);
    }
    
    /// @inheritdoc ICLMSRMarketCore
    function calculateQuantityFromCost(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint256 cost
    ) external view override marketExists(marketId) returns (uint128 quantity) {
        if (cost == 0) {
            return 0;
        }
        
        Market memory market = markets[marketId];
        _validateTick(lowerTick, market);
        _validateTick(upperTick, market);
        
        require(lowerTick <= upperTick, CE.InvalidTickRange(lowerTick, upperTick));
        
        // üö® NO POINT BETTING: Reject same tick betting
        require(lowerTick != upperTick, CE.InvalidTickRange(lowerTick, upperTick));
        
        // ‚úÖ RANGE BETTING: Allow any valid range (single or multiple intervals)
        // Must be aligned to tick spacing
        require(
            (upperTick - lowerTick) % market.tickSpacing == 0,
            CE.InvalidTickRange(lowerTick, upperTick)
        );
        
        // Convert cost to WAD for internal calculation
        uint256 costWad = uint256(cost).toWad();
        uint256 quantityWad = _calculateQuantityFromCostInternal(marketId, lowerTick, upperTick, costWad);
        
        // Convert quantity back to 6-decimal for external interface
        uint256 quantityValue = _roundCredit(quantityWad);
        
        // Ensure result fits in uint128
        require(quantityValue <= type(uint128).max, CE.QuantityOverflow());
        
        return uint128(quantityValue);
    }

    // ========================================
    // INTERNAL FUNCTIONS
    // ========================================

    /// @notice Internal pause implementation
    function _pauseWithReason(string memory reason) internal {
        super._pause();
        emit EmergencyPaused(msg.sender, reason);
    }

    /// @notice Authorize upgrade (only owner)
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    // ----------------------------------------
    // Tick validation and conversion
    // ----------------------------------------

    /// @notice Validate market parameters
    /// @param minTick Minimum tick value
    /// @param maxTick Maximum tick value
    /// @param tickSpacing Tick spacing
    function _validateMarketParameters(int256 minTick, int256 maxTick, int256 tickSpacing) internal pure {
        require(minTick < maxTick, CE.InvalidMarketParameters(minTick, maxTick, tickSpacing));

        require(tickSpacing > 0, CE.InvalidMarketParameters(minTick, maxTick, tickSpacing));

        // Check that the range is divisible by tickSpacing
        require(
            (maxTick - minTick) % tickSpacing == 0,
            CE.InvalidMarketParameters(minTick, maxTick, tickSpacing)
        );
    }

    /// @notice Calculate number of tick ranges for a market
    /// @param minTick Minimum tick value
    /// @param maxTick Maximum tick value
    /// @param tickSpacing Tick spacing
    /// @return numBins Number of bins (tick ranges, not tick points)
    function _calculateNumBins(int256 minTick, int256 maxTick, int256 tickSpacing) internal pure returns (uint32) {
        int256 range = maxTick - minTick;
        int256 ranges = range / tickSpacing; // No +1 for ranges
        require(ranges > 0 && ranges <= int256(uint256(MAX_TICK_COUNT)), CE.InvalidRangeCount(ranges, MAX_TICK_COUNT));
        return uint32(uint256(ranges));
    }

    /// @notice Validate that a tick is within market bounds and follows spacing
    /// @param tick Tick to validate
    /// @param market Market data
    function _validateTick(int256 tick, Market memory market) internal pure {
        require(
            tick >= market.minTick && tick <= market.maxTick,
            CE.InvalidTick(tick, market.minTick, market.maxTick)
        );

        require(
            (tick - market.minTick) % market.tickSpacing == 0,
            CE.InvalidTickSpacing(tick, market.tickSpacing)
        );
    }

    /// @notice Convert tick range to segment tree bin
    /// @param lowerTick Lower bound of range (inclusive)
    /// @param upperTick Upper bound of range (exclusive)
    /// @param market Market data
    /// @return bin Segment tree bin (0-based)
    function _rangeToBin(int256 lowerTick, int256 upperTick, Market memory market) internal pure returns (uint32) {
        // Validate range format
        require(
            upperTick == lowerTick + market.tickSpacing,
            CE.InvalidTickRange(lowerTick, upperTick)
        );

        int256 binInt = (lowerTick - market.minTick) / market.tickSpacing;
        require(binInt >= 0 && binInt < int256(uint256(market.numBins)), CE.RangeBinOutOfBounds(binInt, market.numBins));
        return uint32(uint256(binInt));
    }

    /// @notice Convert segment tree bin to tick range
    /// @param bin Segment tree bin (0-based)
    /// @param market Market data
    /// @return lowerTick Lower bound of range (inclusive)
    /// @return upperTick Upper bound of range (exclusive)
    function _binToRange(uint32 bin, Market memory market) internal pure returns (int256 lowerTick, int256 upperTick) {
        require(bin < market.numBins, CE.BinOutOfBounds(bin, market.numBins));
        lowerTick = market.minTick + int256(uint256(bin)) * market.tickSpacing;
        upperTick = lowerTick + market.tickSpacing;
    }

    /// @notice Validate that a range is properly formatted
    /// @param lowerTick Lower bound (inclusive)
    /// @param upperTick Upper bound (exclusive)
    /// @param market Market data
    function _validateRange(int256 lowerTick, int256 upperTick, Market memory market) internal pure {
        // Range must be exactly one tick spacing
        require(
            upperTick == lowerTick + market.tickSpacing,
            CE.InvalidTickRange(lowerTick, upperTick)
        );

        // Lower tick must be valid and aligned
        _validateTick(lowerTick, market);

        // Upper tick must be within bounds (but can equal maxTick for last range)
        require(
            upperTick <= market.maxTick,
            CE.InvalidTick(upperTick, market.minTick, market.maxTick)
        );
    }

    /// @notice Convert betting range to segment tree bins
    /// @param lowerTick Range lower boundary (inclusive)
    /// @param upperTick Range upper boundary (exclusive)
    /// @param market Market data
    /// @return loBin Starting bin
    /// @return hiBin Ending bin (inclusive in segment tree range)
    function _rangeToBins(int256 lowerTick, int256 upperTick, Market memory market)
        internal
        pure
        returns (uint32 loBin, uint32 hiBin)
    {
        loBin = uint32(uint256((lowerTick - market.minTick) / market.tickSpacing));
        hiBin = uint32(uint256((upperTick - market.minTick) / market.tickSpacing - 1));

        require(loBin < market.numBins && hiBin < market.numBins, CE.RangeBinsOutOfBounds(loBin, hiBin, market.numBins));
        require(loBin <= hiBin, CE.InvalidRangeBins(loBin, hiBin));
    }

    // ----------------------------------------
    // Internal helpers
    // ----------------------------------------

    /// @notice Check if market exists
    function _marketExists(uint256 marketId) internal view returns (bool) {
        return markets[marketId].numBins > 0;
    }

    /// @notice Pull USDC from user (6-decimal amount)
    function _pullUSDC(address from, uint256 amt6) internal {
        if (amt6 > 0) {
            uint256 balance = paymentToken.balanceOf(from);
            require(balance >= amt6, CE.InsufficientBalance(from, amt6, balance));
            paymentToken.safeTransferFrom(from, address(this), amt6);
        }
    }

    /// @notice Push USDC to user (6-decimal amount)
    function _pushUSDC(address to, uint256 amt6) internal {
        if (amt6 > 0) {
            paymentToken.safeTransfer(to, amt6);
        }
    }

    /// @notice Calculate trade cost with 6-decimal input, returns WAD
    function _calcCostInWad(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 qty6
    ) internal view returns (uint256 costWad) {
        uint256 qtyWad = uint256(qty6).toWad();
        return _calculateTradeCostInternal(marketId, lowerTick, upperTick, qtyWad);
    }
    // INTERNAL CALCULATION FUNCTIONS
    // ========================================

    /// @dev Calculate exp(q/Œ±) safely by chunking to avoid overflow
    /// @param q Quantity in WAD format
    /// @param alpha Liquidity parameter in WAD format
    /// @return res Result of exp(q/Œ±) in WAD format
    function _safeExp(uint256 q, uint256 alpha) internal pure returns (uint256 res) {
        uint256 maxPerChunk = alpha.wMul(MAX_EXP_INPUT_WAD); // Œ± * 1.0
        res = FixedPointMathU.WAD; // 1.0
        
        while (q > 0) {
            uint256 chunk = q > maxPerChunk ? maxPerChunk : q;
            uint256 factor = (chunk.wDiv(alpha)).wExp(); // Safe: chunk/Œ± ‚â§ 1.0
            res = res.wMul(factor);
            q -= chunk;
        }
    }
    
    /// @notice Calculate quantity that can be bought with given cost (inverse function)
    /// @dev Implements inverse of CLMSR formula: from C = Œ± * ln(Œ£_after / Œ£_before), solve for q
    /// @param marketId Market identifier
    /// @param lowerTick Lower tick bound (inclusive)
    /// @param upperTick Upper tick bound (exclusive)
    /// @param costWad Target cost in WAD format
    /// @return quantityWad Purchasable quantity in WAD format
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function _calculateQuantityFromCostInternal(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint256 costWad
    ) internal view returns (uint256 quantityWad) {
        Market memory market = markets[marketId];
        uint256 alpha = market.liquidityParameter;
        
        // Convert range to bins
        (uint32 loBin, uint32 hiBin) = _rangeToBins(lowerTick, upperTick, market);
        
        // Get current state with proper lazy propagation
        // Use getRangeSum for entire tree to get accurate total with lazy values
        uint256 sumBefore = marketTrees[marketId].cachedRootSum;
        uint256 affectedSum = LazyMulSegmentTree.getRangeSum(marketTrees[marketId], loBin, hiBin);
        
        // Ensure tree is properly initialized
        require(sumBefore != 0, CE.TreeNotInitialized());

        require(affectedSum != 0, CE.AffectedSumZero());
        
        // Direct mathematical inverse:
        // From: C = Œ± * ln(sumAfter / sumBefore)
        // Calculate: q = Œ± * ln(factor)
        
        // Calculate target sum after: sumAfter = sumBefore * exp(C/Œ±) - use safe chunking
        uint256 expValue = _safeExp(costWad, alpha);
        uint256 targetSumAfter = sumBefore.wMul(expValue);
        
        // Calculate required affected sum after trade
        uint256 requiredAffectedSum = targetSumAfter - (sumBefore - affectedSum);
        
        // Calculate factor: newAffectedSum / affectedSum
        uint256 factor = requiredAffectedSum.wDiv(affectedSum);
        
        // Calculate quantity: q = Œ± * ln(factor)
        quantityWad = alpha.wMul(factor.wLn());
    }
    
    /// @notice Calculate cost of a trade using CLMSR formula with chunk-split logic
    /// @dev CLMSR formula: C = Œ± * ln(Œ£_after / Œ£_before) where each tick has exp(q_i/Œ±)
    function _calculateTradeCostInternal(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint256 quantity
    ) internal view returns (uint256 cost) {
        Market memory market = markets[marketId];
        
        // Convert range to bins
        (uint32 loBin, uint32 hiBin) = _rangeToBins(lowerTick, upperTick, market);
        
        uint256 totalQuantity = quantity;
        uint256 alpha = market.liquidityParameter;
        uint256 maxSafeQuantityPerChunk = _maxSafeChunkQuantity(alpha);
        
        if (totalQuantity <= maxSafeQuantityPerChunk) {
            // Safe to calculate in single operation
            return _calculateSingleTradeCost(marketId, lowerTick, upperTick, totalQuantity, alpha);
        } else {
            // Split into chunks with proper cumulative calculation
            uint256 sumBefore = marketTrees[marketId].cachedRootSum;
            uint256 affectedSum = LazyMulSegmentTree.getRangeSum(marketTrees[marketId], loBin, hiBin);
            
            // Ensure tree is properly initialized
            require(sumBefore != 0, CE.TreeNotInitialized());
            
            // Calculate required number of chunks and prevent gas DoS
            uint256 requiredChunks = (totalQuantity + maxSafeQuantityPerChunk - 1) / maxSafeQuantityPerChunk;
            
            require(requiredChunks <= MAX_CHUNKS_PER_TX, CE.ChunkLimitExceeded(requiredChunks, MAX_CHUNKS_PER_TX));
            
            // Chunk-split with cumulative state tracking
            uint256 cumulativeCostWad = 0;
            uint256 remainingQuantity = totalQuantity;
            uint256 currentSumBefore = sumBefore;
            uint256 currentAffectedSum = affectedSum;
            uint256 chunkCount = 0;
            
            while (remainingQuantity > 0 && chunkCount < MAX_CHUNKS_PER_TX) {
                uint256 chunkQuantity = remainingQuantity > maxSafeQuantityPerChunk 
                    ? maxSafeQuantityPerChunk 
                    : remainingQuantity;
                
                // Calculate factor for this chunk
                uint256 quantityScaled = chunkQuantity.wDiv(alpha);
                uint256 factor = quantityScaled.wExp();
                
                // ‚ú® Adaptive overflow guard: check if multiplication would overflow
                if (currentAffectedSum > type(uint256).max / factor) {
                    // Reduce chunk size to prevent overflow
                    chunkQuantity = _computeSafeChunk(
                        currentAffectedSum, 
                        alpha, 
                        remainingQuantity, 
                        MAX_CHUNKS_PER_TX - chunkCount
                    );
                    
                    // Ensure chunk makes meaningful progress
                    if (chunkQuantity > remainingQuantity) {
                        chunkQuantity = remainingQuantity;
                    }
                    
                    quantityScaled = chunkQuantity.wDiv(alpha);
                    factor = quantityScaled.wExp();
                }
                
                // Calculate new sums after this chunk with overflow protection
                uint256 newAffectedSum;
                
                // Additional safety check: verify multiplication won't overflow in wMul
                require(
                    currentAffectedSum == 0 ||
                        factor <= type(uint256).max / currentAffectedSum,
                    CE.MathMulOverflow()
                );
                
                newAffectedSum = currentAffectedSum.wMulNearest(factor);
                uint256 sumAfter = currentSumBefore - currentAffectedSum + newAffectedSum;
                
                // Calculate cost for this chunk: Œ± * ln(sumAfter / sumBefore)
                require(sumAfter > currentSumBefore, CE.NonIncreasingSum(currentSumBefore, sumAfter));
                uint256 ratio = sumAfter.wDivUp(currentSumBefore);
                uint256 chunkCost = alpha.wMul(ratio.wLn());
                cumulativeCostWad += chunkCost;

                // Ensure we make progress to prevent infinite loops
                require(chunkQuantity != 0, CE.NoChunkProgress());

                // Update state for next chunk
                currentSumBefore = sumAfter;
                currentAffectedSum = newAffectedSum;
                remainingQuantity -= chunkQuantity;
                chunkCount++;
            }
            
            // Additional safety check
            require(remainingQuantity == 0, CE.ResidualQuantity(remainingQuantity));

            return cumulativeCostWad;
        }
    }
    
    /// @notice Calculate cost for a single chunk (small quantity)
    function _calculateSingleTradeCost(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint256 quantity,
        uint256 alpha
    ) internal view returns (uint256 cost) {
        // Get current sum before trade with proper lazy propagation
        Market memory market = markets[marketId];
        uint256 sumBefore = marketTrees[marketId].cachedRootSum;
        
        // Calculate multiplicative factor: exp(quantity / Œ±)
        uint256 quantityScaled = quantity.wDiv(alpha);
        uint256 factor = quantityScaled.wExp();
        
        // Calculate sum after trade - convert range to bins
        (uint32 loBin, uint32 hiBin) = _rangeToBins(lowerTick, upperTick, market);
        uint256 affectedSum = LazyMulSegmentTree.getRangeSum(marketTrees[marketId], loBin, hiBin);
        
        // Ensure tree is properly initialized
        require(sumBefore != 0, CE.TreeNotInitialized());
        
        // ‚ú® Check for overflow before multiplication - fallback to chunked mode if needed
        if (affectedSum > type(uint256).max / factor) {
            // Fallback to chunked calculation to handle large affected sums
            return _calculateTradeCostInternal(marketId, lowerTick, upperTick, quantity);
        }
        
        uint256 sumAfter = sumBefore - affectedSum + affectedSum.wMulNearest(factor);
        // Regular trade: C = Œ± * ln(Œ£_after / Œ£_before)
        if (sumAfter <= sumBefore) {
            return 0; // No cost if sum doesn't increase
        }
        
        uint256 ratio = sumAfter.wDivUp(sumBefore);
        uint256 lnRatio = ratio.wLn();
        cost = alpha.wMul(lnRatio);
    }
    
    /// @notice Calculate proceeds from selling quantity
    /// @dev CLMSR formula with exp(-quantity/Œ±) factor applied to affected ticks
    /// @notice Calculate sell proceeds with safe chunk splitting for large quantities
    function _calculateSellProceeds(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint256 quantity
    ) internal view returns (uint256 proceeds) {
        Market memory market = markets[marketId];
        
        // Convert range to bins
        (uint32 loBin, uint32 hiBin) = _rangeToBins(lowerTick, upperTick, market);
        
        uint256 totalQuantity = quantity;
        uint256 alpha = market.liquidityParameter;
        uint256 maxSafeQuantityPerChunk = _maxSafeChunkQuantity(alpha);
        
        if (totalQuantity <= maxSafeQuantityPerChunk) {
            // Safe to calculate in single operation
            return _calculateSingleSellProceeds(marketId, lowerTick, upperTick, totalQuantity, alpha);
        } else {
            // Split into chunks with proper cumulative calculation
            uint256 sumBefore = marketTrees[marketId].cachedRootSum;
            uint256 affectedSum = LazyMulSegmentTree.getRangeSum(marketTrees[marketId], loBin, hiBin);
            
            // Ensure tree is properly initialized
            require(sumBefore != 0, CE.TreeNotInitialized());

            // Calculate required number of chunks and prevent gas DoS
            uint256 requiredChunks = (totalQuantity + maxSafeQuantityPerChunk - 1) / maxSafeQuantityPerChunk;

            require(requiredChunks <= MAX_CHUNKS_PER_TX, CE.ChunkLimitExceeded(requiredChunks, MAX_CHUNKS_PER_TX));
            
            // Chunk-split with cumulative state tracking
            uint256 cumulativeProceedsWad = 0;
            uint256 remainingQuantity = totalQuantity;
            uint256 currentSumBefore = sumBefore;
            uint256 currentAffectedSum = affectedSum;
            uint256 chunkCount = 0;
            
            while (remainingQuantity > 0 && chunkCount < MAX_CHUNKS_PER_TX) {
                uint256 chunkQuantity = remainingQuantity > maxSafeQuantityPerChunk 
                    ? maxSafeQuantityPerChunk 
                    : remainingQuantity;
                
                // Calculate inverse factor for this chunk: 1 / exp(quantity/Œ±)
                uint256 quantityScaled = chunkQuantity.wDiv(alpha);
                uint256 factor = quantityScaled.wExp();
                // Use ceil division so sell-side rounding mirrors sequential per-chunk execution
                uint256 inverseFactor = FixedPointMathU.WAD.wDivUp(factor);
                
                // ‚ú® Adaptive overflow guard: check if multiplication would overflow
                if (currentAffectedSum > type(uint256).max / inverseFactor) {
                    // Reduce chunk size to prevent overflow
                    chunkQuantity = _computeSafeChunk(
                        currentAffectedSum, 
                        alpha, 
                        remainingQuantity, 
                        MAX_CHUNKS_PER_TX - chunkCount
                    );
                    
                    // Ensure chunk makes meaningful progress
                    if (chunkQuantity > remainingQuantity) {
                        chunkQuantity = remainingQuantity;
                    }
                    
                    quantityScaled = chunkQuantity.wDiv(alpha);
                    factor = quantityScaled.wExp();
                    // Maintain ceil rounding symmetry after chunk size adjustment
                    inverseFactor = FixedPointMathU.WAD.wDivUp(factor);
                }
                
                // Calculate new sums after this chunk with overflow protection
                uint256 newAffectedSum;
                
                // Additional safety check: verify multiplication won't overflow in wMul
                require(
                    currentAffectedSum == 0 ||
                        inverseFactor <= type(uint256).max / currentAffectedSum,
                    CE.MathMulOverflow()
                );
                
                newAffectedSum = currentAffectedSum.wMulNearest(inverseFactor);
                uint256 sumAfter = currentSumBefore - currentAffectedSum + newAffectedSum;
                
                // Safety check: ensure sumAfter > 0 to prevent division by zero
                require(sumAfter != 0, CE.SumAfterZero());
                
                // Calculate proceeds for this chunk: Œ± * ln(sumBefore / sumAfter)
                if (currentSumBefore > sumAfter) {
                    uint256 ratio = currentSumBefore.wDivUp(sumAfter);
                    uint256 chunkProceeds = alpha.wMul(ratio.wLn());
                    cumulativeProceedsWad += chunkProceeds;
                }

                // Ensure we make progress to prevent infinite loops
                require(chunkQuantity != 0, CE.NoChunkProgress());

                // Update state for next chunk
                currentSumBefore = sumAfter;
                currentAffectedSum = newAffectedSum;
                remainingQuantity -= chunkQuantity;
                chunkCount++;
            }
            
            // Additional safety check
            require(remainingQuantity == 0, CE.ResidualQuantity(remainingQuantity));

            return cumulativeProceedsWad;
        }
    }
    
    /// @notice Calculate proceeds for a single chunk (small quantity)
    function _calculateSingleSellProceeds(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint256 quantity,
        uint256 alpha
    ) internal view returns (uint256 proceeds) {
        // Get current sum before sell with proper lazy propagation
        Market memory market = markets[marketId];
        uint256 sumBefore = marketTrees[marketId].cachedRootSum;
        
        // Calculate multiplicative factor: exp(-quantity / Œ±) = 1 / exp(quantity / Œ±)
        uint256 quantityScaled = quantity.wDiv(alpha);
        uint256 factor = quantityScaled.wExp();
        uint256 inverseFactor = FixedPointMathU.WAD.wDivUp(factor);
        
        // Calculate sum after sell - convert range to indices
        (uint32 loBin, uint32 hiBin) = _rangeToBins(lowerTick, upperTick, market);
        uint256 affectedSum = LazyMulSegmentTree.getRangeSum(marketTrees[marketId], loBin, hiBin);
        
        // ‚ú® Check for overflow before multiplication - fallback to chunked mode if needed
        if (affectedSum > type(uint256).max / inverseFactor) {
            // Fallback to chunked calculation to handle large affected sums
            return _calculateSellProceeds(marketId, lowerTick, upperTick, quantity);
        }
        
        uint256 sumAfter = sumBefore - affectedSum + affectedSum.wMulNearest(inverseFactor);
        
        // Safety check: ensure sumAfter > 0 to prevent division by zero
        require(sumAfter != 0, CE.SumAfterZero());
        
        // CLMSR proceeds formula: Œ± * ln(sumBefore / sumAfter)
        if (sumBefore <= sumAfter) {
            return 0; // No proceeds if sum doesn't decrease
        }
        
        uint256 ratio = sumBefore.wDivUp(sumAfter);
        uint256 lnRatio = ratio.wLn();
        proceeds = alpha.wMul(lnRatio);
    }
    
    /// @notice Compute safe chunk size to prevent overflow in multiplication
    /// @param currentSum Current affected sum that will be multiplied
    /// @param alpha Liquidity parameter
    /// @param remainingQty Remaining quantity to process
    /// @param chunksLeft Number of chunks remaining (MAX_CHUNKS_PER_TX - chunkCount)
    /// @return safeChunk Safe chunk quantity that won't cause overflow
    function _computeSafeChunk(
        uint256 currentSum, 
        uint256 alpha, 
        uint256 remainingQty, 
        uint256 chunksLeft
    ) internal pure returns (uint256 safeChunk) {
        // If no chunks left, return remaining quantity
        if (chunksLeft == 0) return remainingQty;
        
        // Calculate minimum progress needed to complete within remaining chunks
        uint256 minProgress = (remainingQty + chunksLeft - 1) / chunksLeft; // Ceiling division
        if (minProgress == 0) minProgress = 1; // Ensure at least 1 wei progress
        
        // Calculate maximum safe quantity based on exponential limits
        uint256 maxSafeQuantity = alpha.wMul(MAX_EXP_INPUT_WAD);
        
        // If currentSum is large, be more conservative to prevent overflow
        if (currentSum > alpha.wMul(50e18)) { // 50x alpha threshold (50e18 = 50 * WAD)
            maxSafeQuantity = alpha / 10; // Very conservative
        }
        
        // Choose the minimum to ensure both progress and safety
        safeChunk = minProgress < maxSafeQuantity ? minProgress : maxSafeQuantity;
        
        // Final safety check - ensure we don't exceed remaining quantity
        if (safeChunk > remainingQty) {
            safeChunk = remainingQty;
        }
    }

    /// @notice Calculate claimable amount from settled position
    function _calculateClaimAmount(uint256 positionId) internal view returns (uint256 amount) {
        ICLMSRPosition.Position memory position = positionContract.getPosition(positionId);
        Market memory market = markets[position.marketId];
        
        if (!market.settled) {
            return 0;
        }
        
        // Check if settlement tick is within position range [lowerTick, upperTick)
        bool hasWinning = (position.lowerTick <= market.settlementTick && 
                          position.upperTick > market.settlementTick);
        
        if (hasWinning) {
            // Position wins - return quantity as payout
            amount = uint256(position.quantity);
        } else {
            // Position loses - no payout
            amount = 0;
        }
    }
    
    /// @notice Update market state for a trade (buy)
    /// @dev Use mulRange to apply exp(quantity/Œ±) factor, with chunk-split for large factors

    
    /// @notice Apply factor with chunk-split to handle large exponential values
    /// @dev Splits large quantity into safe chunks to avoid factor limits and gas DoS
    /// @param marketId Market identifier
    /// @param lowerTick Lower tick bound (inclusive)
    /// @param upperTick Upper tick bound (exclusive)
    /// @param quantity Total quantity to apply
    /// @param alpha Liquidity parameter
    /// @param isBuy True for buy (positive exp), false for sell (negative exp)
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function _applyFactorChunked(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint256 quantity,
        uint256 alpha,
        bool isBuy
    ) internal {
        // Get market data and convert range to bins
        Market memory market = markets[marketId];
        (uint32 loBin, uint32 hiBin) = _rangeToBins(lowerTick, upperTick, market);
        
        // Use fixed safe chunk size to avoid overflow in chunk calculations
        // This ensures that quantity/alpha ratios stay within safe bounds
        // for exponential calculations in PRB-Math
        uint256 maxSafeQuantityPerChunk = _maxSafeChunkQuantity(alpha);
        
        if (quantity <= maxSafeQuantityPerChunk) {
            // Safe to apply in single operation
            uint256 factor = (quantity.wDiv(alpha)).wExp();

            if (!isBuy) {
                // For sell, use inverse factor
                factor = FixedPointMathU.WAD.wDivUp(factor);
            }
            
            // Verify factor is within safe bounds
            require(
                factor >= LazyMulSegmentTree.MIN_FACTOR &&
                    factor <= LazyMulSegmentTree.MAX_FACTOR,
                CE.FactorOutOfBounds()
            );
            
            LazyMulSegmentTree.applyRangeFactor(marketTrees[marketId], loBin, hiBin, factor);
            // Use original tick values for event
            emit RangeFactorApplied(marketId, lowerTick, upperTick, factor);
        } else {
            // Calculate required number of chunks and prevent gas DoS
            uint256 requiredChunks = (quantity + maxSafeQuantityPerChunk - 1) / maxSafeQuantityPerChunk;
            
            require(
                requiredChunks <= MAX_CHUNKS_PER_TX,
                CE.ChunkLimitExceeded(requiredChunks, MAX_CHUNKS_PER_TX)
            );
            
            // Split into chunks with gas-efficient batch processing
            uint256 remainingQuantity = quantity;
            uint256 chunkCount = 0;
            
            while (remainingQuantity > 0 && chunkCount < MAX_CHUNKS_PER_TX) {
                uint256 chunkQuantity = remainingQuantity > maxSafeQuantityPerChunk 
                    ? maxSafeQuantityPerChunk 
                    : remainingQuantity;
                
                uint256 factor = (chunkQuantity.wDiv(alpha)).wExp();

                if (!isBuy) {
                    // For sell, use inverse factor
                    factor = FixedPointMathU.WAD.wDivUp(factor);
                }

                // Verify factor is within safe bounds for each chunk
                require(
                    factor >= LazyMulSegmentTree.MIN_FACTOR &&
                        factor <= LazyMulSegmentTree.MAX_FACTOR,
                    CE.FactorOutOfBounds()
                );

                LazyMulSegmentTree.applyRangeFactor(marketTrees[marketId], loBin, hiBin, factor);
                // Use original tick values for event
                emit RangeFactorApplied(marketId, lowerTick, upperTick, factor);
                
                remainingQuantity -= chunkQuantity;
                chunkCount++;
            }
            
            // Additional safety check
            require(remainingQuantity == 0, CE.IncompleteChunkProcessing());
        }
    }

    /// @notice Internal function to validate market is active and timing is correct
    function _validateActiveMarket(uint256 marketId) internal view {
        Market storage market = markets[marketId];
        require(market.isActive, CE.MarketNotActive());
        
        // Validate market timing
        require(block.timestamp >= market.startTimestamp, CE.MarketNotStarted());
        
        require(block.timestamp <= market.endTimestamp, CE.MarketExpired());
    }
    
} 

```


## contracts/core/CLMSRPosition.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "../interfaces/ICLMSRPosition.sol";
import {CLMSRErrors as CE} from "../errors/CLMSRErrors.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/// @title CLMSRPosition
/// @notice ERC721 implementation for CLMSR position management
/// @dev Gas-optimized position tokens with core authorization
contract CLMSRPosition is 
    Initializable,
    ICLMSRPosition, 
    ERC721Upgradeable,
    OwnableUpgradeable,
    UUPSUpgradeable
{
    using Strings for uint256;

    // ========================================
    // STORAGE LAYOUT (Gas Optimized)
    // ========================================
    
    /// @notice Core contract address for authorization
    address public core;
    
    /// @notice Next position ID to mint (starts at 1)
    uint256 private _nextId;
    
    /// @notice DEPRECATED: Total supply tracking (no longer maintained)
    uint256 private _totalSupply;
    
    /// @notice Position data mapping
    mapping(uint256 => ICLMSRPosition.Position) private _positions;
    
    /// @notice DEPRECATED: Owner tokens slot (no longer maintained)
    mapping(address => uint256) private _ownedTokensSlot;
    
    /// @dev Gap for future storage variables
    // MARKET-LOCAL TOKEN INDEXING
    mapping(uint256 => uint256[]) private _marketTokenList;
    mapping(uint256 => uint256) private _positionMarket; // DEPRECATED: no longer maintained
    mapping(uint256 => uint256) private _positionMarketIndex;
    uint256[47] private __gap;

    // ========================================
    // MODIFIERS
    // ========================================
    
    /// @notice Restricts access to core contract only
    modifier onlyCore() {
        require(msg.sender == core, CE.UnauthorizedCaller(msg.sender));
        _;
    }

    // ========================================
    // INITIALIZER
    // ========================================
    
    /// @notice Initialize the upgradeable position contract
    /// @param _core Core contract address
    function initialize(address _core) external initializer {
        // Allow CE.ZeroAddress temporarily for deployment, will be updated later
        
        __ERC721_init("CLMSR Position", "CLMSR-POS");
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        
        core = _core;
        _nextId = 1;
    }
    
    
    /// @notice Update core contract address (only owner)
    /// @param _newCore New core contract address
    function updateCore(address _newCore) external onlyOwner {
        require(_newCore != address(0), CE.ZeroAddress());
        core = _newCore;
    }

    // ========================================
    // ERC721 OVERRIDES
    // ========================================
    
    /// @notice Override tokenURI to provide dynamic metadata
    /// @param tokenId Position token ID
    /// @return URI string with base64-encoded JSON metadata
    function tokenURI(uint256 tokenId) public view override(ERC721Upgradeable) returns (string memory) {
        require(_exists(tokenId), CE.PositionNotFound(tokenId));
        
        ICLMSRPosition.Position memory position = _positions[tokenId];
        
        // Generate dynamic JSON metadata
        string memory json = string(abi.encodePacked(
            '{"name":"CLMSR Position #', tokenId.toString(), '",',
            '"description":"CLMSR Range Position",',
            '"attributes":[',
                '{"trait_type":"Market ID","value":', position.marketId.toString(), '},',
                '{"trait_type":"Lower Tick","value":', _int256ToString(position.lowerTick), '},',
                '{"trait_type":"Upper Tick","value":', _int256ToString(position.upperTick), '},',
                '{"trait_type":"Quantity","value":', uint256(position.quantity).toString(), '},',
                '{"trait_type":"Created At","value":', uint256(position.createdAt).toString(), '}',
            ']}'
        ));
        
        return string(abi.encodePacked(
            "data:application/json;base64,",
            Base64.encode(bytes(json))
        ));
    }


    // ========================================
    // POSITION MANAGEMENT (Core Only)
    // ========================================
    
    /// @inheritdoc ICLMSRPosition
    function mintPosition(
        address to,
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity
    ) external onlyCore returns (uint256 positionId) {
        require(to != address(0), CE.ZeroAddress());
        require(quantity != 0, CE.InvalidQuantity(quantity));
        
        positionId = _nextId++;
        
        // Store position data with gas-optimized packing
        _positions[positionId] = ICLMSRPosition.Position({
            marketId: marketId,
            lowerTick: lowerTick,
            upperTick: upperTick,
            quantity: quantity,
            createdAt: uint64(block.timestamp)
        });
        
        // Mint NFT
        _safeMint(to, positionId);
        
        // Market-local indexing
        _marketTokenList[marketId].push(positionId);
        _positionMarketIndex[positionId] = _marketTokenList[marketId].length; // 1-based index
        
        emit PositionMinted(positionId, to, marketId, lowerTick, upperTick, quantity);
    }

    /// @inheritdoc ICLMSRPosition
    function updateQuantity(uint256 positionId, uint128 newQuantity) external onlyCore {
        require(_exists(positionId), CE.PositionNotFound(positionId));
        require(newQuantity != 0, CE.InvalidQuantity(newQuantity));
        
        uint128 oldQuantity = _positions[positionId].quantity;
        _positions[positionId].quantity = newQuantity;
        
        emit PositionUpdated(positionId, oldQuantity, newQuantity);
    }

    /// @inheritdoc ICLMSRPosition
    function burn(uint256 positionId) external onlyCore {
        require(_exists(positionId), CE.PositionNotFound(positionId));
        
        address owner = ownerOf(positionId);
        uint256 marketId = _positions[positionId].marketId;
        uint256 idx1 = _positionMarketIndex[positionId];
        
        // Burn NFT 
        _burn(positionId);
        
        // Mark hole in market-local list and clear indexes
        if (idx1 != 0) {
            uint256 arrIndex = idx1 - 1; // convert to 0-based
            if (arrIndex < _marketTokenList[marketId].length) {
                _marketTokenList[marketId][arrIndex] = 0; // hole mark
            }
            delete _positionMarketIndex[positionId];
        }
        // No longer maintaining _positionMarket mapping

        // Clean up position data
        delete _positions[positionId];
        
        emit PositionBurned(positionId, owner);
    }



    // ========================================
    // POSITION QUERIES
    // ========================================
    
    /// @inheritdoc ICLMSRPosition
    function getPosition(uint256 positionId) external view returns (ICLMSRPosition.Position memory data) {
        require(_exists(positionId), CE.PositionNotFound(positionId));
        return _positions[positionId];
    }



    /// @inheritdoc ICLMSRPosition
    function exists(uint256 positionId) external view returns (bool) {
        return _exists(positionId);
    }


    // ========================================
    // ERC165 SUPPORT
    // ========================================
    
    /// @notice ERC165 interface support
    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        override(ERC721Upgradeable, IERC165) 
        returns (bool) 
    {
        return super.supportsInterface(interfaceId);
    }





    // ========================================
    // INTERNAL HELPERS
    // ========================================
    


    // ========================================
    // MARKET-LOCAL TOKEN INDEXING VIEWS
    // ========================================

    /// @inheritdoc ICLMSRPosition
    function getMarketTokenLength(uint256 marketId) external view override returns (uint256 length) {
        return _marketTokenList[marketId].length;
    }

    /// @inheritdoc ICLMSRPosition
    function getMarketTokenAt(uint256 marketId, uint256 index) external view override returns (uint256 tokenId) {
        return _marketTokenList[marketId][index];
    }




    // ========================================
    // INTERNAL FUNCTIONS
    // ========================================

    /// @notice Authorize upgrade (only owner)
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}


    /// @notice Convert int256 to string
    function _int256ToString(int256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }

        bool negative = value < 0;
        uint256 temp = negative ? uint256(-value) : uint256(value);

        bytes memory buffer = new bytes(78); // max length for int256
        uint256 digits;

        while (temp != 0) {
            digits++;
            buffer[78 - digits] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }

        if (negative) {
            digits++;
            buffer[78 - digits] = "-";
        }

        bytes memory result = new bytes(digits);
        for (uint256 i = 0; i < digits; i++) {
            result[i] = buffer[78 - digits + i];
        }

        return string(result);
    }

    /// @notice Check if token exists
    /// @param tokenId Token ID to check
    /// @return True if token exists
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _ownerOf(tokenId) != address(0);
    }
}

```


## contracts/core/storage/CLMSRMarketCoreStorage.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../../interfaces/ICLMSRMarketCore.sol";
import "../../interfaces/ICLMSRPosition.sol";
import "../../fees/interfaces/ICLMSRFeePolicy.sol";
import {LazyMulSegmentTree} from "../../libraries/LazyMulSegmentTree.sol";

/// @dev Í≥µÏú† Ïä§ÌÜ†Î¶¨ÏßÄ Î†àÏù¥ÏïÑÏõÉ: CoreÏôÄ ManagerÍ∞Ä ÎèôÏùº ÏàúÏÑúÎ°ú ÏÉÅÏÜçÌï¥Ïïº Ïä¨Î°ØÏù¥ ÏùºÏπòÌïúÎã§.
abstract contract CLMSRMarketCoreStorage {
    uint64 internal constant SETTLEMENT_SUBMIT_WINDOW = 10 minutes;
    uint64 internal constant SETTLEMENT_FINALIZE_DEADLINE = 15 minutes;

    IERC20 public paymentToken;
    ICLMSRPosition public positionContract;
    mapping(uint256 => ICLMSRMarketCore.Market) public markets;
    mapping(uint256 => LazyMulSegmentTree.Tree) public marketTrees;
    uint256 public _nextMarketId;
    mapping(uint256 => bool) public positionSettledEmitted;
    address public manager;
    ICLMSRFeePolicy public deprecatedFeePolicy;
    address public feeRecipient;

    struct SettlementOracleState {
        int256 candidateValue;
        uint64 candidatePriceTimestamp;
    }

    mapping(uint256 => SettlementOracleState) internal settlementOracleState;
    address public settlementOracleSigner;

    uint256[43] internal __gap;
}

```


## contracts/interfaces/ICLMSRMarketCore.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

/// @title ICLMSRMarketCore
/// @notice Upgradeable core interface for CLMSR Daily-Market System
/// @dev UUPS upgradeable contract handling core trading logic and market state
interface ICLMSRMarketCore {
    // ========================================
    // STRUCTS
    // ========================================
    
    /// @notice Market information
    struct Market {
        bool isActive;                  // Market is active
        bool settled;                   // Market is settled
        uint64 startTimestamp;          // Market start time
        uint64 endTimestamp;            // Market end time
        int256 settlementTick;          // Winning tick value (only if settled) - floored from settlementValue
        int256 minTick;                 // Minimum allowed tick value
        int256 maxTick;                 // Maximum allowed tick value
        int256 tickSpacing;             // Spacing between valid ticks
        uint32 numBins;                 // Number of bins in market (calculated)
        uint256 liquidityParameter;    // Alpha parameter (1e18 scale)
        
        // Position events emission state
        uint32 positionEventsCursor;    // Next emission start index
        bool positionEventsEmitted;     // All events emitted flag
        
        int256 settlementValue;         // Original settlement value with 6 decimals (only if settled)
        uint64 settlementTimestamp;     // Settlement reference time (when settlement data should be retrieved)
        address feePolicy;              // Fee policy assigned to this market
    }

    /// @notice Parameter bundle for market creation
    struct MarketCreationParams {
        int256 minTick;
        int256 maxTick;
        int256 tickSpacing;
        uint64 startTimestamp;
        uint64 endTimestamp;
        uint64 settlementTimestamp;
        uint256 liquidityParameter;
        address feePolicy;
    }
    

    // ========================================
    // EVENTS
    // ========================================
    
    event MarketCreated(
        uint256 indexed marketId,
        uint64 startTimestamp,
        uint64 endTimestamp,
        int256 minTick,
        int256 maxTick,
        int256 tickSpacing,
        uint32 numBins,
        uint256 liquidityParameter
    );

    event MarketSettled(
        uint256 indexed marketId,
        int256 settlementTick
    );

    event MarketSettlementCandidateSubmitted(
        uint256 indexed marketId,
        int256 settlementValue,
        int256 settlementTick,
        uint64 priceTimestamp,
        address indexed submitter,
        bytes oracleData
    );

    event MarketSettlementFinalized(
        uint256 indexed marketId,
        bool isFailed,
        int256 settlementValue,
        int256 settlementTick,
        uint64 priceTimestamp,
        uint64 finalizedAt
    );

    event MarketSettlementValueSubmitted(
        uint256 indexed marketId,
        int256 settlementValue
    );

    event PositionSettled(
        uint256 indexed positionId,
        address indexed trader,
        uint256 payout,
        bool isWin
    );

    event PositionEventsProgress(
        uint256 indexed marketId,
        uint256 from,
        uint256 to,
        bool done
    );

    event PositionOpened(
        uint256 indexed positionId,
        address indexed trader,
        uint256 indexed marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity,
        uint256 cost
    );

    event PositionIncreased(
        uint256 indexed positionId,
        address indexed trader,
        uint128 additionalQuantity,
        uint128 newQuantity,
        uint256 cost
    );

    event PositionDecreased(
        uint256 indexed positionId,
        address indexed trader,
        uint128 sellQuantity,
        uint128 newQuantity,
        uint256 proceeds
    );

    event PositionClosed(
        uint256 indexed positionId,
        address indexed trader,
        uint256 proceeds
    );

    event PositionClaimed(
        uint256 indexed positionId,
        address indexed trader,
        uint256 payout
    );

    event EmergencyPaused(
        address indexed by,
        string reason
    );

    event EmergencyUnpaused(
        address indexed by
    );

    event MarketTimingUpdated(
        uint256 indexed marketId,
        uint64 newStartTimestamp,
        uint64 newEndTimestamp
    );

    event MarketReopened(
        uint256 indexed marketId
    );

    event MarketActivationUpdated(
        uint256 indexed marketId,
        bool isActive
    );

    event RangeFactorBatchApplied(
        uint256 indexed marketId,
        uint256 operationCount,
        bytes32 context
    );

    event SettlementTimestampUpdated(
        uint256 indexed marketId,
        uint64 settlementTimestamp
    );

    event ManagerUpdated(
        address indexed oldManager,
        address indexed newManager
    );

    event MarketFeePolicySet(
        uint256 indexed marketId,
        address indexed oldPolicy,
        address indexed newPolicy
    );

    event FeeRecipientUpdated(
        address indexed oldRecipient,
        address indexed newRecipient
    );

    event TradeFeeCharged(
        address indexed trader,
        uint256 indexed marketId,
        uint256 indexed positionId,
        bool isBuy,
        uint256 baseAmount,
        uint256 feeAmount,
        address policy
    );

    /// @notice Emitted when range multiplication factor is applied
    /// @param marketId Market identifier
    /// @param lo Lower tick boundary (inclusive)
    /// @param hi Upper tick boundary (exclusive)
    /// @param factor Multiplication factor in WAD format
    // lo/hi are tick boundaries; range = [lo, hi). Internally maps to inclusive bin indices [loBin, hiBin]
    event RangeFactorApplied(
        uint256 indexed marketId,
        int256 indexed lo,
        int256 indexed hi,
        uint256 factor
    );

    // ========================================
    // MARKET MANAGEMENT FUNCTIONS
    // ========================================
    
    /// @notice Create a new market (only callable by Owner)
    /// @dev Stores market data and initializes all tick values to WAD (1e18)
    /// @param minTick Minimum allowed tick value (must be aligned to tickSpacing)
    /// @param maxTick Maximum allowed tick value (must be aligned to tickSpacing)
    /// @param tickSpacing Spacing between valid ticks (must be positive)
    /// @param startTimestamp Market start time (unix timestamp)
    /// @param endTimestamp Market end time (unix timestamp, must be > startTimestamp)
    /// @param settlementTimestamp Settlement reference time (must be > endTimestamp)
    /// @param liquidityParameter Alpha parameter for CLMSR formula (1e18 scale, between MIN_LIQUIDITY_PARAMETER and MAX_LIQUIDITY_PARAMETER)
    /// @param feePolicy Fee policy contract address applied to the market (zero address disables fees)
    /// @return marketId Auto-generated market identifier
    function createMarket(
        int256 minTick,
        int256 maxTick,
        int256 tickSpacing,
        uint64 startTimestamp,
        uint64 endTimestamp,
        uint64 settlementTimestamp,
        uint256 liquidityParameter,
        address feePolicy
    ) external returns (uint256 marketId);

    /// @notice Settle a market (only callable by Owner)
    /// @dev Sets exact winning settlement value (6 decimals) and calculates corresponding tick value
    /// @param marketId Market identifier
    /// @param settlementValue Exact winning settlement value with 6 decimals
    function settleMarket(uint256 marketId, int256 settlementValue) external;

    /// @notice Submit oracle settlement candidate during submit window
    function submitSettlement(
        uint256 marketId
    ) external;

    /// @notice Finalize settlement (confirm/fail) during finalize window
    function finalizeSettlement(uint256 marketId, bool markFailed) external;

    /// @notice Toggle market active status
    /// @param marketId Market identifier
    /// @param active Target activation state
    function setMarketActive(uint256 marketId, bool active) external;

    /// @notice Emit position settled events in batches (only callable by Owner)
    /// @dev Emits PositionSettled events for positions using cursor-based pagination
    /// @param marketId Market identifier
    /// @param limit Maximum number of positions to process in this batch
    function emitPositionSettledBatch(uint256 marketId, uint256 limit) external;

    /// @notice Update market timing (only callable by Owner)
    /// @dev Changes market start, end, and settlement timestamps for a specific market
    /// @param marketId Market identifier
    /// @param newStartTimestamp New market start time
    /// @param newEndTimestamp New market end time
    /// @param newSettlementTimestamp New settlement reference time (must be > newEndTimestamp)
    function updateMarketTiming(
        uint256 marketId,
        uint64 newStartTimestamp,
        uint64 newEndTimestamp,
        uint64 newSettlementTimestamp
    ) external;

    /// @notice Reopen a settled market (only callable by Owner)
    /// @dev Reactivates a settled market using existing timing parameters
    /// @param marketId Market identifier
    function reopenMarket(uint256 marketId) external;

    // ========================================
    // MANAGER CONFIGURATION
    // ========================================

    function setManager(address newManager) external;

    function setMarketFeePolicy(uint256 marketId, address newPolicy) external;

    function setFeeRecipient(address newRecipient) external;

    function getMarketFeePolicy(uint256 marketId) external view returns (address);

    function getFeeRecipient() external view returns (address);

    // ========================================
    // EXECUTION FUNCTIONS
    // ========================================
    
    /// @notice Open a new position by buying a range
    /// @dev Creates a new position NFT and updates market state via segment tree
    /// @param marketId Market identifier (must be active and within trading window)
    /// @param lowerTick Lower tick bound (inclusive, aligned to tickSpacing)
    /// @param upperTick Upper tick bound (exclusive, aligned to tickSpacing, must be > lowerTick)
    /// @param quantity Position quantity (always positive, Long-Only, in 6 decimals)
    /// @param maxCost Maximum cost willing to pay (6 decimals, reverts if exceeded)
    /// @return positionId Newly created position ID
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function openPosition(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity,
        uint256 maxCost
    ) external returns (uint256 positionId);
    
    /// @notice Increase existing position quantity (buy more)
    /// @param positionId Position to increase
    /// @param additionalQuantity Additional quantity to buy
    /// @param maxCost Maximum additional cost willing to pay
    /// @return newQuantity New total quantity after increase
    function increasePosition(
        uint256 positionId,
        uint128 additionalQuantity,
        uint256 maxCost
    ) external returns (uint128 newQuantity);
    
    /// @notice Decrease existing position quantity (sell some)
    /// @param positionId Position to decrease
    /// @param sellQuantity Quantity to sell (must be <= current quantity)
    /// @param minProceeds Minimum proceeds willing to accept
    /// @return newQuantity New total quantity after decrease
    /// @return proceeds Actual proceeds received
    function decreasePosition(
        uint256 positionId,
        uint128 sellQuantity,
        uint256 minProceeds
    ) external returns (uint128 newQuantity, uint256 proceeds);
    
    /// @notice Close entire position (sell all)
    /// @param positionId Position to close
    /// @param minProceeds Minimum proceeds willing to accept
    /// @return proceeds Total proceeds from closing position
    function closePosition(
        uint256 positionId,
        uint256 minProceeds
    ) external returns (uint256 proceeds);
    
    /// @notice Claim position payout after market settlement
    /// @param positionId Position to claim
    /// @return payout Amount paid out to position holder
    function claimPayout(
        uint256 positionId
    ) external returns (uint256 payout);

    // ========================================
    // CALCULATION FUNCTIONS
    // ========================================
    
    /// @notice Calculate cost of opening a new position
    /// @param marketId Market identifier
    /// @param lowerTick Lower tick bound (inclusive)
    /// @param upperTick Upper tick bound (exclusive)
    /// @param quantity Position quantity
    /// @return cost Estimated cost
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function calculateOpenCost(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity
    ) external view returns (uint256 cost);
    
    /// @notice Calculate cost of increasing existing position
    /// @param positionId Position identifier  
    /// @param additionalQuantity Additional quantity to buy
    /// @return cost Estimated additional cost
    function calculateIncreaseCost(
        uint256 positionId,
        uint128 additionalQuantity
    ) external view returns (uint256 cost);
    
    /// @notice Calculate proceeds from decreasing position
    /// @param positionId Position identifier
    /// @param sellQuantity Quantity to sell
    /// @return proceeds Estimated proceeds
    function calculateDecreaseProceeds(
        uint256 positionId,
        uint128 sellQuantity
    ) external view returns (uint256 proceeds);
    
    /// @notice Calculate proceeds from closing entire position
    /// @param positionId Position identifier
    /// @return proceeds Estimated proceeds
    function calculateCloseProceeds(
        uint256 positionId
    ) external view returns (uint256 proceeds);
    
    /// @notice Calculate claimable amount from settled position
    /// @param positionId Position identifier
    /// @return amount Claimable amount
    function calculateClaimAmount(
        uint256 positionId
    ) external view returns (uint256 amount);
    
    /// @notice Calculate quantity that can be bought with given cost (inverse function)
    /// @param marketId Market identifier
    /// @param lowerTick Lower tick bound (inclusive)
    /// @param upperTick Upper tick bound (exclusive)
    /// @param cost Target cost to spend (6 decimals)
    /// @return quantity Purchasable quantity
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function calculateQuantityFromCost(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint256 cost
    ) external view returns (uint128 quantity);

    /// @notice Preview fee amount for opening or increasing a position
    /// @param marketId Market identifier
    /// @param lowerTick Lower tick bound (inclusive)
    /// @param upperTick Upper tick bound (exclusive)
    /// @param quantity Trade quantity (6 decimals)
    /// @param cost Base cost used for the fee quote (6 decimals)
    /// @return fee Quoted fee amount
    function previewOpenFee(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity,
        uint256 cost
    ) external view returns (uint256 fee);

    /// @notice Preview fee amount for decreasing or closing a position
    /// @param positionId Position identifier
    /// @param sellQuantity Quantity to sell (6 decimals)
    /// @param proceeds Base proceeds used for the fee quote (6 decimals)
    /// @return fee Quoted fee amount
    function previewSellFee(
        uint256 positionId,
        uint128 sellQuantity,
        uint256 proceeds
    ) external view returns (uint256 fee);

    // ========================================
    // STATE QUERY FUNCTIONS
    // ========================================
    
    /// @notice Get market information
    /// @param marketId Market identifier
    /// @return market Market data
    function getMarket(uint256 marketId) external view returns (Market memory market);
    
    /// @notice Get position contract address
    /// @return Position contract address
    function getPositionContract() external view returns (address);
    
    /// @notice Get payment token address
    /// @return Payment token address
    function getPaymentToken() external view returns (address);
    
    // ========================================
    // SEGMENT TREE FUNCTIONS
    // ========================================
    
    /// @notice Get range sum with on-the-fly lazy calculation (view function)
    /// @dev For general users - returns latest values without state changes
    /// @param marketId Market identifier
    /// @param lo Lower tick (inclusive)
    /// @param hi Upper tick (exclusive)
    /// @return sum Sum of exponential values in range
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function getRangeSum(uint256 marketId, int256 lo, int256 hi)
        external view returns (uint256 sum);
    
    /// @notice Propagate lazy values and return range sum (state-changing function)
    /// @dev For Keeper/Owner - actually pushes lazy values down the tree
    /// @param marketId Market identifier
    /// @param lo Lower tick (inclusive)
    /// @param hi Upper tick (exclusive)
    /// @return sum Sum of exponential values in range
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function propagateLazy(uint256 marketId, int256 lo, int256 hi)
        external returns (uint256 sum);
    
    /// @notice Apply multiplication factor to range (state-changing function)
    /// @dev For Keeper/Owner - updates market state by applying factor
    /// @param marketId Market identifier
    /// @param lo Lower tick (inclusive)
    /// @param hi Upper tick (exclusive)
    /// @param factor Multiplication factor (WAD scale)
    // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
    function applyRangeFactor(uint256 marketId, int256 lo, int256 hi, uint256 factor)
        external;

    /// @notice Apply multiple range factors within a single transaction
    /// @param marketId Market identifier
    /// @param lowers Lower tick bounds (inclusive)
    /// @param uppers Upper tick bounds (exclusive)
    /// @param factors Multiplication factors (WAD scale)
    /// @param context Optional context hash (e.g., seed commitment)
    function applyRangeFactorBatch(
        uint256 marketId,
        int256[] calldata lowers,
        int256[] calldata uppers,
        uint256[] calldata factors,
        bytes32 context
    ) external;

    // ========================================
    // EMERGENCY FUNCTIONS
    // ========================================
    
    /// @notice Pause the contract
    /// @param reason Reason for pausing
    function pause(string calldata reason) external;
    
    /// @notice Unpause the contract
    function unpause() external;
    
    /// @notice Check if contract is paused
    /// @return True if paused
    function isPaused() external view returns (bool);
}

```


## contracts/interfaces/ICLMSRPosition.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {CLMSRErrors as CE} from "../errors/CLMSRErrors.sol";

/// @title ICLMSRPosition
/// @notice Upgradeable interface for CLMSR position NFT management
/// @dev ERC721 NFT contract for position tokens
interface ICLMSRPosition is IERC721 {
    
    // ========================================
    // STRUCTS
    // ========================================
    
    /// @notice Position data structure (same as legacy for compatibility)
    struct Position {
        uint256 marketId;               // Market identifier
        int256 lowerTick;               // Lower tick bound (inclusive)
        int256 upperTick;               // Upper tick bound (exclusive)
        uint128 quantity;               // Position quantity (always positive, Long-Only)
        uint64 createdAt;               // Creation timestamp
    }

    // ========================================
    // EVENTS
    // ========================================
    
    event PositionMinted(
        uint256 indexed positionId,
        address indexed trader,
        uint256 indexed marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity
    );
    
    event PositionBurned(
        uint256 indexed positionId,
        address indexed trader
    );
    
    event PositionUpdated(
        uint256 indexed positionId,
        uint128 oldQuantity,
        uint128 newQuantity
    );
    
    event PositionClaimed(
        uint256 indexed positionId,
        address indexed trader
    );
    
    // ========================================
    // CORE FUNCTIONS
    // ========================================
    
    /// @notice Mint a new position NFT (only callable by Core contract)
    /// @param trader Position owner
    /// @param marketId Market identifier
    /// @param lowerTick Lower tick bound
    /// @param upperTick Upper tick bound
    /// @param quantity Position quantity
    /// @return positionId Newly minted position ID
    function mintPosition(
        address trader,
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity
    ) external returns (uint256 positionId);
    
    /// @notice Burn a position NFT (only callable by Core contract)
    /// @param positionId Position to burn
    function burn(uint256 positionId) external;
    
    /// @notice Set position quantity (only callable by Core contract)
    /// @param positionId Position to update
    /// @param newQuantity New quantity value
    function updateQuantity(uint256 positionId, uint128 newQuantity) external;
    
    
    // ========================================
    // VIEW FUNCTIONS
    // ========================================
    
    /// @notice Get position data
    /// @param positionId Position identifier
    /// @return position Position data
    function getPosition(uint256 positionId) external view returns (Position memory position);
    
    
    /// @notice Check if a position exists
    /// @param positionId Position identifier
    /// @return exists True if position exists
    function exists(uint256 positionId) external view returns (bool exists);
    

    // ========================================
    // MARKET-LOCAL TOKEN INDEXING (NEW)
    // ========================================

    /// @notice Get number of tokens indexed for a market (includes burned holes)
    /// @param marketId Market identifier
    /// @return length Length of market-local token list
    function getMarketTokenLength(uint256 marketId) external view returns (uint256 length);

    /// @notice Get tokenId at market-local index (O(1))
    /// @dev Returns 0 for burned positions (hole markers)
    /// @param marketId Market identifier
    /// @param index 0-based index
    /// @return tokenId Position token id or 0 if burned
    function getMarketTokenAt(uint256 marketId, uint256 index) external view returns (uint256 tokenId);
}
```


## contracts/libraries/FixedPointMath.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

/// @title FixedPointMath ‚Äî thin‚Äëalias helpers for PRB‚ÄëMath
/// @notice Re‚Äëexports PRB‚ÄëMath UD60x18 functions with zero wrapper overhead.
/// @dev   * FixedPointMathU ‚Äî unsigned UD60x18 helpers for core math operations
///        * Functions are external due to contract size limits, but enable efficient library linking
///        * Additional lightweight guards included where PRB‚ÄëMath cannot catch edge cases

import { exp, ln } from "@prb/math/src/ud60x18/Math.sol";
import { wrap, unwrap } from "@prb/math/src/ud60x18/Casting.sol";
import { mulDiv } from "@prb/math/src/Common.sol";

error FP_DivisionByZero();
error FP_InvalidInput();

//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
//  Unsigned 60.18‚Äëdecimal fixed‚Äëpoint helpers
//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
library FixedPointMathU {
    uint256 internal constant WAD = 1e18;
    uint256 internal constant SCALE_DIFF = 1e12;   // 10^(18-6)
    uint256 internal constant HALF_SCALE = SCALE_DIFF / 2;
    uint256 internal constant HALF_WAD = WAD / 2;

    /*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄscaling‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
    /// @dev 6-decimal ‚Üí 18-decimal (multiply by 1e12)
    function toWad(uint256 amt6) internal pure returns (uint256) {
        unchecked {
            return amt6 * SCALE_DIFF;   // overflow impossible: amt6 ‚â§ 2^256-1 / 1e12
        }
    }

    /// @dev 18-decimal ‚Üí 6-decimal (divide by 1e12, truncates decimals)
    function fromWad(uint256 amtWad) internal pure returns (uint256) {
        unchecked {
            return amtWad / SCALE_DIFF;
        }
    }

    /// @dev 18-decimal ‚Üí 6-decimal with round-up (prevents zero-cost attacks)
    /// @notice Always rounds up to ensure minimum 1 micro unit cost
    function fromWadRoundUp(uint256 amtWad) internal pure returns (uint256) {
        if (amtWad == 0) {
            return 0;
        }
        unchecked {
            return ((amtWad - 1) / SCALE_DIFF) + 1;
        }
    }

    /// @dev 18-decimal ‚Üí 6-decimal with nearest-even style rounding (ties round up)
    function fromWadNearest(uint256 amtWad) internal pure returns (uint256) {
        uint256 quotient = amtWad / SCALE_DIFF;
        uint256 remainder = amtWad % SCALE_DIFF;
        if (remainder >= HALF_SCALE) {
            unchecked {
                quotient += 1;
            }
        }
        return quotient;
    }

    /// @dev 18-decimal ‚Üí 6-decimal nearest rounding with minimum 1 micro unit when input is non-zero
    function fromWadNearestMin1(uint256 amtWad) internal pure returns (uint256) {
        if (amtWad == 0) {
            return 0;
        }
        uint256 result = fromWadNearest(amtWad);
        if (result == 0) {
            return 1;
        }
        return result;
    }

    /*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄbasic‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
    function wExp(uint256 x) external pure returns (uint256) {
        return unwrap(exp(wrap(x)));
    }

    function wLn(uint256 x) external pure returns (uint256) {
        if (x < WAD) {
            revert FP_InvalidInput();
        }
        return unwrap(ln(wrap(x)));
    }

    function wMul(uint256 a, uint256 b) external pure returns (uint256) {
        return mulDiv(a, b, WAD);
    }

    function wDiv(uint256 a, uint256 b) external pure returns (uint256) {
        require(b != 0, FP_DivisionByZero());
        return mulDiv(a, WAD, b);
    }

    function wDivUp(uint256 a, uint256 b) external pure returns (uint256) {
        require(b != 0, FP_DivisionByZero());
        uint256 result = mulDiv(a, WAD, b);
        if (mulmod(a, WAD, b) != 0) {
            unchecked {
                result += 1;
            }
        }
        return result;
    }

    function wMulNearest(uint256 a, uint256 b) external pure returns (uint256) {
        uint256 result = mulDiv(a, b, WAD);
        uint256 remainder = mulmod(a, b, WAD);
        if (remainder >= HALF_WAD) {
            unchecked {
                result += 1;
            }
        }
        return result;
    }
} 

```


## contracts/libraries/LazyMulSegmentTree.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {FixedPointMathU} from "./FixedPointMath.sol";
import {CLMSRErrors as CE} from "../errors/CLMSRErrors.sol";

/// @title LazyMulSegmentTree
/// @notice Gas-optimized sparse lazy multiplication segment tree for CLMSR tick data management
/// @dev Supports efficient range multiplication and queries with minimal storage.
///      All leaves default to 1 WAD (e^0 = 1), nodes created only when needed.
library LazyMulSegmentTree {
    using FixedPointMathU for uint256;

    // ========================================
    // CONSTANTS
    // ========================================
    
    uint256 public constant ONE_WAD = 1e18;
    uint256 public constant MIN_FACTOR = 0.01e18;  // 1% minimum - allow wide range for CLMSR
    uint256 public constant MAX_FACTOR = 100e18;   // 100x maximum - allow wide range for CLMSR
    uint256 public constant FLUSH_THRESHOLD = 1e21; // 1,000 WAD - auto-flush when pendingFactor exceeds this
    uint256 public constant UNDERFLOW_FLUSH_THRESHOLD = 1e15; // 0.001 WAD - auto-flush when pendingFactor drops below this

    // ========================================
    // STRUCTS
    // ========================================
    
    /// @notice Packed node structure for lazy multiplication segment tree
    /// @dev Optimized for 2-slot storage: pendingFactor(192bit) + childPtr(64bit) in slot 1, sum in slot 2
    struct Node {
        uint256 sum;            // Sum of exponential values in subtree
        uint192 pendingFactor;  // Lazy multiplication factor (ONE_WAD = no-op) - 192 bits sufficient
        uint64 childPtr;        // Packed: left(32bit) + right(32bit)
    }
    
    /// @notice Complete lazy multiplication segment tree structure
    struct Tree {
        mapping(uint32 => Node) nodes;  // Node storage
        uint32 root;                    // Root node index
        uint32 nextIndex;               // Next available node index
        uint32 size;                    // Tree size (number of leaves)
        uint256 cachedRootSum;          // Cached total sum for O(1) access
    }


    // ========================================
    // EXTERNAL FUNCTIONS
    // ========================================
    
    /// @notice Initialize a new lazy multiplication segment tree
    /// @param tree Tree storage reference
    /// @param treeSize Number of leaves in the tree
    function init(Tree storage tree, uint32 treeSize) external {
        require(treeSize != 0, CE.TreeSizeZero());
        require(tree.size == 0, CE.TreeAlreadyInitialized());
        require(treeSize <= type(uint32).max / 2, CE.TreeSizeTooLarge());
        
        tree.size = treeSize;
        tree.nextIndex = 0; // Start from 0
        tree.root = _allocateNode(tree, 0, treeSize - 1);
        tree.cachedRootSum = tree.nodes[tree.root].sum; // Read actual root sum
    }
    
    /// @notice Apply range multiplication factor
    /// @param tree Tree storage reference
    /// @param lo Bin index lower bound (inclusive)
    /// @param hi Bin index upper bound (inclusive)
    /// @param factor Multiplication factor in WAD format
    function applyRangeFactor(Tree storage tree, uint32 lo, uint32 hi, uint256 factor) external {
        require(tree.size != 0, CE.TreeNotInitialized());
        require(lo <= hi, CE.InvalidRange(lo, hi));
        require(hi < tree.size, CE.IndexOutOfBounds(hi, tree.size));
        require(
            factor >= MIN_FACTOR && factor <= MAX_FACTOR,
            CE.InvalidFactor(factor)
        );
        
        _applyFactorRecursive(tree, tree.root, 0, tree.size - 1, lo, hi, factor);
    
    }

    /// @notice Get range sum (on-the-fly calculation, view function)
    /// @param tree Tree storage reference
    /// @param lo Left boundary (inclusive)
    /// @param hi Right boundary (inclusive)
    /// @return sum Sum of values in range
    function getRangeSum(Tree storage tree, uint32 lo, uint32 hi) 
        external 
        view
        returns (uint256 sum) 
    {
        require(tree.size != 0, CE.TreeNotInitialized());
        require(lo <= hi, CE.InvalidRange(lo, hi));
        require(hi < tree.size, CE.IndexOutOfBounds(hi, tree.size));
        
        return _sumRangeWithAccFactor(tree, tree.root, 0, tree.size - 1, lo, hi, ONE_WAD);
    }
    
    /// @notice Propagate lazy values and return range sum (state-changing function)
    /// @param tree Tree storage reference
    /// @param lo Bin index lower bound (inclusive)
    /// @param hi Bin index upper bound (inclusive)
    /// @return sum Sum of values in range
    function propagateLazy(Tree storage tree, uint32 lo, uint32 hi)
        external
        returns (uint256 sum)
    {
        require(tree.size != 0, CE.TreeNotInitialized());
        require(lo <= hi, CE.InvalidRange(lo, hi));
        require(hi < tree.size, CE.IndexOutOfBounds(hi, tree.size));
        
        sum = _queryRecursive(tree, tree.root, 0, tree.size - 1, lo, hi);
        
        return sum;
    }

    // ========================================
    // INTERNAL FUNCTIONS
    // ========================================
    
    /// @notice Calculate default sum for empty range (all leaves = 1 WAD)
    /// @param l Left boundary (inclusive)
    /// @param r Right boundary (inclusive)
    /// @return sum Default sum for range
    function _defaultSum(uint32 l, uint32 r) private pure returns (uint256 sum) {
        unchecked {
            return uint256(r - l + 1) * ONE_WAD;
        }
    }

    /// @dev Applies factor to a value while mirroring sell-side rounding so view logic matches mutate path.
    function _mulWithCompensation(uint256 value, uint256 factor) private pure returns (uint256) {
        if (value == 0 || factor == ONE_WAD) {
            return value;
        }

        return value.wMulNearest(factor);
    }

    /// @dev Multiplies two lazy factors while preserving the compensation semantics used on sums.
    function _combineFactors(uint256 lhs, uint256 rhs) private pure returns (uint256) {
        if (rhs == ONE_WAD) {
            return lhs;
        }

        return lhs.wMulNearest(rhs);
    }

    /// @notice Pack two uint32 values into uint64 child pointer
    function _packChildPtr(uint32 left, uint32 right) private pure returns (uint64) {
        return (uint64(left) << 32) | uint64(right);
    }
    
    /// @notice Unpack uint64 child pointer into two uint32 values
    function _unpackChildPtr(uint64 packed) private pure returns (uint32 left, uint32 right) {
        left = uint32(packed >> 32);
        right = uint32(packed);
    }
    
    /// @notice Allocate a new node with range boundaries
    /// @param tree Tree storage reference
    /// @param l Left boundary
    /// @param r Right boundary
    /// @return newIndex Newly allocated index
    function _allocateNode(Tree storage tree, uint32 l, uint32 r) private returns (uint32 newIndex) {
        newIndex = ++tree.nextIndex;
        Node storage node = tree.nodes[newIndex];
        node.pendingFactor = uint192(ONE_WAD); // No pending operations
        node.sum = _defaultSum(l, r); // Default sum for range
    }

    /// @notice Apply multiplicative factor to node sum with sell-side rounding compensation
    /// @param node Node storage reference
    /// @param factor Multiplication factor
    function _scaleNodeSum(Node storage node, uint256 factor) private {
        node.sum = _mulWithCompensation(node.sum, factor);
    }

    /// @notice Apply lazy propagation to a node
    /// @dev INVARIANT: node.sum already contains its own pendingFactor
    /// @param tree Tree storage reference
    /// @param nodeIndex Node index to apply to
    /// @param factor Multiplication factor
    function _applyFactorToNode(Tree storage tree, uint32 nodeIndex, uint256 factor) private {
        if (nodeIndex == 0 || factor == ONE_WAD) return;
        
        Node storage node = tree.nodes[nodeIndex];
        _scaleNodeSum(node, factor);
        
        uint256 priorPending = uint256(node.pendingFactor);
        uint256 newPendingFactor = _combineFactors(priorPending, factor);

        require(newPendingFactor <= type(uint192).max, CE.LazyFactorOverflow());
        node.pendingFactor = uint192(newPendingFactor);
        
        // Update cached root sum if this is root
        if (nodeIndex == tree.root) {
            tree.cachedRootSum = node.sum;
        }
    }
    
    /// @notice Push lazy values down to children (with auto-allocation)
    /// @param tree Tree storage reference
    /// @param nodeIndex Current node index
    /// @param l Left boundary
    /// @param r Right boundary
    function _pushPendingFactor(Tree storage tree, uint32 nodeIndex, uint32 l, uint32 r) private {
        if (nodeIndex == 0) return;
        
        Node storage node = tree.nodes[nodeIndex];
        uint192 nodePendingFactor = node.pendingFactor;
        
        if (nodePendingFactor != uint192(ONE_WAD)) {
            uint32 mid = l + (r - l) / 2;
            (uint32 left, uint32 right) = _unpackChildPtr(node.childPtr);
            
            uint256 pendingFactorVal = uint256(nodePendingFactor);
            
            // Auto-allocate left child if needed
            if (left == 0) {
                left = _allocateNode(tree, l, mid);
            }
            
            // Auto-allocate right child if needed
            if (right == 0) {
                right = _allocateNode(tree, mid + 1, r);
            }
            _applyFactorToNode(tree, left, pendingFactorVal);
            _applyFactorToNode(tree, right, pendingFactorVal);

            _rebalanceChildren(tree, left, right, node.sum);
            
            // Update packed children
            node.childPtr = _packChildPtr(left, right);
            node.pendingFactor = uint192(ONE_WAD);

            if (nodeIndex == tree.root) {
                tree.cachedRootSum = node.sum;
            }
        }
    }
    
    function _rebalanceChildren(
        Tree storage tree,
        uint32 left,
        uint32 right,
        uint256 target
    ) private {
        uint256 combined = tree.nodes[left].sum + tree.nodes[right].sum;
        if (combined == target) return;

        if (combined < target) {
            tree.nodes[right].sum += target - combined;
            return;
        }

        uint256 surplus = combined - target;
        uint256 rightSum = tree.nodes[right].sum;
        if (surplus <= rightSum) {
            tree.nodes[right].sum = rightSum - surplus;
            return;
        }

        uint256 remaining = surplus - rightSum;
        tree.nodes[right].sum = 0;
        uint256 leftSum = tree.nodes[left].sum;
        require(remaining <= leftSum, CE.MathMulOverflow());
        tree.nodes[left].sum = leftSum - remaining;
    }
    
    /// @notice Pull values up from children
    /// @dev PREREQUISITE: Must call _pushPendingFactor first (pending=ONE_WAD state)
    /// @param tree Tree storage reference
    /// @param nodeIndex Current node index
    /// @param l Left boundary
    /// @param r Right boundary
    function _pullUpSum(Tree storage tree, uint32 nodeIndex, uint32 l, uint32 r) private {
        if (nodeIndex == 0) return;
        
        Node storage node = tree.nodes[nodeIndex];
        (uint32 left, uint32 right) = _unpackChildPtr(node.childPtr);
        
        uint32 mid = l + (r - l) / 2;
        
        uint256 leftSum = (left != 0) ? tree.nodes[left].sum : _defaultSum(l, mid);
        uint256 rightSum = (right != 0) ? tree.nodes[right].sum : _defaultSum(mid + 1, r);
        
        node.sum = leftSum + rightSum;
        
        // Update cached root sum if this is root
        if (nodeIndex == tree.root) {
            tree.cachedRootSum = node.sum;
        }
    }
    
    /// @notice Recursive range multiplication implementation
    /// @param tree Tree storage reference
    /// @param nodeIndex Current node index
    /// @param l Left boundary of current segment
    /// @param r Right boundary of current segment
    /// @param lo Query left boundary
    /// @param hi Query right boundary
    /// @param factor Multiplication factor
    function _applyFactorRecursive(
        Tree storage tree,
        uint32 nodeIndex,
        uint32 l,
        uint32 r,
        uint32 lo,
        uint32 hi,
        uint256 factor
    ) private {
        // No overlap
        if (r < lo || l > hi) return;
        
        // If no node exists, nothing to do
        if (nodeIndex == 0) return;
        
        Node storage node = tree.nodes[nodeIndex];
        
        // Complete overlap - apply lazy update with smart auto-flush
        if (l >= lo && r <= hi) {
            uint256 priorPending = uint256(node.pendingFactor);
            uint256 combinedPending = _combineFactors(priorPending, factor);

            if (
                priorPending != ONE_WAD &&
                (combinedPending < UNDERFLOW_FLUSH_THRESHOLD || combinedPending > FLUSH_THRESHOLD)
            ) {
                _pushPendingFactor(tree, nodeIndex, l, r);
                priorPending = uint256(node.pendingFactor);
            }

            _scaleNodeSum(node, factor);

            uint256 newPendingFactor = _combineFactors(priorPending, factor);

            if (newPendingFactor < UNDERFLOW_FLUSH_THRESHOLD) {
                node.pendingFactor = uint192(factor);
            } else if (newPendingFactor > FLUSH_THRESHOLD) {
                node.pendingFactor = uint192(factor);
                _pushPendingFactor(tree, nodeIndex, l, r);
                node.pendingFactor = uint192(ONE_WAD);
            } else {
                require(newPendingFactor <= type(uint192).max, CE.LazyFactorOverflow());
                node.pendingFactor = uint192(newPendingFactor);
            }
            
            // Update cached root sum if this is root
            if (nodeIndex == tree.root) {
                tree.cachedRootSum = node.sum;
            }
            return;
        }
        
        // Partial overlap - push down and recurse
        _pushPendingFactor(tree, nodeIndex, l, r);
        
        Node storage current = tree.nodes[nodeIndex];
        (uint32 leftChild, uint32 rightChild) = _unpackChildPtr(current.childPtr);
        uint32 mid = l + (r - l) / 2;

        if (lo <= mid) {
            if (leftChild == 0) {
                leftChild = _allocateNode(tree, l, mid);
            }
            _applyFactorRecursive(tree, leftChild, l, mid, lo, hi, factor);
        }
        if (hi > mid) {
            if (rightChild == 0) {
                rightChild = _allocateNode(tree, mid + 1, r);
            }
            _applyFactorRecursive(tree, rightChild, mid + 1, r, lo, hi, factor);
        }
        
        current.childPtr = _packChildPtr(leftChild, rightChild);

        uint256 leftSum = (leftChild != 0)
            ? tree.nodes[leftChild].sum
            : _defaultSum(l, mid);
        uint256 rightSum = (rightChild != 0)
            ? tree.nodes[rightChild].sum
            : _defaultSum(mid + 1, r);
        current.sum = leftSum + rightSum;
        
        if (nodeIndex == tree.root) {
            tree.cachedRootSum = current.sum;
        }
    }
    
    /// @notice On-the-fly query with accumulated lazy (true view function)
    /// @dev Renamed from _queryOnTheFly to _sumRangeWithAccFactor
    /// @param tree Tree storage reference
    /// @param nodeIndex Current node index
    /// @param l Left boundary of current segment
    /// @param r Right boundary of current segment
    /// @param lo Query left boundary
    /// @param hi Query right boundary
    /// @param accFactor Accumulated lazy factor from ancestors
    /// @return sum Sum in the queried range with all lazy values applied
    function _sumRangeWithAccFactor(
        Tree storage tree,
        uint32 nodeIndex,
        uint32 l,
        uint32 r,
        uint32 lo,
        uint32 hi,
        uint256 accFactor
    ) private view returns (uint256 sum) {
        // Handle empty nodes with default sum
        if (nodeIndex == 0) {
            if (r < lo || l > hi) return 0;
            uint32 overlapL = lo > l ? lo : l;
            uint32 overlapR = hi < r ? hi : r;
            return _mulWithCompensation(_defaultSum(overlapL, overlapR), accFactor);
        }
        
        // No overlap
        if (r < lo || l > hi) return 0;
        
        Node storage node = tree.nodes[nodeIndex];

        // Complete overlap
        if (l >= lo && r <= hi) {
            // node.sum already contains pendingFactor, so only apply ancestor accumulated factor
            return _mulWithCompensation(node.sum, accFactor);
        }
        
        // Apply current node's lazy to accumulated lazy
        uint256 newAccFactor = accFactor.wMulNearest(uint256(node.pendingFactor));
        
        // Partial overlap - recurse with accumulated lazy
        uint32 mid = l + (r - l) / 2;
        (uint32 leftChild, uint32 rightChild) = _unpackChildPtr(node.childPtr);
        
        uint256 leftSum = _sumRangeWithAccFactor(tree, leftChild, l, mid, lo, hi, newAccFactor);
        uint256 rightSum = _sumRangeWithAccFactor(tree, rightChild, mid + 1, r, lo, hi, newAccFactor);
        
        return leftSum + rightSum;
    }
    
    /// @notice Recursive query implementation with lazy propagation
    /// @param tree Tree storage reference
    /// @param nodeIndex Current node index
    /// @param l Left boundary of current segment
    /// @param r Right boundary of current segment
    /// @param lo Query left boundary
    /// @param hi Query right boundary
    /// @return sum Sum in the queried range
    function _queryRecursive(
        Tree storage tree,
        uint32 nodeIndex,
        uint32 l,
        uint32 r,
        uint32 lo,
        uint32 hi
    ) private returns (uint256 sum) {
        // Handle empty nodes with default sum
        if (nodeIndex == 0) {
            if (r < lo || l > hi) return 0;
            uint32 overlapL = lo > l ? lo : l;
            uint32 overlapR = hi < r ? hi : r;
            return _defaultSum(overlapL, overlapR);
        }
        
        // No overlap
        if (r < lo || l > hi) return 0;
        
        Node storage node = tree.nodes[nodeIndex];
        
        // Complete overlap
        if (l >= lo && r <= hi) {
            return node.sum;
        }
        
        // Partial overlap - push lazy values first
        _pushPendingFactor(tree, nodeIndex, l, r);
        
        uint32 mid = l + (r - l) / 2;
        (uint32 leftChild, uint32 rightChild) = _unpackChildPtr(node.childPtr);
        
        uint256 leftSum = _queryRecursive(tree, leftChild, l, mid, lo, hi);
        uint256 rightSum = _queryRecursive(tree, rightChild, mid + 1, r, lo, hi);
        
        return leftSum + rightSum;
    }


    function seedWithFactors(Tree storage tree, uint256[] memory factors) internal {
        require(tree.size != 0, CE.TreeNotInitialized());
        require(factors.length == tree.size, CE.ArrayLengthMismatch());

        tree.nextIndex = 0;
        tree.root = 0;

        (uint32 rootIndex, uint256 total) = _buildTreeFromArray(tree, 0, tree.size - 1, factors);
        tree.root = rootIndex;
        tree.cachedRootSum = total;
    }

    function _buildTreeFromArray(
        Tree storage tree,
        uint32 l,
        uint32 r,
        uint256[] memory factors
    ) private returns (uint32 nodeIndex, uint256 sum) {
        nodeIndex = _allocateNode(tree, l, r);
        Node storage node = tree.nodes[nodeIndex];
        node.pendingFactor = uint192(ONE_WAD);

        if (l == r) {
            uint256 leafValue = factors[uint256(l)];
            node.sum = leafValue;
            node.childPtr = 0;
            return (nodeIndex, leafValue);
        }

        uint32 mid = l + (r - l) / 2;
        (uint32 leftChild, uint256 leftSum) = _buildTreeFromArray(tree, l, mid, factors);
        (uint32 rightChild, uint256 rightSum) = _buildTreeFromArray(tree, mid + 1, r, factors);

        node.childPtr = _packChildPtr(leftChild, rightChild);
        uint256 total = leftSum + rightSum;
        node.sum = total;

        return (nodeIndex, total);
    }

}

```


## contracts/errors/CLMSRErrors.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

interface CLMSRErrors {
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Market life-cycle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    error MarketNotStarted();
    error MarketExpired();
    error MarketNotActive();
    error InvalidTimeRange();
    error MarketAlreadySettled(uint256 marketId);
    error MarketNotSettled(uint256 marketId);
    error MarketNotFound(uint256 marketId);
    error MarketAlreadyExists(uint256 marketId);
    error SettlementTooEarly(uint64 requiredTimestamp, uint64 currentTimestamp);
    error SettlementFinalizeWindowClosed(uint64 requiredTimestamp, uint64 currentTimestamp);
    error SettlementOracleCandidateMissing();
    error SettlementOracleSignatureInvalid(address signer);

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Trade params ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    error InvalidTick(int256 tick, int256 minTick, int256 maxTick);
    error InvalidTickRange(int256 lowerTick, int256 upperTick);
    error InvalidTickSpacing(int256 tick, int256 tickSpacing);
    error InvalidQuantity(uint128 qty);
    error CostExceedsMaximum(uint256 cost, uint256 maxAllowed);
    error FeeExceedsBase(uint256 fee, uint256 baseAmount);
    error InvalidFeePolicy(address policy);
    error InvalidMarketParameters(int256 minTick, int256 maxTick, int256 tickSpacing);

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Access control ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    error UnauthorizedCaller(address caller);

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Misc / config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    error ZeroAddress();
    error InvalidTokenDecimals(uint8 provided, uint8 expected);
    error BinCountExceedsLimit(uint32 requested, uint32 maxAllowed);
    error InvalidLiquidityParameter();
    error ZeroLimit();
    error InvalidRangeCount(int256 ranges, uint256 maxAllowed);
    error RangeBinOutOfBounds(int256 bin, uint32 numBins);
    error BinOutOfBounds(uint32 bin, uint32 numBins);
    error RangeBinsOutOfBounds(uint32 lowerBin, uint32 upperBin, uint32 numBins);
    error InvalidRangeBins(uint32 lowerBin, uint32 upperBin);
    error ManagerNotSet();
    
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Position errors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    error PositionNotFound(uint256 positionId);
    error InsufficientBalance(address account, uint256 required, uint256 available);
    
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Segment Tree errors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    error TreeNotInitialized();
    error TreeSizeZero();
    error TreeSizeTooLarge();
    error TreeAlreadyInitialized();
    error LazyFactorOverflow();
    error ArrayLengthMismatch();
    error FactorOutOfBounds();
    error IncompleteChunkProcessing();
    error IndexOutOfBounds(uint32 index, uint32 size);
    error InvalidRange(uint32 lo, uint32 hi);
    error InvalidFactor(uint256 factor);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Core math / flow / slippage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    error MathMulOverflow();
    error NonIncreasingSum(uint256 beforeSum, uint256 afterSum);
    error SumAfterZero();
    error NoChunkProgress();
    error ResidualQuantity(uint256 remaining);
    error AffectedSumZero();
    error ChunkLimitExceeded(uint256 required, uint256 maxAllowed);
    error QuantityOverflow();
    error InsufficientPositionQuantity(uint128 want, uint128 have);
    error ProceedsBelowMinimum(uint256 proceeds, uint256 minProceeds);
}

```


## contracts/errors/PointsErrors.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

interface PointsErrors {
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Points system errors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    error InvalidParameters();
    error ParameterArrayLengthMismatch();
}


```


## contracts/managers/CLMSRMarketManager.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "../core/storage/CLMSRMarketCoreStorage.sol";
import "../interfaces/ICLMSRMarketCore.sol";
import "../interfaces/ICLMSRPosition.sol";
import {LazyMulSegmentTree} from "../libraries/LazyMulSegmentTree.sol";
import "../errors/CLMSRErrors.sol";
import {CLMSRErrors as CE} from "../errors/CLMSRErrors.sol";
import "@redstone-finance/evm-connector/contracts/data-services/PrimaryProdDataServiceConsumerBase.sol";

/// @notice ÎùºÏù¥ÌîÑÏÇ¨Ïù¥ÌÅ¥ Ï†ÑÏö© Îß§ÎãàÏ†Ä - CoreÎ°úÎ∂ÄÌÑ∞ delegatecallÎ°ú Ìò∏Ï∂úÎêòÏñ¥ ÎèôÏùº Ïä§ÌÜ†Î¶¨ÏßÄÎ•º Ï°∞ÏûëÌïúÎã§.
contract CLMSRMarketManager is
    Initializable,
    CLMSRErrors,
    OwnableUpgradeable,
    UUPSUpgradeable,
    PausableUpgradeable,
    ReentrancyGuardUpgradeable,
    PrimaryProdDataServiceConsumerBase,
    CLMSRMarketCoreStorage
{
    uint32 private constant MAX_TICK_COUNT = 1_000_000;
    uint256 private constant MIN_LIQUIDITY_PARAMETER = 1e15;
    uint256 private constant MAX_LIQUIDITY_PARAMETER = 1e23;
    bytes32 private constant REDSTONE_DATA_FEED_ID = bytes32("BTC");
    uint8 private constant REDSTONE_FEED_DECIMALS = 8;

    event MarketCreated(
        uint256 indexed marketId,
        uint64 startTimestamp,
        uint64 endTimestamp,
        int256 minTick,
        int256 maxTick,
        int256 tickSpacing,
        uint32 numBins,
        uint256 liquidityParameter
    );

    event MarketSettled(uint256 indexed marketId, int256 settlementTick);

    event MarketSettlementValueSubmitted(uint256 indexed marketId, int256 settlementValue);

    event MarketSettlementCandidateSubmitted(
        uint256 indexed marketId,
        int256 settlementValue,
        int256 settlementTick,
        uint64 priceTimestamp,
        address indexed submitter,
        bytes oracleData
    );

    event MarketSettlementFinalized(
        uint256 indexed marketId,
        bool isFailed,
        int256 settlementValue,
        int256 settlementTick,
        uint64 priceTimestamp,
        uint64 finalizedAt
    );

    event MarketReopened(uint256 indexed marketId);

    event MarketActivationUpdated(uint256 indexed marketId, bool isActive);

    event MarketTimingUpdated(
        uint256 indexed marketId,
        uint64 newStartTimestamp,
        uint64 newEndTimestamp
    );

    event SettlementTimestampUpdated(uint256 indexed marketId, uint64 settlementTimestamp);

    event PositionEventsProgress(
        uint256 indexed marketId,
        uint256 from,
        uint256 to,
        bool done
    );

    event PositionSettled(
        uint256 indexed positionId,
        address indexed trader,
        uint256 payout,
        bool isWin
    );

    event MarketFeePolicySet(
        uint256 indexed marketId,
        address indexed oldPolicy,
        address indexed newPolicy
    );

    address private immutable self;

    constructor() {
        self = address(this);
        _disableInitializers();
    }

    modifier onlyDelegated() {
        require(address(this) != self, "ManagerDirectCall");
        _;
    }

    /// @inheritdoc UUPSUpgradeable
    function _authorizeUpgrade(address) internal pure override {
        revert("ManagerNotUpgradeable");
    }

    function createMarket(
        int256 minTick,
        int256 maxTick,
        int256 tickSpacing,
        uint64 startTimestamp,
        uint64 endTimestamp,
        uint64 settlementTimestamp,
        uint256 liquidityParameter,
        address feePolicy
    ) external onlyOwner whenNotPaused onlyDelegated returns (uint256 marketId) {
        ICLMSRMarketCore.MarketCreationParams memory params = ICLMSRMarketCore.MarketCreationParams({
            minTick: minTick,
            maxTick: maxTick,
            tickSpacing: tickSpacing,
            startTimestamp: startTimestamp,
            endTimestamp: endTimestamp,
            settlementTimestamp: settlementTimestamp,
            liquidityParameter: liquidityParameter,
            feePolicy: feePolicy
        });

        (marketId, ) = _createMarketInternal(params, false);
        emit MarketActivationUpdated(marketId, false);
        return marketId;
    }

    function settleMarket(uint256 marketId, int256 settlementValue)
        external
        onlyOwner
        onlyDelegated
    {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        ICLMSRMarketCore.Market storage market = markets[marketId];

        require(!market.settled, CE.MarketAlreadySettled(marketId));

        uint64 gate = market.settlementTimestamp == 0 ? market.endTimestamp : market.settlementTimestamp;
        require(block.timestamp >= gate, CE.SettlementTooEarly(gate, uint64(block.timestamp)));

        int256 settlementTick = settlementValue / 1_000_000;

        require(
            settlementTick >= market.minTick &&
                settlementTick <= market.maxTick,
            CE.InvalidTick(settlementTick, market.minTick, market.maxTick)
        );

        market.settled = true;
        market.settlementValue = settlementValue;
        market.settlementTick = settlementTick;
        market.isActive = false;

        market.positionEventsCursor = 0;
        market.positionEventsEmitted = false;

        emit MarketSettled(marketId, settlementTick);
        emit MarketSettlementValueSubmitted(marketId, settlementValue);
    }

    function submitSettlement(
        uint256 marketId
    ) external onlyDelegated whenNotPaused {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        ICLMSRMarketCore.Market storage market = markets[marketId];
        SettlementOracleState storage state = settlementOracleState[marketId];

        require(!market.settled, CE.MarketAlreadySettled(marketId));

        uint64 gate = market.settlementTimestamp == 0 ? market.endTimestamp : market.settlementTimestamp;
        uint64 nowTs = uint64(block.timestamp);

        require(nowTs >= gate, CE.SettlementTooEarly(gate, nowTs));
        require(
            nowTs < gate + SETTLEMENT_SUBMIT_WINDOW,
            CE.SettlementFinalizeWindowClosed(gate + SETTLEMENT_SUBMIT_WINDOW, nowTs)
        );

        // Validate signatures and extract single price/timestamp from payload
        uint256 price = getOracleNumericValueFromTxMsg(REDSTONE_DATA_FEED_ID);
        uint256 timestampMs = extractTimestampsAndAssertAllAreEqual();
        uint64 priceTimestamp = uint64(timestampMs / 1000);
        int256 settlementValue = _convertPriceToSettlementValue(price);
        int256 settlementTick = settlementValue / 1_000_000;
        require(
            settlementTick >= market.minTick &&
            settlementTick <= market.maxTick,
            CE.InvalidTick(settlementTick, market.minTick, market.maxTick)
        );

        uint64 target = gate;
        uint64 existingTs = state.candidatePriceTimestamp;
        if (existingTs == 0) {
            state.candidateValue = settlementValue;
            state.candidatePriceTimestamp = priceTimestamp;
        } else {
            uint64 oldDiff = existingTs > target ? existingTs - target : target - existingTs;
            uint64 newDiff = priceTimestamp > target ? priceTimestamp - target : target - priceTimestamp;
            if (newDiff < oldDiff || (newDiff == oldDiff && priceTimestamp < existingTs)) {
                state.candidateValue = settlementValue;
                state.candidatePriceTimestamp = priceTimestamp;
            }
        }

        emit MarketSettlementCandidateSubmitted(
            marketId,
            settlementValue,
            settlementTick,
            priceTimestamp,
            msg.sender,
            ""
        );
    }

    function finalizeSettlement(uint256 marketId, bool markFailed)
        external
        onlyDelegated
        whenNotPaused
    {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        ICLMSRMarketCore.Market storage market = markets[marketId];
        SettlementOracleState storage state = settlementOracleState[marketId];

        require(!market.settled, CE.MarketAlreadySettled(marketId));

        uint64 gate = market.settlementTimestamp == 0 ? market.endTimestamp : market.settlementTimestamp;
        uint64 nowTs = uint64(block.timestamp);

        require(
            nowTs >= gate + SETTLEMENT_SUBMIT_WINDOW,
            CE.SettlementTooEarly(gate + SETTLEMENT_SUBMIT_WINDOW, nowTs)
        );
        require(
            nowTs < gate + SETTLEMENT_FINALIZE_DEADLINE,
            CE.SettlementFinalizeWindowClosed(gate + SETTLEMENT_FINALIZE_DEADLINE, nowTs)
        );

        if (markFailed) {
            require(msg.sender == owner(), CE.UnauthorizedCaller(msg.sender));
            state.candidateValue = 0;
            state.candidatePriceTimestamp = 0;

            emit MarketSettlementFinalized(
                marketId,
                true,
                0,
                0,
                0,
                nowTs
            );
            return;
        }

        require(state.candidatePriceTimestamp != 0, CE.SettlementOracleCandidateMissing());

        int256 settlementValue = state.candidateValue;
        int256 settlementTick = settlementValue / 1_000_000;

        require(
            settlementTick >= market.minTick &&
                settlementTick <= market.maxTick,
            CE.InvalidTick(settlementTick, market.minTick, market.maxTick)
        );

        market.settled = true;
        market.settlementValue = settlementValue;
        market.settlementTick = settlementTick;
        market.isActive = false;

        market.positionEventsCursor = 0;
        market.positionEventsEmitted = false;

        emit MarketSettled(marketId, settlementTick);
        emit MarketSettlementValueSubmitted(marketId, settlementValue);
        emit MarketSettlementFinalized(
            marketId,
            false,
            settlementValue,
            settlementTick,
            state.candidatePriceTimestamp,
            nowTs
        );

        state.candidateValue = 0;
        state.candidatePriceTimestamp = 0;
    }

    function reopenMarket(uint256 marketId)
        external
        onlyOwner
        onlyDelegated
    {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        ICLMSRMarketCore.Market storage market = markets[marketId];

        require(market.settled, CE.MarketNotSettled(marketId));

        market.settled = false;
        market.settlementValue = 0;
        market.settlementTick = 0;
        market.isActive = true;

        market.positionEventsCursor = 0;
        market.positionEventsEmitted = false;

        emit MarketReopened(marketId);
    }

    function updateMarketTiming(
        uint256 marketId,
        uint64 newStartTimestamp,
        uint64 newEndTimestamp,
        uint64 newSettlementTimestamp
    ) external onlyOwner onlyDelegated {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        ICLMSRMarketCore.Market storage market = markets[marketId];

        require(!market.settled, CE.MarketAlreadySettled(marketId));

        require(newStartTimestamp < newEndTimestamp, CE.InvalidTimeRange());
        require(newEndTimestamp < newSettlementTimestamp, CE.InvalidTimeRange());

        market.startTimestamp = newStartTimestamp;
        market.endTimestamp = newEndTimestamp;
        market.settlementTimestamp = newSettlementTimestamp;

        emit MarketTimingUpdated(marketId, newStartTimestamp, newEndTimestamp);
        emit SettlementTimestampUpdated(marketId, newSettlementTimestamp);
    }

    function emitPositionSettledBatch(uint256 marketId, uint256 limit)
        external
        onlyOwner
        onlyDelegated
    {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        ICLMSRMarketCore.Market storage m = markets[marketId];
        require(m.settled, CE.MarketNotSettled(marketId));
        if (m.positionEventsEmitted) return;
        require(limit > 0, CE.ZeroLimit());

        uint256 len = positionContract.getMarketTokenLength(marketId);
        uint256 cursor = uint256(m.positionEventsCursor);
        if (cursor >= len) {
            m.positionEventsEmitted = true;
            emit PositionEventsProgress(marketId, cursor, cursor, true);
            return;
        }

        uint256 toExclusive = cursor + limit;
        if (toExclusive > len) toExclusive = len;

        for (uint256 i = cursor; i < toExclusive; ++i) {
            uint256 pid = positionContract.getMarketTokenAt(marketId, i);
            if (pid == 0) continue;
            if (positionSettledEmitted[pid]) continue;
            if (!positionContract.exists(pid)) continue;

            ICLMSRPosition.Position memory p = positionContract.getPosition(pid);
            if (p.marketId != marketId) continue;

            uint256 payout = ICLMSRMarketCore(address(this)).calculateClaimAmount(pid);
            bool isWin = payout > 0;
            address trader = positionContract.ownerOf(pid);
            emit PositionSettled(pid, trader, payout, isWin);
            positionSettledEmitted[pid] = true;
        }

        m.positionEventsCursor = uint32(toExclusive);
        bool done = toExclusive == len;
        if (done) m.positionEventsEmitted = true;
        emit PositionEventsProgress(marketId, cursor, toExclusive == 0 ? 0 : (toExclusive - 1), done);
    }

    function setMarketActive(uint256 marketId, bool active)
        external
        onlyOwner
        whenNotPaused
        onlyDelegated
    {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        ICLMSRMarketCore.Market storage market = markets[marketId];

        require(!market.settled, CE.MarketAlreadySettled(marketId));

        if (market.isActive == active) {
            return;
        }

        market.isActive = active;
        emit MarketActivationUpdated(marketId, active);
    }

    function setMarketFeePolicy(uint256 marketId, address newPolicy)
        external
        onlyOwner
        whenNotPaused
        onlyDelegated
    {
        require(_marketExists(marketId), CE.MarketNotFound(marketId));
        if (newPolicy != address(0) && newPolicy.code.length == 0) {
            revert CE.InvalidFeePolicy(newPolicy);
        }

        ICLMSRMarketCore.Market storage market = markets[marketId];
        address oldPolicy = market.feePolicy;
        if (oldPolicy == newPolicy) {
            return;
        }

        market.feePolicy = newPolicy;
        emit MarketFeePolicySet(marketId, oldPolicy, newPolicy);
    }

    function _convertPriceToSettlementValue(uint256 price) internal pure returns (int256) {
        uint256 scaleDivisor = 10 ** uint256(REDSTONE_FEED_DECIMALS - 6);
        uint256 scaled = price / scaleDivisor;
        require(scaled <= uint256(type(int256).max), "PriceOverflow");
        return int256(scaled);
    }

    function _createMarketInternal(
        ICLMSRMarketCore.MarketCreationParams memory params,
        bool activate
    ) internal returns (uint256 marketId, uint32 numBins) {
        marketId = _nextMarketId;
        _nextMarketId++;

        require(!_marketExists(marketId), CE.MarketAlreadyExists(marketId));

        _validateMarketParameters(params.minTick, params.maxTick, params.tickSpacing);

        require(params.startTimestamp < params.endTimestamp, CE.InvalidTimeRange());
        require(params.endTimestamp < params.settlementTimestamp, CE.InvalidTimeRange());

        require(
            params.liquidityParameter >= MIN_LIQUIDITY_PARAMETER &&
                params.liquidityParameter <= MAX_LIQUIDITY_PARAMETER,
            CE.InvalidLiquidityParameter()
        );

        if (params.feePolicy != address(0)) {
            require(params.feePolicy.code.length > 0, CE.InvalidFeePolicy(params.feePolicy));
        }

        numBins = _calculateNumBins(params.minTick, params.maxTick, params.tickSpacing);

        require(
            numBins != 0 && numBins <= MAX_TICK_COUNT,
            CE.BinCountExceedsLimit(numBins, MAX_TICK_COUNT)
        );

        markets[marketId] = ICLMSRMarketCore.Market({
            isActive: activate,
            settled: false,
            startTimestamp: params.startTimestamp,
            endTimestamp: params.endTimestamp,
            settlementTick: 0,
            minTick: params.minTick,
            maxTick: params.maxTick,
            tickSpacing: params.tickSpacing,
            numBins: numBins,
            liquidityParameter: params.liquidityParameter,
            positionEventsCursor: 0,
            positionEventsEmitted: false,
            settlementValue: 0,
            settlementTimestamp: params.settlementTimestamp,
            feePolicy: params.feePolicy
        });

        LazyMulSegmentTree.init(marketTrees[marketId], numBins);

        emit MarketCreated(
            marketId,
            params.startTimestamp,
            params.endTimestamp,
            params.minTick,
            params.maxTick,
            params.tickSpacing,
            numBins,
            params.liquidityParameter
        );

        if (params.feePolicy != address(0)) {
            emit MarketFeePolicySet(marketId, address(0), params.feePolicy);
        }

        emit SettlementTimestampUpdated(marketId, params.settlementTimestamp);

        return (marketId, numBins);
    }

    function _marketExists(uint256 marketId) internal view returns (bool) {
        return markets[marketId].numBins != 0;
    }

    function _validateMarketParameters(int256 minTick, int256 maxTick, int256 tickSpacing) internal pure {
        require(minTick < maxTick, CE.InvalidMarketParameters(minTick, maxTick, tickSpacing));
        require(tickSpacing > 0, CE.InvalidMarketParameters(minTick, maxTick, tickSpacing));
        require((maxTick - minTick) % tickSpacing == 0, CE.InvalidMarketParameters(minTick, maxTick, tickSpacing));
    }

    function _calculateNumBins(int256 minTick, int256 maxTick, int256 tickSpacing) internal pure returns (uint32) {
        int256 range = maxTick - minTick;
        int256 ranges = range / tickSpacing;
        require(ranges > 0 && ranges <= int256(uint256(MAX_TICK_COUNT)), CE.InvalidRangeCount(ranges, MAX_TICK_COUNT));
        return uint32(uint256(ranges));
    }
}

```


## contracts/mocks/MockERC20.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @title MockERC20
/// @notice Simple ERC20 mock for testing purposes
contract MockERC20 is ERC20, Ownable {
    uint8 private _decimals;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals_
    ) ERC20(name, symbol) Ownable(msg.sender) {
        _decimals = decimals_;
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) public onlyOwner {
        _burn(from, amount);
    }
} 
```


## contracts/mocks/MockPosition.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {ICLMSRPosition} from "../interfaces/ICLMSRPosition.sol";
import {CLMSRErrors as CE} from "../errors/CLMSRErrors.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @title MockPosition
/// @notice Test helper contract that mimics the production CLMSR position manager
/// @dev Provides additional view helpers for tests while enforcing core-only mutations
contract MockPosition is ERC721Enumerable, Ownable, ICLMSRPosition {
    address public core;
    uint256 private _nextId;

    mapping(uint256 positionId => Position) private _positions;

    mapping(uint256 marketId => uint256[]) private _marketTokenList;
    mapping(uint256 positionId => uint256) private _positionMarket;
    mapping(uint256 positionId => uint256) private _positionMarketIndex;

    constructor() ERC721("Mock CLMSR Position", "MCLMSR-POS") Ownable(msg.sender) {
        _nextId = 1;
    }

    modifier onlyCore() {
        require(msg.sender == core, CE.UnauthorizedCaller(msg.sender));
        _;
    }

    function setCore(address newCore) external onlyOwner {
        require(newCore != address(0), CE.ZeroAddress());
        core = newCore;
    }

    function getCoreContract() external view returns (address) {
        return core;
    }

    function isAuthorizedCaller(address account) external view returns (bool) {
        return account == core;
    }

    function getNextId() external view returns (uint256) {
        return _nextId;
    }

    function mintPosition(
        address trader,
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity
    ) external onlyCore returns (uint256 positionId) {
        require(trader != address(0), CE.ZeroAddress());
        require(quantity != 0, CE.InvalidQuantity(quantity));

        positionId = _nextId++;

        _positions[positionId] = Position({
            marketId: marketId,
            lowerTick: lowerTick,
            upperTick: upperTick,
            quantity: quantity,
            createdAt: uint64(block.timestamp)
        });

        _safeMint(trader, positionId);

        _marketTokenList[marketId].push(positionId);
        _positionMarket[positionId] = marketId;
        _positionMarketIndex[positionId] = _marketTokenList[marketId].length; // 1-based index

        emit PositionMinted(positionId, trader, marketId, lowerTick, upperTick, quantity);
    }

    function updateQuantity(uint256 positionId, uint128 newQuantity) public onlyCore {
        require(_positionExists(positionId), CE.PositionNotFound(positionId));
        require(newQuantity != 0, CE.InvalidQuantity(newQuantity));

        uint128 oldQuantity = _positions[positionId].quantity;
        _positions[positionId].quantity = newQuantity;

        emit PositionUpdated(positionId, oldQuantity, newQuantity);
    }

    function setPositionQuantity(uint256 positionId, uint128 newQuantity) external onlyCore {
        updateQuantity(positionId, newQuantity);
    }

    function burn(uint256 positionId) public onlyCore {
        require(_positionExists(positionId), CE.PositionNotFound(positionId));

        address owner = ownerOf(positionId);
        uint256 marketId = _positionMarket[positionId];
        uint256 index = _positionMarketIndex[positionId];

        _burn(positionId);
        delete _positions[positionId];

        if (index != 0) {
            uint256 arrayIndex = index - 1;
            if (arrayIndex < _marketTokenList[marketId].length) {
                _marketTokenList[marketId][arrayIndex] = 0;
            }
            delete _positionMarketIndex[positionId];
        }
        delete _positionMarket[positionId];

        emit PositionBurned(positionId, owner);
    }

    function burnPosition(uint256 positionId) external onlyCore {
        burn(positionId);
    }

    function updateCore(address newCore) external onlyOwner {
        require(newCore != address(0), CE.ZeroAddress());
        core = newCore;
    }

    function getPosition(uint256 positionId) external view returns (Position memory data) {
        require(_positionExists(positionId), CE.PositionNotFound(positionId));
        data = _positions[positionId];
    }

    function exists(uint256 positionId) external view returns (bool) {
        return _positionExists(positionId);
    }

    function coreContract() external view returns (address) {
        return core;
    }

    function getPositionsByOwner(address owner) external view returns (uint256[] memory positions_) {
        uint256 count = balanceOf(owner);
        positions_ = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            positions_[i] = tokenOfOwnerByIndex(owner, i);
        }
    }

    function getMarketTokenLength(uint256 marketId) external view returns (uint256 length) {
        length = _marketTokenList[marketId].length;
    }

    function getMarketTokenAt(uint256 marketId, uint256 index) external view returns (uint256 tokenId) {
        tokenId = _marketTokenList[marketId][index];
    }

    function getMarketPositions(uint256 marketId) external view returns (uint256[] memory positions_) {
        uint256[] storage tokens = _marketTokenList[marketId];
        uint256 count;

        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 tokenId = tokens[i];
            if (tokenId != 0 && _positionExists(tokenId)) {
                count++;
            }
        }

        positions_ = new uint256[](count);
        uint256 idx;
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 tokenId = tokens[i];
            if (tokenId != 0 && _positionExists(tokenId)) {
                positions_[idx++] = tokenId;
            }
        }
    }

    function getUserPositionsInMarket(address owner, uint256 marketId) external view returns (uint256[] memory positions_) {
        uint256 length = _marketTokenList[marketId].length;
        uint256 count;
        for (uint256 i = 0; i < length; i++) {
            uint256 tokenId = _marketTokenList[marketId][i];
            if (tokenId != 0 && ownerOf(tokenId) == owner) {
                count++;
            }
        }

        positions_ = new uint256[](count);
        uint256 idx;
        for (uint256 i = 0; i < length; i++) {
            uint256 tokenId = _marketTokenList[marketId][i];
            if (tokenId != 0 && ownerOf(tokenId) == owner) {
                positions_[idx++] = tokenId;
            }
        }
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721Enumerable, IERC165)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _positionExists(uint256 positionId) internal view returns (bool) {
        return _ownerOf(positionId) != address(0);
    }
}

```


## contracts/mocks/ReentrantPositionAttacker.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IERC721Receiver } from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import { ICLMSRMarketCore } from "../interfaces/ICLMSRMarketCore.sol";

/// @title ReentrantPositionAttacker
/// @notice Malicious receiver contract used to simulate ERC721 reentrancy against core operations
contract ReentrantPositionAttacker is IERC721Receiver {
    ICLMSRMarketCore public immutable core;
    address public immutable paymentToken;

    uint256 private targetMarketId;
    int256 private targetLowerTick;
    int256 private targetUpperTick;
    uint128 private targetQuantity;
    uint256 private targetMaxCost;
    bool private shouldReenter;

    constructor(address coreAddress, address paymentTokenAddress) {
        core = ICLMSRMarketCore(coreAddress);
        paymentToken = paymentTokenAddress;
    }

    function configureAttack(
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity,
        uint256 maxCost
    ) external {
        targetMarketId = marketId;
        targetLowerTick = lowerTick;
        targetUpperTick = upperTick;
        targetQuantity = quantity;
        targetMaxCost = maxCost;
    }

    function approvePayment() external {
        IERC20(paymentToken).approve(address(core), type(uint256).max);
    }

    function attackOpenPosition() external {
        shouldReenter = true;
        core.openPosition(
            targetMarketId,
            targetLowerTick,
            targetUpperTick,
            targetQuantity,
            targetMaxCost
        );
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        if (shouldReenter) {
            shouldReenter = false;
            core.openPosition(
                targetMarketId,
                targetLowerTick,
                targetUpperTick,
                targetQuantity,
                targetMaxCost
            );
        }
        return IERC721Receiver.onERC721Received.selector;
    }
}

```


## contracts/mocks/ReentrantPositionMock.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {ICLMSRPosition} from "../interfaces/ICLMSRPosition.sol";
import {ICLMSRMarketCore} from "../interfaces/ICLMSRMarketCore.sol";
import {CLMSRErrors as CE} from "../errors/CLMSRErrors.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @title ReentrantPositionMock
/// @notice Malicious position contract used to simulate reentrant behaviours against the core contract
contract ReentrantPositionMock is ERC721Enumerable, Ownable, ICLMSRPosition {
    enum AttackMode {
        None,
        Decrease,
        Close,
        Claim,
        EmitBatch
    }

    address public core;
    uint256 private _nextId;

    mapping(uint256 positionId => Position) private _positions;
    mapping(uint256 marketId => uint256[]) private _marketTokenList;
    mapping(uint256 positionId => uint256) private _positionMarket;
    mapping(uint256 positionId => uint256) private _positionMarketIndex;

    AttackMode public attackMode;
    uint256 public attackTargetPosition;
    uint128 public attackQuantity;
    uint256 public attackMinProceeds;
    uint256 public attackEmitLimit;

    constructor() ERC721("Reentrant CLMSR Position", "RCLMSR-POS") Ownable(msg.sender) {
        _nextId = 1;
    }

    modifier onlyCore() {
        require(msg.sender == core, CE.UnauthorizedCaller(msg.sender));
        _;
    }

    function setCore(address newCore) external onlyOwner {
        require(newCore != address(0), CE.ZeroAddress());
        core = newCore;
    }

    function updateCore(address newCore) external onlyOwner {
        require(newCore != address(0), CE.ZeroAddress());
        core = newCore;
    }

    function configureAttack(
        AttackMode mode,
        uint256 targetPosition,
        uint128 quantity,
        uint256 minProceeds,
        uint256 emitLimit
    ) external onlyOwner {
        attackMode = mode;
        attackTargetPosition = targetPosition;
        attackQuantity = quantity;
        attackMinProceeds = minProceeds;
        attackEmitLimit = emitLimit;
    }

    function getCoreContract() external view returns (address) {
        return core;
    }

    function isAuthorizedCaller(address account) external view returns (bool) {
        return account == core;
    }

    function getNextId() external view returns (uint256) {
        return _nextId;
    }

    function mintPosition(
        address trader,
        uint256 marketId,
        int256 lowerTick,
        int256 upperTick,
        uint128 quantity
    ) external onlyCore returns (uint256 positionId) {
        require(trader != address(0), CE.ZeroAddress());
        require(quantity != 0, CE.InvalidQuantity(quantity));

        positionId = _nextId++;

        _positions[positionId] = Position({
            marketId: marketId,
            lowerTick: lowerTick,
            upperTick: upperTick,
            quantity: quantity,
            createdAt: uint64(block.timestamp)
        });

        _safeMint(trader, positionId);

        _marketTokenList[marketId].push(positionId);
        _positionMarket[positionId] = marketId;
        _positionMarketIndex[positionId] = _marketTokenList[marketId].length;

        emit PositionMinted(positionId, trader, marketId, lowerTick, upperTick, quantity);
    }

    function updateQuantity(uint256 positionId, uint128 newQuantity) public onlyCore {
        require(_positionExists(positionId), CE.PositionNotFound(positionId));
        require(newQuantity != 0, CE.InvalidQuantity(newQuantity));

        if (attackMode == AttackMode.Decrease) {
            attackMode = AttackMode.None;
            uint256 targetId = attackTargetPosition == 0 ? positionId : attackTargetPosition;
            uint128 qty = attackQuantity == 0 ? 1 : attackQuantity;
            ICLMSRMarketCore(core).decreasePosition(targetId, qty, attackMinProceeds);
        }

        uint128 oldQuantity = _positions[positionId].quantity;
        _positions[positionId].quantity = newQuantity;

        emit PositionUpdated(positionId, oldQuantity, newQuantity);
    }

    function setPositionQuantity(uint256 positionId, uint128 newQuantity) external onlyCore {
        updateQuantity(positionId, newQuantity);
    }

    function burn(uint256 positionId) public onlyCore {
        require(_positionExists(positionId), CE.PositionNotFound(positionId));

        address owner = ownerOf(positionId);
        uint256 marketId = _positionMarket[positionId];
        uint256 index = _positionMarketIndex[positionId];

        if (attackMode == AttackMode.Close) {
            attackMode = AttackMode.None;
            uint256 targetId = attackTargetPosition == 0 ? positionId : attackTargetPosition;
            ICLMSRMarketCore(core).closePosition(targetId, attackMinProceeds);
        } else if (attackMode == AttackMode.Claim) {
            attackMode = AttackMode.None;
            uint256 targetId = attackTargetPosition == 0 ? positionId : attackTargetPosition;
            ICLMSRMarketCore(core).claimPayout(targetId);
        } else if (attackMode == AttackMode.EmitBatch) {
            attackMode = AttackMode.None;
            uint256 limit = attackEmitLimit == 0 ? 1 : attackEmitLimit;
            ICLMSRMarketCore(core).emitPositionSettledBatch(marketId, limit);
        }

        _burn(positionId);
        delete _positions[positionId];

        if (index != 0) {
            uint256 arrayIndex = index - 1;
            if (arrayIndex < _marketTokenList[marketId].length) {
                _marketTokenList[marketId][arrayIndex] = 0;
            }
            delete _positionMarketIndex[positionId];
        }
        delete _positionMarket[positionId];

        emit PositionBurned(positionId, owner);
    }

    function burnPosition(uint256 positionId) external onlyCore {
        burn(positionId);
    }

    function getPosition(uint256 positionId) external view returns (Position memory data) {
        require(_positionExists(positionId), CE.PositionNotFound(positionId));
        data = _positions[positionId];
    }

    function exists(uint256 positionId) external view returns (bool) {
        return _positionExists(positionId);
    }

    function coreContract() external view returns (address) {
        return core;
    }

    function getPositionsByOwner(address owner) external view returns (uint256[] memory positions_) {
        uint256 count = balanceOf(owner);
        positions_ = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            positions_[i] = tokenOfOwnerByIndex(owner, i);
        }
    }

    function getMarketTokenLength(uint256 marketId) external view returns (uint256 length) {
        length = _marketTokenList[marketId].length;
    }

    function getMarketTokenAt(uint256 marketId, uint256 index) external view returns (uint256 tokenId) {
        tokenId = _marketTokenList[marketId][index];
    }

    function getMarketPositions(uint256 marketId) external view returns (uint256[] memory positions_) {
        uint256[] storage tokens = _marketTokenList[marketId];
        uint256 count;

        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 tokenId = tokens[i];
            if (tokenId != 0 && _positionExists(tokenId)) {
                count++;
            }
        }

        positions_ = new uint256[](count);
        uint256 idx;
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 tokenId = tokens[i];
            if (tokenId != 0 && _positionExists(tokenId)) {
                positions_[idx++] = tokenId;
            }
        }
    }

    function getUserPositionsInMarket(address owner, uint256 marketId) external view returns (uint256[] memory positions_) {
        uint256 length = _marketTokenList[marketId].length;
        uint256 count;
        for (uint256 i = 0; i < length; i++) {
            uint256 tokenId = _marketTokenList[marketId][i];
            if (tokenId != 0 && ownerOf(tokenId) == owner) {
                count++;
            }
        }

        positions_ = new uint256[](count);
        uint256 idx;
        for (uint256 i = 0; i < length; i++) {
            uint256 tokenId = _marketTokenList[marketId][i];
            if (tokenId != 0 && ownerOf(tokenId) == owner) {
                positions_[idx++] = tokenId;
            }
        }
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721Enumerable, IERC165)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _positionExists(uint256 positionId) internal view returns (bool) {
        return _ownerOf(positionId) != address(0);
    }
}

```


## contracts/points/PointsGranter.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {PointsErrors as PE} from "../errors/PointsErrors.sol";

/**
 * @title PointsGranter
 * @notice UUPS Ìå®ÌÑ¥. Ïò®Ï≤¥Ïù∏ Ïä§ÌÜ†Î¶¨ÏßÄÎäî ÏóÜÍ≥† Ïù¥Î≤§Ìä∏Îßå Î∞úÏÉùÏãúÏºú Ïù∏Îç±Ïã±Ïö©ÏúºÎ°ú ÏÇ¨Ïö©.
 */
contract PointsGranter is Initializable, OwnableUpgradeable, UUPSUpgradeable {
    /// reason: 1=ACTIVITY, 2=PERFORMANCE, 3=RISK_BONUS, 100+=MANUAL
    /// contextTs: 0Ïù¥Î©¥ Ïù∏Îç±ÏÑúÏóêÏÑú block.timestamp ÏÇ¨Ïö©
    event PointsGranted(address indexed user, uint256 amount, uint8 reason, uint64 contextTs);

    function initialize(address initialOwner) public initializer {
        __Ownable_init(initialOwner);
        __UUPSUpgradeable_init();
    }

    function _authorizeUpgrade(address) internal override onlyOwner {}



    function grantPoints(
        address user,
        uint256 amount, // 6 decimals
        uint8 reason,
        uint64 contextTs // 0 or backfill timestamp
    ) external onlyOwner {
        require(user != address(0) && amount > 0, PE.InvalidParameters());
        emit PointsGranted(user, amount, reason, contextTs);
    }

    function batchGrantPoints(
        address[] calldata users,
        uint256[] calldata amounts,
        uint8[] calldata reasons,
        uint64[] calldata contextTs
    ) external onlyOwner {
        uint256 n = users.length;
        require(n == amounts.length && n == reasons.length && n == contextTs.length, PE.ParameterArrayLengthMismatch());
        for (uint256 i = 0; i < n; i++) {
            emit PointsGranted(users[i], amounts[i], reasons[i], contextTs[i]);
        }
    }
}

 
```


## contracts/test/CLMSRMarketCoreV2Mock.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "../core/CLMSRMarketCore.sol";

/// @notice ÌÖåÏä§Ìä∏ Ï†ÑÏö© V2 Íµ¨ÌòÑÏúºÎ°ú, ÏóÖÍ∑∏Î†àÏù¥Îìú Í≤ΩÎ°ú Í≤ÄÏ¶ùÏùÑ ÏúÑÌïú ÏµúÏÜå ÌôïÏû• Î≤ÑÏ†Ñ
contract CLMSRMarketCoreV2Mock is CLMSRMarketCore {
    /// @notice V2 Íµ¨ÌòÑÏûÑÏùÑ ÎÇòÌÉÄÎÇ¥Îäî ÏãùÎ≥ÑÏûê
    function version() external pure returns (string memory) {
        return "v2-mock";
    }

    /// @notice ÏóÖÍ∑∏Î†àÏù¥Îìú ÌõÑ ÏÉÅÌÉú Î≥¥Ï°¥ ÌôïÏù∏ÏùÑ ÏúÑÌïú Ìó¨Ìçº
    function snapshotState()
        external
        view
        returns (address currentManager, uint256 nextMarketId)
    {
        return (manager, _nextMarketId);
    }
}

```


## contracts/test/CLMSRMarketManagerTest.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "../managers/CLMSRMarketManager.sol";

/// @dev Test-only manager that allows Hardhat local signers (chainid 31337) as authorised RedStone signers.
contract CLMSRMarketManagerTest is CLMSRMarketManager {
    address private constant LOCAL_SIGNER_0 = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;
    address private constant LOCAL_SIGNER_1 = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8;
    address private constant LOCAL_SIGNER_2 = 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC;

    function getAuthorisedSignerIndex(address signerAddress)
        public
        view
        override
        returns (uint8)
    {
        if (block.chainid == 31337) {
            if (signerAddress == LOCAL_SIGNER_0) return 0;
            if (signerAddress == LOCAL_SIGNER_1) return 1;
            if (signerAddress == LOCAL_SIGNER_2) return 2;
            revert SignerNotAuthorised(signerAddress);
        }
        return super.getAuthorisedSignerIndex(signerAddress);
    }

    function getUniqueSignersThreshold() public view override returns (uint8) {
        if (block.chainid == 31337) {
            return 3;
        }
        return super.getUniqueSignersThreshold();
    }
}

```


## contracts/test/CLMSRMathHarness.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {CLMSRMarketCore} from "../core/CLMSRMarketCore.sol";

/// @dev Thin harness to expose internal math helpers from CLMSRMarketCore for testing parity.
contract CLMSRMathHarness is CLMSRMarketCore {
    /// @notice Expose the internal _safeExp helper for tests.
    function exposedSafeExp(uint256 q, uint256 alpha) external pure returns (uint256) {
        return _safeExp(q, alpha);
    }
}

```


## contracts/test/CLMSRPositionV2Mock.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "../core/CLMSRPosition.sol";

/// @notice ÌÖåÏä§Ìä∏ Ï†ÑÏö© V2 Íµ¨ÌòÑ (ÏóÖÍ∑∏Î†àÏù¥Îìú ÌöåÍ∑Ä Í≤ÄÏ¶ùÏö©)
contract CLMSRPositionV2Mock is CLMSRPosition {
    /// @notice V2 ÏãùÎ≥ÑÏûêÎ•º ÎÖ∏Ï∂úÌï¥ ÏóÖÍ∑∏Î†àÏù¥Îìú ÏÑ±Í≥µ Ïó¨Î∂ÄÎ•º ÌôïÏù∏ÌïúÎã§.
    function version() external pure returns (string memory) {
        return "position-v2-mock";
    }
}

```


## contracts/test/FixedPointMathTest.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {FixedPointMathU, FP_DivisionByZero, FP_InvalidInput} from "../libraries/FixedPointMath.sol";
import {sqrt} from "@prb/math/src/ud60x18/Math.sol";
import {wrap as wrapUd, unwrap as unwrapUd} from "@prb/math/src/ud60x18/Casting.sol";
import {mul as mulSd, div as divSd} from "@prb/math/src/sd59x18/Math.sol";
import {wrap as wrapSd, unwrap as unwrapSd} from "@prb/math/src/sd59x18/Casting.sol";

error FP_EmptyArray();
error FP_Overflow();
error FP_SignedOverflow();

contract FixedPointMathTest {
    uint256 public constant WAD = 1e18;
    uint256 public constant UNIT = 1e18;

    // ---------------------------------------------------------------------
    // Core math wrappers
    // ---------------------------------------------------------------------

    function wExp(uint256 x) public pure returns (uint256) {
        return FixedPointMathU.wExp(x);
    }

    function wLn(uint256 x) public pure returns (uint256) {
        return FixedPointMathU.wLn(x);
    }

    function wLnSigned(uint256 x) external pure returns (int256) {
        return int256(FixedPointMathU.wLn(x));
    }

    function wMul(uint256 a, uint256 b) public pure returns (uint256) {
        return FixedPointMathU.wMul(a, b);
    }

    function wDiv(uint256 a, uint256 b) public pure returns (uint256) {
        return FixedPointMathU.wDiv(a, b);
    }

    function wSqrt(uint256 x) public pure returns (uint256) {
        return unwrapUd(sqrt(wrapUd(x)));
    }

    function wMulSigned(int256 a, int256 b) public pure returns (int256) {
        if (a == type(int256).min || b == type(int256).min) revert FP_SignedOverflow();

        bool negative = (a < 0) != (b < 0);
        uint256 aAbs = _abs(a);
        uint256 bAbs = _abs(b);
        uint256 unsignedResult = FixedPointMathU.wMul(aAbs, bAbs);
        if (unsignedResult > uint256(type(int256).max)) revert FP_Overflow();

        int256 signedResult = int256(unsignedResult);
        return negative ? -signedResult : signedResult;
    }

    function wDivSigned(int256 a, int256 b) public pure returns (int256) {
        if (b == 0) revert FP_DivisionByZero();
        if (a == type(int256).min || b == type(int256).min) revert FP_SignedOverflow();

        bool negative = (a < 0) != (b < 0);
        uint256 aAbs = _abs(a);
        uint256 bAbs = _abs(b);
        uint256 unsignedResult = FixedPointMathU.wDiv(aAbs, bAbs);
        if (unsignedResult > uint256(type(int256).max)) revert FP_Overflow();

        int256 signedResult = int256(unsignedResult);
        return negative ? -signedResult : signedResult;
    }

    // ---------------------------------------------------------------------
    // CLMSR helpers
    // ---------------------------------------------------------------------

    function clmsrCost(
        uint256 alpha,
        uint256 sumBefore,
        uint256 sumAfter
    ) public pure returns (uint256) {
        uint256 ratio = FixedPointMathU.wDiv(sumAfter, sumBefore);
        uint256 lnRatio = FixedPointMathU.wLn(ratio);
        return FixedPointMathU.wMul(alpha, lnRatio);
    }

    function clmsrCostSigned(
        int256 alpha,
        uint256 sumBefore,
        uint256 sumAfter
    ) public pure returns (int256) {
        if (sumBefore == 0 || sumAfter == 0) revert FP_InvalidInput();

        int256 lnRatioSigned;
        if (sumAfter >= sumBefore) {
            uint256 ratio = FixedPointMathU.wDiv(sumAfter, sumBefore);
            uint256 lnRatio = FixedPointMathU.wLn(ratio);
            lnRatioSigned = int256(lnRatio);
        } else {
            uint256 ratio = FixedPointMathU.wDiv(sumBefore, sumAfter);
            uint256 lnRatio = FixedPointMathU.wLn(ratio);
            lnRatioSigned = -int256(lnRatio);
        }

        return wMulSigned(alpha, lnRatioSigned);
    }

    function clmsrPrice(uint256 expValue, uint256 totalSumExp) external pure returns (uint256) {
        return FixedPointMathU.wDiv(expValue, totalSumExp);
    }

    // ---------------------------------------------------------------------
    // Array operations
    // ---------------------------------------------------------------------

    function sumExp(uint256[] memory values) public pure returns (uint256) {
        return _sumExp(values);
    }

    function logSumExp(uint256[] memory values) public pure returns (uint256) {
        uint256 total = _sumExp(values);
        return FixedPointMathU.wLn(total);
    }

    // ---------------------------------------------------------------------
    // Utility & conversion helpers
    // ---------------------------------------------------------------------

    function testToWad(uint256 amt6) external pure returns (uint256) {
        return FixedPointMathU.toWad(amt6);
    }

    function testFromWad(uint256 amtWad) external pure returns (uint256) {
        return FixedPointMathU.fromWad(amtWad);
    }

    function testFromWadRoundUp(uint256 amtWad) external pure returns (uint256) {
        return FixedPointMathU.fromWadRoundUp(amtWad);
    }

    function testFromWadNearest(uint256 amtWad) external pure returns (uint256) {
        return FixedPointMathU.fromWadNearest(amtWad);
    }

    function testFromWadNearestMin1(uint256 amtWad) external pure returns (uint256) {
        return FixedPointMathU.fromWadNearestMin1(amtWad);
    }

    function wMulNearest(uint256 a, uint256 b) public pure returns (uint256) {
        return FixedPointMathU.wMulNearest(a, b);
    }

    // ---------------------------------------------------------------------
    // Signed math via PRB SD59x18 wrappers
    // ---------------------------------------------------------------------

    function sdMul(int256 a, int256 b) external pure returns (int256) {
        return unwrapSd(mulSd(wrapSd(a), wrapSd(b)));
    }

    function sdDiv(int256 a, int256 b) external pure returns (int256) {
        return unwrapSd(divSd(wrapSd(a), wrapSd(b)));
    }

    // ---------------------------------------------------------------------
    // Internal helpers
    // ---------------------------------------------------------------------

    function _sumExp(uint256[] memory values) private pure returns (uint256 sum) {
        uint256 len = values.length;
        if (len == 0) revert FP_EmptyArray();

        for (uint256 i = 0; i < len; i++) {
            uint256 term = FixedPointMathU.wExp(values[i]);
            sum = _safeAdd(sum, term);
        }
    }

    function _safeAdd(uint256 a, uint256 b) private pure returns (uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) revert FP_Overflow();
            return c;
        }
    }

    function _abs(int256 value) private pure returns (uint256) {
        if (value >= 0) {
            return uint256(value);
        }
        if (value == type(int256).min) revert FP_SignedOverflow();
        return uint256(-value);
    }
}

```


## contracts/test/LazyMulSegmentTreeHarness.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {LazyMulSegmentTree} from "../libraries/LazyMulSegmentTree.sol";

/// @dev Direct harness around LazyMulSegmentTree for white-box unit tests
contract LazyMulSegmentTreeHarness {
    using LazyMulSegmentTree for LazyMulSegmentTree.Tree;

    LazyMulSegmentTree.Tree internal _tree;

    function init(uint32 size) external {
        _tree.init(size);
    }

    function applyFactor(uint32 lo, uint32 hi, uint256 factor) external {
        _tree.applyRangeFactor(lo, hi, factor);
    }

    function rangeSum(uint32 lo, uint32 hi) external view returns (uint256) {
        return _tree.getRangeSum(lo, hi);
    }

    function propagate(uint32 lo, uint32 hi) external returns (uint256) {
        return _tree.propagateLazy(lo, hi);
    }

    function root() external view returns (uint32) {
        return _tree.root;
    }

    function cachedRootSum() external view returns (uint256) {
        return _tree.cachedRootSum;
    }

    function getNode(uint32 idx)
        external
        view
        returns (uint256 sum, uint256 pendingFactor, uint64 childPtr)
    {
        LazyMulSegmentTree.Node storage node = _tree.nodes[idx];
        return (node.sum, uint256(node.pendingFactor), node.childPtr);
    }
}

```


## contracts/test/LazyMulSegmentTreeTest.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {CLMSRErrors as CE} from "../errors/CLMSRErrors.sol";
import {FixedPointMathU} from "../libraries/FixedPointMath.sol";

/// @title LazyMulSegmentTreeTest
/// @notice Simplified reference contract that mimics LazyMulSegmentTree behaviour for unit tests
contract LazyMulSegmentTreeTest {
    using FixedPointMathU for uint256;

    uint256 public constant ONE_WAD = 1e18;
    uint256 public constant MIN_FACTOR = 0.01e18;
    uint256 public constant MAX_FACTOR = 100e18;

    enum OpKind { Factor, Update }

    struct Operation {
        OpKind kind;
        uint32 lo;
        uint32 hi;
        uint256 factorOrValue;
    }

    uint32 private _size;
    bool private _initialized;
    Operation[] private _ops;

    event Initialized(uint256 size);
    event NodeUpdated(uint256 index, uint256 newValue);
    event RangeFactorApplied(uint256 lo, uint256 hi, uint256 factor);

    modifier onlyInitialized() {
        if (!_initialized) revert CE.TreeNotInitialized();
        _;
    }

    function init(uint256 size) external {
        if (size == 0) revert CE.TreeSizeZero();
        if (_initialized) revert CE.TreeAlreadyInitialized();
        if (size > type(uint32).max / 2) revert CE.TreeSizeTooLarge();

        _size = uint32(size);
        _initialized = true;
        delete _ops;

        emit Initialized(size);
    }

    function update(uint256 index, uint256 newValue) external onlyInitialized {
        if (index >= _size) revert CE.IndexOutOfBounds(uint32(index), _size);

        _ops.push(Operation({ kind: OpKind.Update, lo: uint32(index), hi: uint32(index), factorOrValue: newValue }));
        emit NodeUpdated(index, newValue);
    }

    function batchUpdate(uint32[] calldata indices, uint256[] calldata values) external onlyInitialized {
        if (indices.length != values.length) revert CE.ArrayLengthMismatch();
        for (uint256 i = 0; i < indices.length; i++) {
            if (indices[i] >= _size) revert CE.IndexOutOfBounds(indices[i], _size);
            _ops.push(Operation({ kind: OpKind.Update, lo: indices[i], hi: indices[i], factorOrValue: values[i] }));
            emit NodeUpdated(indices[i], values[i]);
        }
    }

    function applyRangeFactor(uint256 lo, uint256 hi, uint256 factor) external onlyInitialized {
        if (lo > hi) revert CE.InvalidRange(uint32(lo), uint32(hi));
        if (hi >= _size) revert CE.IndexOutOfBounds(uint32(hi), _size);
        if (factor < MIN_FACTOR || factor > MAX_FACTOR) revert CE.InvalidFactor(factor);

        _ops.push(Operation({ kind: OpKind.Factor, lo: uint32(lo), hi: uint32(hi), factorOrValue: factor }));
        emit RangeFactorApplied(lo, hi, factor);
    }

    function getRangeSum(uint256 lo, uint256 hi) public view onlyInitialized returns (uint256 sum) {
        if (lo > hi) revert CE.InvalidRange(uint32(lo), uint32(hi));
        if (hi >= _size) revert CE.IndexOutOfBounds(uint32(hi), _size);

        for (uint256 idx = lo; idx <= hi; idx++) {
            sum += _valueAt(uint32(idx));
        }
    }

    function getTotalSum() external view onlyInitialized returns (uint256) {
        if (_size == 0) return 0;
        return getRangeSum(0, _size - 1);
    }

    function getTreeSize() external view returns (uint256) {
        return _size;
    }

    function getNodeValue(uint256 index) external view onlyInitialized returns (uint256) {
        if (index >= _size) revert CE.IndexOutOfBounds(uint32(index), _size);
        return _valueAt(uint32(index));
    }

    function getLazyValue(uint256) external pure returns (uint256) {
        return 0;
    }

    function _valueAt(uint32 index) internal view returns (uint256 value) {
        value = ONE_WAD;
        for (uint256 i = 0; i < _ops.length; i++) {
            Operation memory op = _ops[i];
            if (op.kind == OpKind.Update) {
                if (op.lo == index) {
                    value = op.factorOrValue;
                }
            } else {
                if (index >= op.lo && index <= op.hi) {
                    value = _mulWad(value, op.factorOrValue);
                }
            }
        }
    }

    function _mulWad(uint256 a, uint256 b) private pure returns (uint256) {
        if (a == 0 || b == 0) return 0;
        return a.wMulNearest(b);
    }
}

```


## contracts/test/MockExcessiveFeePolicy.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "../fees/interfaces/ICLMSRFeePolicy.sol";

/// @title MockExcessiveFeePolicy
/// @notice ÌÖåÏä§Ìä∏Ïö© Ï†ïÏ±ÖÏúºÎ°ú baseAmountÎ≥¥Îã§ ÌÅ∞ ÏàòÏàòÎ£åÎ•º Í∞ïÏ†úÎ°ú Î∞òÌôòÌïúÎã§.
contract MockExcessiveFeePolicy is ICLMSRFeePolicy {
    function quoteFee(QuoteParams calldata params) external pure override returns (uint256) {
        return params.baseAmount + 1;
    }

    function name() external pure override returns (string memory) {
        return "MockExcessiveFeePolicy";
    }

    function descriptor() external pure override returns (string memory) {
        return '{"policy":"mock","params":{"behavior":"excessive"}}';
    }
}

```

## SDK Source


## clmsr-sdk/src/clmsr-sdk.ts

```typescript
import Big from "big.js";
import {
  MarketDistribution,
  Market,
  Position,
  OpenCostResult,
  IncreaseCostResult,
  DecreaseProceedsResult,
  CloseProceedsResult,
  ClaimResult,
  QuantityFromCostResult,
  QuantityFromProceedsResult,
  PositionValueResult,
  WADAmount,
  USDCAmount,
  Quantity,
  Tick,
  FeeInfo,
  FeePolicyKind,
  ValidationError,
  CalculationError,
} from "./types";

import * as MathUtils from "./utils/math";
import {
  Bytes32Like,
  TradeSide,
  quoteOpenFee,
  quoteSellFee,
  resolveFeePolicyWithMetadata,
  NullFeePolicy,
} from "./fees";

// Re-export types and utilities for easy access
export * from "./types";
export { toWAD, toMicroUSDC } from "./utils/math";

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const ZERO_CONTEXT: Bytes32Like = `0x${"00".repeat(32)}` as Bytes32Like;

const INVERSE_SPEND_TOLERANCE = new Big(1); // 1 micro USDC tolerance
const MAX_INVERSE_ITERATIONS = 64;

function bigToBigInt(value: Big): bigint {
  const rounded = value.round(0, Big.roundDown);
  if (!rounded.eq(value)) {
    throw new CalculationError(
      "Fee calculations require integer micro-USDC amounts"
    );
  }
  return BigInt(rounded.toFixed(0, Big.roundDown));
}

/**
 * CLMSR SDK - Ïª®Ìä∏ÎûôÌä∏ Î∑∞Ìï®ÏàòÎì§Í≥º Ïó≠Ìï®Ïàò Ï†úÍ≥µ
 */
export class CLMSRSDK {
  // ============================================================================
  // CONTRACT VIEW FUNCTIONS (Ïª®Ìä∏ÎûôÌä∏ Î∑∞Ìï®ÏàòÎì§)
  // ============================================================================

  /**
   * calculateOpenCost - ÏÉà Ìè¨ÏßÄÏÖò Ïó¥Í∏∞ ÎπÑÏö© Í≥ÑÏÇ∞
   * @param lowerTick Lower tick bound (inclusive)
   * @param upperTick Upper tick bound (exclusive)
   * @param quantity Îß§Ïàò ÏàòÎüâ
   * @param distribution Current market distribution
   * @param market Market parameters
   */
  // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
  calculateOpenCost(
    lowerTick: Tick,
    upperTick: Tick,
    quantity: Quantity,
    distribution: MarketDistribution,
    market: Market
  ): OpenCostResult {
    const normalizedQuantity = MathUtils.formatUSDC(new Big(quantity));

    // Input validation
    if (normalizedQuantity.lte(0)) {
      throw new ValidationError("Quantity must be positive");
    }

    if (!distribution) {
      throw new ValidationError(
        "Distribution data is required but was undefined"
      );
    }

    // Tick range Í≤ÄÏ¶ù
    this.validateTickRange(lowerTick, upperTick, market);

    // ÏãúÏû•Î≥Ñ ÏµúÎåÄ ÏàòÎüâ Í≤ÄÏ¶ù (UX Í∞úÏÑ†)
    this._assertQuantityWithinLimit(
      normalizedQuantity,
      market.liquidityParameter
    );

    // Convert to WAD for calculations
    const alpha = market.liquidityParameter;
    const quantityWad = MathUtils.toWad(normalizedQuantity);

    // Get current state
    const sumBefore = distribution.totalSum;
    const affectedSum = this.getAffectedSum(
      lowerTick,
      upperTick,
      distribution,
      market
    );

    // 1. Calculate factor: exp(quantity / Œ±) - Ïª®Ìä∏ÎûôÌä∏ÏôÄ ÎèôÏùº, safe chunking ÏÇ¨Ïö©
    const factor = MathUtils.safeExp(quantityWad, alpha);

    // 2. Calculate sum after trade - Ïª®Ìä∏ÎûôÌä∏ÏôÄ ÎèôÏùº
    const sumAfter = sumBefore
      .minus(affectedSum)
      .plus(MathUtils.wMulNearest(affectedSum, factor));

    // 3. Calculate cost: Œ± * ln(sumAfter / sumBefore) - Ïª®Ìä∏ÎûôÌä∏ÏôÄ ÎèôÏùº
    const ratio = MathUtils.wDivUp(sumAfter, sumBefore);
    const lnRatio = MathUtils.wLn(ratio);
    const costWad = MathUtils.wMul(alpha, lnRatio);

    // Í≥ÑÏÇ∞ ÏôÑÎ£å

    const cost = MathUtils.formatUSDC(MathUtils.fromWadRoundUp(costWad));

    // Calculate average price with proper formatting
    // costÎäî micro USDC, quantityÎèÑ micro USDCÏù¥ÎØÄÎ°ú Í≤∞Í≥ºÎäî USDC/USDC = ÎπÑÏú®
    const averagePrice = cost.div(normalizedQuantity);
    const formattedAveragePrice = new Big(
      averagePrice.toFixed(6, Big.roundDown)
    ); // 6ÏûêÎ¶¨ Ï†ïÎ∞ÄÎèÑÎ°ú Ï∂©Î∂Ñ

    const feeOverlay = this.computeFeeOverlay(
      "BUY",
      cost,
      normalizedQuantity,
      lowerTick,
      upperTick,
      market.feePolicyDescriptor
    );

    const result: OpenCostResult = {
      cost,
      averagePrice: formattedAveragePrice,
      feeAmount: feeOverlay.amount,
      feeRate: feeOverlay.rate,
      feeInfo: feeOverlay.info,
    };

    return result;
  }

  /**
   * calculateIncreaseCost - Í∏∞Ï°¥ Ìè¨ÏßÄÏÖò Ï¶ùÍ∞Ä ÎπÑÏö© Í≥ÑÏÇ∞
   */
  calculateIncreaseCost(
    position: Position,
    additionalQuantity: Quantity,
    distribution: MarketDistribution,
    market: Market
  ): IncreaseCostResult {
    const result = this.calculateOpenCost(
      position.lowerTick,
      position.upperTick,
      additionalQuantity,
      distribution,
      market
    );

    return {
      additionalCost: result.cost,
      averagePrice: result.averagePrice,
      feeAmount: result.feeAmount,
      feeRate: result.feeRate,
      feeInfo: result.feeInfo,
    };
  }

  /**
   * Decrease position ÎπÑÏö© Í≥ÑÏÇ∞
   */
  calculateDecreaseProceeds(
    position: Position,
    sellQuantity: Quantity,
    distribution: MarketDistribution,
    market: Market
  ): DecreaseProceedsResult {
    const normalizedSellQuantity = MathUtils.formatUSDC(new Big(sellQuantity));

    const baseResult = this._calcSellProceeds(
      position.lowerTick,
      position.upperTick,
      normalizedSellQuantity,
      position.quantity,
      distribution,
      market
    );

    const feeOverlay = this.computeFeeOverlay(
      "SELL",
      baseResult.proceeds,
      normalizedSellQuantity,
      position.lowerTick,
      position.upperTick,
      market.feePolicyDescriptor
    );

    return {
      proceeds: baseResult.proceeds,
      averagePrice: baseResult.averagePrice,
      feeAmount: feeOverlay.amount,
      feeRate: feeOverlay.rate,
      feeInfo: feeOverlay.info,
    };
  }

  /**
   * Close position ÎπÑÏö© Í≥ÑÏÇ∞
   */
  calculateCloseProceeds(
    position: Position,
    distribution: MarketDistribution,
    market: Market
  ): CloseProceedsResult {
    const result = this.calculateDecreaseProceeds(
      position,
      position.quantity,
      distribution,
      market
    );

    return {
      proceeds: result.proceeds,
      averagePrice: result.averagePrice,
      feeAmount: result.feeAmount,
      feeRate: result.feeRate,
      feeInfo: result.feeInfo,
    };
  }

  /**
   * Claim amount Í≥ÑÏÇ∞
   */
  calculateClaim(position: Position, settlementTick: Tick): ClaimResult {
    // Ï†ïÏÇ∞ Ìã±Ïù¥ Ìè¨ÏßÄÏÖò Î≤îÏúÑ [lowerTick, upperTick)Ïóê Ìè¨Ìï®ÎêòÎäîÏßÄ ÌôïÏù∏
    const hasWinning =
      position.lowerTick <= settlementTick &&
      position.upperTick > settlementTick;

    if (!hasWinning) {
      // Ìå®Î∞∞ Ìè¨ÏßÄÏÖò: ÌÅ¥Î†àÏûÑ Î∂àÍ∞Ä
      return {
        payout: new Big(0),
      };
    }

    // ÏäπÎ¶¨ Ìè¨ÏßÄÏÖò: 1 USDC per unit
    return {
      payout: position.quantity,
    };
  }

  /**
   * Ìè¨ÏßÄÏÖòÏùò ÌòÑÏû¨ Í∞ÄÏπòÏôÄ ÎØ∏Ïã§ÌòÑ ÏÜêÏùµ Í≥ÑÏÇ∞
   * @param position Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥
   * @param totalCost Ìè¨ÏßÄÏÖòÏùò Ï¥ù ÎπÑÏö© (OPEN + INCREASE ÎπÑÏö© Ìï©Í≥Ñ)
   * @param distribution Current market distribution
   * @param market Market parameters
   * @returns Ìè¨ÏßÄÏÖò ÌòÑÏû¨ Í∞ÄÏπòÏôÄ ÎØ∏Ïã§ÌòÑ ÏÜêÏùµ
   */
  calculatePositionValue(
    position: Position,
    totalCost: USDCAmount,
    distribution: MarketDistribution,
    market: Market
  ): PositionValueResult {
    // Ìè¨ÏßÄÏÖòÏùÑ ÏßÄÍ∏à Îã´ÏïòÏùÑ Îïå Î∞õÏùÑ Ïàò ÏûàÎäî Í∏àÏï° Í≥ÑÏÇ∞
    const closeResult = this.calculateCloseProceeds(
      position,
      distribution,
      market
    );

    const normalizedTotalCost = MathUtils.formatUSDC(new Big(totalCost));
    const currentValue = closeResult.proceeds;
    const unrealizedPnL = currentValue.minus(normalizedTotalCost);

    return {
      currentValue,
      unrealizedPnL,
      averagePrice: closeResult.averagePrice,
      feeAmount: closeResult.feeAmount,
      feeRate: closeResult.feeRate,
      feeInfo: closeResult.feeInfo,
    };
  }

  // ============================================================================
  // INVERSE FUNCTION (Ïó≠Ìï®Ïàò: Îèà ‚Üí ÏàòÎüâ)
  // ============================================================================

  /**
   * Sell positionÏùò ÏòàÏÉÅ ÏàòÏùµ Í≥ÑÏÇ∞
   * @param position Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥
   * @param sellQuantity Îß§ÎèÑÌï† ÏàòÎüâ
   * @param distribution Current market distribution
   * @param market Market parameters
   * @returns ÏòàÏÉÅ ÏàòÏùµ
   */
  calculateSellProceeds(
    position: Position,
    sellQuantity: Quantity,
    distribution: MarketDistribution,
    market: Market
  ): DecreaseProceedsResult {
    const base = this._calcSellProceeds(
      position.lowerTick,
      position.upperTick,
      sellQuantity,
      position.quantity,
      distribution,
      market
    );

    return {
      proceeds: base.proceeds,
      averagePrice: base.averagePrice,
      feeAmount: MathUtils.formatUSDC(new Big(0)),
      feeRate: new Big(0),
      feeInfo: {
        policy: FeePolicyKind.Null,
        name: "NullFeePolicy",
      },
    };
  }

  /**
   * Ï£ºÏñ¥ÏßÑ Ï¥ù ÏßÄÏ∂ú(ÏàòÏàòÎ£å Ìè¨Ìï®)ÏúºÎ°ú ÏÇ¥ Ïàò ÏûàÎäî ÏàòÎüâ Í≥ÑÏÇ∞ (Ïó≠ÏÇ∞)
   * @param lowerTick Lower tick bound (inclusive)
   * @param upperTick Upper tick bound (exclusive)
   * @param cost Ï¥ù ÏßÄÏ∂ú ÌïúÎèÑ (ÏàòÏàòÎ£å Ìè¨Ìï®, 6 decimals)
   * @param distribution Current market distribution
   * @param market Market parameters
   * @returns Íµ¨Îß§ Í∞ÄÎä•Ìïú ÏàòÎüâÍ≥º ÏàúÏàò Î≤†ÌåÖ ÎπÑÏö©
   */
  // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
  calculateQuantityFromCost(
    lowerTick: Tick,
    upperTick: Tick,
    cost: USDCAmount,
    distribution: MarketDistribution,
    market: Market,
    includeFees: boolean = true
  ): QuantityFromCostResult {
    const targetSpend = MathUtils.formatUSDC(new Big(cost));

    // 0 ÎòêÎäî ÏùåÏàò ÏûÖÎ†•ÏùÄ Í∏∞Ï°¥ Î°úÏßÅÍ≥º ÎèôÏùºÌïòÍ≤å Ï≤òÎ¶¨
    if (targetSpend.lte(0)) {
      return this._calculateQuantityFromNetCost(
        lowerTick,
        upperTick,
        targetSpend,
        distribution,
        market
      );
    }

    if (!includeFees) {
      return this._calculateQuantityFromNetCost(
        lowerTick,
        upperTick,
        targetSpend,
        distribution,
        market
      );
    }

    const descriptor = market.feePolicyDescriptor?.trim();
    if (!descriptor || descriptor.length === 0) {
      return this._calculateQuantityFromNetCost(
        lowerTick,
        upperTick,
        targetSpend,
        distribution,
        market
      );
    }

    const resolvedPolicy = resolveFeePolicyWithMetadata(descriptor);
    if (
      resolvedPolicy.descriptor?.policy === "null" ||
      resolvedPolicy.policy === NullFeePolicy
    ) {
      return this._calculateQuantityFromNetCost(
        lowerTick,
        upperTick,
        targetSpend,
        distribution,
        market
      );
    }

    const zeroBase = MathUtils.formatUSDC(new Big(0));
    const minSpend = this._computeTotalSpendWithFees(
      zeroBase,
      zeroBase,
      lowerTick,
      upperTick,
      descriptor
    );

    if (targetSpend.lt(minSpend)) {
      throw new ValidationError(
        "Target cost is below the minimum spend achievable after fees"
      );
    }

    let low = new Big(0);
    let high = new Big(targetSpend);

    // ÌçºÏÑºÌä∏ ÏàòÏàòÎ£åÏùò Í≤ΩÏö∞ Ï¥ùÏï°ÏùÑ (1+rate)Î°ú ÎÇòÎà† Ï¥àÍ∏∞ Ï∂îÏ†ïÏπòÎ•º Ïû°ÏïÑ ÏàòÎ†¥ ÏÜçÎèÑ Í∞úÏÑ†
    let initialGuess = new Big(targetSpend);
    if (resolvedPolicy.descriptor?.policy === "percentage") {
      const bps = new Big(resolvedPolicy.descriptor.bps!.toString());
      const rate = bps.div(10_000);
      const onePlusRate = new Big(1).plus(rate);
      initialGuess = targetSpend.div(onePlusRate);
    }

    let netGuess = MathUtils.formatUSDC(initialGuess);
    if (netGuess.lt(0)) {
      netGuess = new Big(0);
    }

    let bestResult = this._calculateQuantityFromNetCost(
      lowerTick,
      upperTick,
      netGuess,
      distribution,
      market
    );
    let bestDiff = this._computeTotalSpendWithFees(
      bestResult.actualCost,
      bestResult.quantity,
      lowerTick,
      upperTick,
      descriptor
    ).minus(targetSpend);

    if (bestDiff.abs().lte(INVERSE_SPEND_TOLERANCE)) {
      return bestResult;
    }

    if (bestDiff.gt(0)) {
      high = new Big(netGuess);
    } else {
      low = new Big(netGuess);
    }

    for (let i = 0; i < MAX_INVERSE_ITERATIONS; i++) {
      const mid = low.plus(high).div(2);
      const midFormatted = MathUtils.formatUSDC(mid);
      const lowFormatted = MathUtils.formatUSDC(low);
      const highFormatted = MathUtils.formatUSDC(high);

      // ÏàòÎ†¥ Ï°∞Í±¥: Îçî Ïù¥ÏÉÅ Î≥ÄÌôîÍ∞Ä ÏóÜÍ±∞ÎÇò ÏûîÏó¨ Íµ¨Í∞ÑÏù¥ tolerance Ïù¥Ìïò
      if (
        midFormatted.eq(lowFormatted) ||
        midFormatted.eq(highFormatted) ||
        high.minus(low).abs().lte(INVERSE_SPEND_TOLERANCE)
      ) {
        const seen = new Set<string>();
        [lowFormatted, highFormatted].forEach((boundary) => {
          const key = boundary.toString();
          if (seen.has(key)) {
            return;
          }
          seen.add(key);

          const boundaryCandidate = this._calculateQuantityFromNetCost(
            lowerTick,
            upperTick,
            boundary,
            distribution,
            market
          );
          const boundaryTotal = this._computeTotalSpendWithFees(
            boundaryCandidate.actualCost,
            boundaryCandidate.quantity,
            lowerTick,
            upperTick,
            descriptor
          );
          const boundaryDiff = boundaryTotal.minus(targetSpend);
          if (boundaryDiff.abs().lt(bestDiff.abs())) {
            bestResult = boundaryCandidate;
            bestDiff = boundaryDiff;
          }
        });
        break;
      }

      const candidate = this._calculateQuantityFromNetCost(
        lowerTick,
        upperTick,
        MathUtils.formatUSDC(midFormatted),
        distribution,
        market
      );
      const totalSpend = this._computeTotalSpendWithFees(
        candidate.actualCost,
        candidate.quantity,
        lowerTick,
        upperTick,
        descriptor
      );
      const diff = totalSpend.minus(targetSpend);

      if (diff.abs().lt(bestDiff.abs())) {
        bestResult = candidate;
        bestDiff = diff;
      }

      if (diff.abs().lte(INVERSE_SPEND_TOLERANCE)) {
        bestResult = candidate;
        break;
      }

      if (diff.gt(0)) {
        high = mid;
      } else {
        low = mid;
      }
    }

    if (bestDiff.abs().gt(INVERSE_SPEND_TOLERANCE)) {
      throw new ValidationError(
        "Target cost cannot be achieved with current fee policy"
      );
    }

    return bestResult;
  }

  private _calculateQuantityFromNetCost(
    lowerTick: Tick,
    upperTick: Tick,
    netCost: USDCAmount,
    distribution: MarketDistribution,
    market: Market
  ): QuantityFromCostResult {
    const costWad = MathUtils.toWad(netCost); // 6‚Üí18 dec Î≥ÄÌôò

    // Convert from input
    const alpha = market.liquidityParameter;

    // Get current state
    const sumBefore = distribution.totalSum;
    const affectedSum = this.getAffectedSum(
      lowerTick,
      upperTick,
      distribution,
      market
    );

    // Direct mathematical inverse:
    // From: C = Œ± * ln(sumAfter / sumBefore)
    // Calculate: q = Œ± * ln(factor)

    // Calculate target sum after: sumAfter = sumBefore * exp(C/Œ±) - safe chunking ÏÇ¨Ïö©
    const expValue = MathUtils.safeExp(costWad, alpha);
    const targetSumAfter = MathUtils.wMul(sumBefore, expValue);

    // Calculate required affected sum after trade
    const requiredAffectedSum = targetSumAfter.minus(
      sumBefore.minus(affectedSum)
    );

    // Calculate factor: newAffectedSum / affectedSum
    if (affectedSum.eq(0)) {
      throw new CalculationError(
        "Cannot calculate quantity from cost: affected sum is zero. This usually means the tick range is outside the market or the distribution data is empty."
      );
    }
    const factor = MathUtils.wDiv(requiredAffectedSum, affectedSum);

    // Calculate quantity: q = Œ± * ln(factor)
    const quantityWad = MathUtils.wMul(alpha, MathUtils.wLn(factor));
    // quantityWadÎäî WAD ÌòïÏãùÏù¥ÎØÄÎ°ú WADÎ•º ÏùºÎ∞ò ÏàòÎ°ú Î≥ÄÌôò ÌõÑ micro USDCÎ°ú Î≥ÄÌôò
    const quantityValue = MathUtils.wadToNumber(quantityWad);
    const quantity = quantityValue.mul(MathUtils.USDC_PRECISION); // ÏùºÎ∞ò ÏàòÎ•º micro USDCÎ°ú Î≥ÄÌôò

    // Ïó≠ÏÇ∞ Í≤∞Í≥º ÏàòÎüâÏù¥ ÏãúÏû• ÌïúÍ≥Ñ ÎÇ¥Ïóê ÏûàÎäîÏßÄ Í≤ÄÏ¶ù (UX Í∞úÏÑ†)
    this._assertQuantityWithinLimit(quantity, market.liquidityParameter);

    // Verify by calculating actual cost
    // Ïä§ÏºÄÏùºÎßÅ Î¨∏Ï†ú ÏàòÏ†ïÏúºÎ°ú Ïù¥Ï†ú ÏïàÏ†ÑÌïòÍ≤å Í≤ÄÏ¶ù Í∞ÄÎä•
    let actualCost: Big;
    try {
      const verification = this.calculateOpenCost(
        lowerTick,
        upperTick,
        quantity,
        distribution,
        market
      );
      actualCost = verification.cost;
    } catch (error) {
      // Îß§Ïö∞ ÌÅ∞ ÏàòÎüâÏù¥ÎÇò Í∑πÎã®Ï†ÅÏù∏ Í≤ΩÏö∞ÏóêÎßå ÏòàÏô∏ Ï≤òÎ¶¨
      // ÏûÖÎ†• ÎπÑÏö©ÏùÑ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
      actualCost = netCost;
      console.warn(
        "calculateQuantityFromCost: verification failed, using target cost as approximation",
        error
      );
    }

    // Calculate fee information for the final result
    const formattedActualCost = MathUtils.formatUSDC(actualCost);
    const formattedQuantity = MathUtils.formatUSDC(quantity);
    
    const feeOverlay = this.computeFeeOverlay(
      "BUY",
      formattedActualCost,
      formattedQuantity,
      lowerTick,
      upperTick,
      market.feePolicyDescriptor
    );

    return {
      quantity: formattedQuantity,
      actualCost: formattedActualCost,
      feeAmount: feeOverlay.amount,
      feeRate: feeOverlay.rate,
      feeInfo: feeOverlay.info,
    };
  }

  private _computeTotalSpendWithFees(
    baseAmount: USDCAmount,
    quantity: USDCAmount,
    lowerTick: Tick,
    upperTick: Tick,
    descriptor: string
  ): USDCAmount {
    const formattedBase = MathUtils.formatUSDC(baseAmount);
    const formattedQuantity = MathUtils.formatUSDC(quantity);

    const feeOverlay = this.computeFeeOverlay(
      "BUY",
      formattedBase,
      formattedQuantity,
      lowerTick,
      upperTick,
      descriptor
    );

    return MathUtils.formatUSDC(formattedBase.plus(feeOverlay.amount));
  }

  /**
   * Ï£ºÏñ¥ÏßÑ Î™©Ìëú ÏàòÏùµ(ÏàòÏàòÎ£å Î∞òÏòÅ)ÏúºÎ°ú ÌïÑÏöîÌïú Îß§ÎèÑ ÏàòÎüâ Ïó≠ÏÇ∞
   * @param position Î≥¥Ïú† Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥
   * @param targetProceeds ÏàòÏàòÎ£å Ï†úÏô∏ ÌõÑ Ïã§Ï†úÎ°ú Î∞õÍ≥† Ïã∂ÏùÄ Í∏àÏï° (6 decimals)
   * @param distribution Current market distribution
   * @param market Market parameters
   * @returns Îß§ÎèÑÌï¥Ïïº Ìï† ÏàòÎüâÍ≥º Í≤ÄÏ¶ùÎêú Ïã§Ï†ú ÏàòÏùµ(ÏàòÏàòÎ£å Ï†úÏô∏ Ï†Ñ Í∏∞Ï§Ä)
   */
  calculateQuantityFromProceeds(
    position: Position,
    targetProceeds: USDCAmount,
    distribution: MarketDistribution,
    market: Market,
    includeFees: boolean = true
  ): QuantityFromProceedsResult {
    this.validateTickRange(position.lowerTick, position.upperTick, market);

    if (!distribution) {
      throw new ValidationError(
        "Distribution data is required but was undefined"
      );
    }

    if (new Big(position.quantity).lte(0)) {
      throw new ValidationError("Position quantity must be positive");
    }

    if (new Big(targetProceeds).lte(0)) {
      throw new ValidationError("Target proceeds must be positive");
    }

    const maxDecrease = this.calculateDecreaseProceeds(
      position,
      position.quantity,
      distribution,
      market
    );

    const targetAmount = MathUtils.formatUSDC(new Big(targetProceeds));
    const maxBaseProceeds = MathUtils.formatUSDC(maxDecrease.proceeds);

    if (!includeFees) {
      if (targetAmount.gt(maxBaseProceeds)) {
        throw new ValidationError(
          "Target proceeds exceed the maximum proceeds available for this position"
        );
      }
      return this._calculateQuantityFromBaseProceeds(
        position,
        targetAmount,
        distribution,
        market
      );
    }

    const descriptor = market.feePolicyDescriptor?.trim();
    const targetNetProceeds = targetAmount;

    if (!descriptor || descriptor.length === 0) {
      if (targetNetProceeds.gt(maxBaseProceeds)) {
        throw new ValidationError(
          "Target proceeds exceed the maximum proceeds available for this position"
        );
      }
      return this._calculateQuantityFromBaseProceeds(
        position,
        targetNetProceeds,
        distribution,
        market
      );
    }

    const maxNetProceeds = MathUtils.formatUSDC(
      maxDecrease.proceeds.minus(maxDecrease.feeAmount)
    );

    if (targetNetProceeds.gt(maxNetProceeds)) {
      throw new ValidationError(
        "Target proceeds exceed the maximum net proceeds available for this position"
      );
    }

    const resolvedPolicy = resolveFeePolicyWithMetadata(descriptor);
    if (
      resolvedPolicy.descriptor?.policy === "null" ||
      resolvedPolicy.policy === NullFeePolicy
    ) {
      return this._calculateQuantityFromBaseProceeds(
        position,
        targetNetProceeds,
        distribution,
        market
      );
    }

    let lowBound = new Big(targetNetProceeds);
    let highBound = new Big(maxBaseProceeds);

    if (lowBound.gt(highBound)) {
      lowBound = new Big(highBound);
    }

    let initialGuess = new Big(targetNetProceeds);
    const parsedDescriptor = resolvedPolicy.descriptor;

    if (parsedDescriptor?.policy === "percentage") {
      const bps = new Big(parsedDescriptor.bps!.toString());
      const rate = bps.div(10_000);
      const denominator = new Big(1).minus(rate);
      if (denominator.gt(0)) {
        const derived = targetNetProceeds.div(denominator);
        if (derived.gt(initialGuess)) {
          initialGuess = derived;
        }
      } else {
        initialGuess = new Big(highBound);
      }
    }

    if (initialGuess.gt(highBound)) {
      initialGuess = new Big(highBound);
    }
    if (initialGuess.lt(lowBound)) {
      initialGuess = new Big(lowBound);
    }

    let baseGuess = MathUtils.formatUSDC(initialGuess);

    let bestResult = this._calculateQuantityFromBaseProceeds(
      position,
      baseGuess,
      distribution,
      market
    );
    let bestNet = this._computeNetProceedsAfterFees(
      bestResult.actualProceeds,
      bestResult.quantity,
      position.lowerTick,
      position.upperTick,
      descriptor
    );
    let bestDiff = bestNet.minus(targetNetProceeds);

    if (bestDiff.abs().lte(INVERSE_SPEND_TOLERANCE)) {
      return bestResult;
    }

    const adjustBounds = (candidateBase: Big, diff: Big) => {
      if (diff.gt(0)) {
        highBound = candidateBase;
      } else {
        lowBound = candidateBase;
      }
    };

    adjustBounds(new Big(bestResult.actualProceeds), bestDiff);

    for (let i = 0; i < MAX_INVERSE_ITERATIONS; i++) {
      const mid = lowBound.plus(highBound).div(2);
      const midFormatted = MathUtils.formatUSDC(mid);
      const lowFormatted = MathUtils.formatUSDC(lowBound);
      const highFormatted = MathUtils.formatUSDC(highBound);

      if (
        midFormatted.eq(lowFormatted) ||
        midFormatted.eq(highFormatted) ||
        highBound.minus(lowBound).abs().lte(INVERSE_SPEND_TOLERANCE)
      ) {
        const seen = new Set<string>();
        [lowFormatted, highFormatted].forEach((boundary) => {
          const key = boundary.toString();
          if (seen.has(key)) {
            return;
          }
          seen.add(key);

          const boundaryCandidate = this._calculateQuantityFromBaseProceeds(
            position,
            boundary,
            distribution,
            market
          );
          const boundaryNet = this._computeNetProceedsAfterFees(
            boundaryCandidate.actualProceeds,
            boundaryCandidate.quantity,
            position.lowerTick,
            position.upperTick,
            descriptor
          );
          const boundaryDiff = boundaryNet.minus(targetNetProceeds);
          if (boundaryDiff.abs().lt(bestDiff.abs())) {
            bestResult = boundaryCandidate;
            bestDiff = boundaryDiff;
          }
        });
        break;
      }

      const candidate = this._calculateQuantityFromBaseProceeds(
        position,
        MathUtils.formatUSDC(midFormatted),
        distribution,
        market
      );
      const candidateNet = this._computeNetProceedsAfterFees(
        candidate.actualProceeds,
        candidate.quantity,
        position.lowerTick,
        position.upperTick,
        descriptor
      );
      const diff = candidateNet.minus(targetNetProceeds);

      if (diff.abs().lt(bestDiff.abs())) {
        bestResult = candidate;
        bestDiff = diff;
      }

      if (diff.abs().lte(INVERSE_SPEND_TOLERANCE)) {
        bestResult = candidate;
        break;
      }

      adjustBounds(new Big(candidate.actualProceeds), diff);
    }

    if (bestDiff.abs().gt(INVERSE_SPEND_TOLERANCE)) {
      throw new ValidationError(
        "Target proceeds cannot be achieved with current fee policy"
      );
    }

    return bestResult;
  }

  // ============================================================================
  // HELPER FUNCTIONS
  // ============================================================================

  /**
   * ÏãúÏû•Î≥Ñ ÏµúÎåÄ ÏàòÎüâ ÌïúÍ≥Ñ Í≤ÄÏ¶ù (Ïª®Ìä∏ÎûôÌä∏ÏôÄ ÎèôÏùºÌïú Ï†úÌïú)
   * @param quantity Í≤ÄÏ¶ùÌï† ÏàòÎüâ (6 decimals)
   * @param alpha Ïú†ÎèôÏÑ± ÌååÎùºÎØ∏ÌÑ∞ Œ± (18 decimals WAD)
   * @throws Error if quantity exceeds market limit
   */
  private _assertQuantityWithinLimit(
    quantity: Quantity,
    alpha: WADAmount
  ): void {
    // maxQty = Œ± √ó MAX_EXP_INPUT_WAD √ó MAX_CHUNKS_PER_TX
    //        = Œ± √ó 1.0 √ó 1000
    // alphaÎäî WAD ÌòïÏãù, ÏßÅÏ†ë Í≥ÑÏÇ∞
    const chunksWad = new Big(MathUtils.MAX_CHUNKS_PER_TX.toString()).mul(
      MathUtils.WAD
    );
    const step1 = MathUtils.wMul(alpha, MathUtils.MAX_EXP_INPUT_WAD);
    const maxQtyWad = MathUtils.wMul(step1, chunksWad);
    // quantityÎäî Ïù¥ÎØ∏ micro-USDC(6 decimals) Ï†ïÏàòÏù¥ÎØÄÎ°ú Î∞îÎ°ú WADÎ°ú Î≥ÄÌôò
    const qtyWad = MathUtils.toWad(quantity);

    if (qtyWad.gt(maxQtyWad)) {
      const maxQtyFormatted = MathUtils.wadToNumber(maxQtyWad);
      throw new ValidationError(
        `Quantity too large. Max per trade = ${maxQtyFormatted.toString()} USDC (market limit: Œ± √ó 1.0 √ó 1000)`
      );
    }
  }

  /**
   * ÎÇ¥Î∂Ä Ìó¨Ìçº: Îß§ÎèÑ ÏàòÏùµ Í≥ÑÏÇ∞ (ÏΩîÎìú Ï§ëÎ≥µ Ï†úÍ±∞)
   * @param lowerTick Lower tick bound (inclusive)
   * @param upperTick Upper tick bound (exclusive)
   * @param sellQuantity Îß§ÎèÑÌï† ÏàòÎüâ
   * @param positionQuantity ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÏàòÎüâ (Í≤ÄÏ¶ùÏö©)
   * @param distribution Current market distribution
   * @param market Market parameters
   * @returns Îß§ÎèÑ ÏàòÏùµ
   */
  // Tick boundary in absolute ticks; internally maps to inclusive bin indices [loBin, hiBin]
  private _calculateQuantityFromBaseProceeds(
    position: Position,
    baseProceeds: USDCAmount,
    distribution: MarketDistribution,
    market: Market
  ): QuantityFromProceedsResult {
    const alpha = market.liquidityParameter;
    const proceedsWad = MathUtils.toWad(baseProceeds);

    const sumBefore = distribution.totalSum;
    const affectedSum = this.getAffectedSum(
      position.lowerTick,
      position.upperTick,
      distribution,
      market
    );

    if (affectedSum.eq(0)) {
      throw new CalculationError(
        "Cannot calculate quantity from proceeds: affected sum is zero. This usually means the tick range is outside the market or the distribution data is empty."
      );
    }

    const expProceeds = MathUtils.safeExp(proceedsWad, alpha);
    const targetSumAfter = MathUtils.wDiv(sumBefore, expProceeds);

    const unaffectedSum = sumBefore.minus(affectedSum);

    if (targetSumAfter.lt(unaffectedSum)) {
      throw new ValidationError(
        "Target proceeds require selling more than the position holds"
      );
    }

    const requiredAffectedSumAfter = targetSumAfter.minus(unaffectedSum);

    if (requiredAffectedSumAfter.lte(0)) {
      throw new ValidationError(
        "Target proceeds would reduce the affected sum to zero or negative"
      );
    }

    if (requiredAffectedSumAfter.gt(affectedSum)) {
      throw new CalculationError(
        "Target proceeds require increasing the affected sum, which is impossible for a sale"
      );
    }

    const inverseFactor = MathUtils.wDiv(requiredAffectedSumAfter, affectedSum);

    if (inverseFactor.lte(0) || inverseFactor.gt(MathUtils.WAD)) {
      throw new CalculationError(
        "Inverse factor out of bounds when calculating sell quantity"
      );
    }

    const factor = MathUtils.wDiv(MathUtils.WAD, inverseFactor);
    const quantityWad = MathUtils.wMul(alpha, MathUtils.wLn(factor));

    const quantityValue = MathUtils.wadToNumber(quantityWad);
    const quantity = quantityValue.mul(MathUtils.USDC_PRECISION);

    this._assertQuantityWithinLimit(quantity, alpha);

    let formattedQuantity = MathUtils.formatUSDC(quantity);

    if (formattedQuantity.gt(position.quantity)) {
      formattedQuantity = MathUtils.formatUSDC(position.quantity);
    }

    let actualProceeds: Big;

    try {
      const verification = this._calcSellProceeds(
        position.lowerTick,
        position.upperTick,
        formattedQuantity,
        position.quantity,
        distribution,
        market
      );
      actualProceeds = verification.proceeds;
    } catch (error) {
      actualProceeds = baseProceeds;
      console.warn(
        "calculateQuantityFromProceeds: verification failed, using target proceeds as approximation",
        error
      );
    }

    // Calculate fee information
    const feeOverlay = this.computeFeeOverlay(
      "SELL",
      actualProceeds,
      formattedQuantity,
      position.lowerTick,
      position.upperTick,
      market.feePolicyDescriptor
    );

    return {
      quantity: formattedQuantity,
      actualProceeds: MathUtils.formatUSDC(actualProceeds),
      feeAmount: feeOverlay.amount,
      feeRate: feeOverlay.rate,
      feeInfo: feeOverlay.info,
    };
  }

  private _calcSellProceeds(
    lowerTick: Tick,
    upperTick: Tick,
    sellQuantity: Quantity,
    positionQuantity: Quantity,
    distribution: MarketDistribution,
    market: Market
  ): { proceeds: USDCAmount; averagePrice: USDCAmount } {
    this.validateTickRange(lowerTick, upperTick, market);

    // Input validation
    if (new Big(sellQuantity).lte(0)) {
      throw new ValidationError("Sell quantity must be positive");
    }

    if (new Big(sellQuantity).gt(positionQuantity)) {
      throw new ValidationError("Cannot sell more than current position");
    }

    // ÏãúÏû•Î≥Ñ ÏµúÎåÄ ÏàòÎüâ Í≤ÄÏ¶ù (UX Í∞úÏÑ†)
    this._assertQuantityWithinLimit(sellQuantity, market.liquidityParameter);

    // Convert to WAD for calculations
    const alpha = market.liquidityParameter;
    const quantityWad = MathUtils.toWad(sellQuantity);

    // Get current state
    const sumBefore = distribution.totalSum;
    const affectedSum = this.getAffectedSum(
      lowerTick,
      upperTick,
      distribution,
      market
    );

    // üéØ Ïª®Ìä∏ÎûôÌä∏ÏôÄ Ï†ïÌôïÌûà ÎèôÏùºÌïú LMSR sell Í≥µÏãù Íµ¨ÌòÑ
    // 1. Calculate inverse factor: exp(-quantity / Œ±) = 1 / exp(quantity / Œ±) - safe chunking ÏÇ¨Ïö©
    const factor = MathUtils.safeExp(quantityWad, alpha);
    const inverseFactor = MathUtils.wDivUp(MathUtils.WAD, factor);

    // 2. Calculate sum after sell
    const sumAfter = sumBefore
      .minus(affectedSum)
      .plus(MathUtils.wMulNearest(affectedSum, inverseFactor));

    // 3. Calculate proceeds: Œ± * ln(sumBefore / sumAfter)
    const ratio = MathUtils.wDivUp(sumBefore, sumAfter);
    const lnRatio = MathUtils.wLn(ratio);
    const proceedsWad = MathUtils.wMul(alpha, lnRatio);

    const proceeds = MathUtils.fromWad(proceedsWad);

    // Calculate average price with proper formatting
    const averagePrice = proceeds.div(sellQuantity);
    const formattedAveragePrice = new Big(
      averagePrice.toFixed(6, Big.roundDown)
    ); // 6ÏûêÎ¶¨ Ï†ïÎ∞ÄÎèÑÎ°ú Ï∂©Î∂Ñ

    return {
      proceeds: MathUtils.formatUSDC(proceeds),
      averagePrice: formattedAveragePrice,
    };
  }

  private _computeNetProceedsAfterFees(
    baseProceeds: USDCAmount,
    quantity: USDCAmount,
    lowerTick: Tick,
    upperTick: Tick,
    descriptor: string
  ): USDCAmount {
    const formattedBase = MathUtils.formatUSDC(baseProceeds);
    const formattedQuantity = MathUtils.formatUSDC(quantity);

    const feeOverlay = this.computeFeeOverlay(
      "SELL",
      formattedBase,
      formattedQuantity,
      lowerTick,
      upperTick,
      descriptor
    );

    return MathUtils.formatUSDC(formattedBase.minus(feeOverlay.amount));
  }

  private computeFeeOverlay(
    side: TradeSide,
    baseAmount: USDCAmount,
    quantity: USDCAmount,
    lowerTick: Tick,
    upperTick: Tick,
    descriptor?: string
  ): { amount: USDCAmount; rate: Big; info: FeeInfo } {
    const makeZeroOverlay = (descriptorString?: string, policyName?: string) => ({
      amount: MathUtils.formatUSDC(new Big(0)),
      rate: new Big(0),
      info: {
        policy: FeePolicyKind.Null,
        ...(descriptorString ? { descriptor: descriptorString } : {}),
        name: policyName ?? "NullFeePolicy",
      },
    });

    if (!descriptor || descriptor.trim().length === 0) {
      return makeZeroOverlay();
    }

    const resolved = resolveFeePolicyWithMetadata(descriptor);
    const baseAmountInt = bigToBigInt(baseAmount);
    const quantityInt = bigToBigInt(quantity);

    const trader = ZERO_ADDRESS;
    const marketId = 0;
    const context = ZERO_CONTEXT;

    const feeBigInt =
      side === "BUY"
        ? quoteOpenFee(resolved.policy, {
            trader,
            marketId,
            lowerTick,
            upperTick,
            quantity6: quantityInt,
            cost6: baseAmountInt,
            context,
          })
        : quoteSellFee(resolved.policy, {
            trader,
            marketId,
            lowerTick,
            upperTick,
            sellQuantity6: quantityInt,
            proceeds6: baseAmountInt,
            context,
          });

    const feeAmount = MathUtils.formatUSDC(new Big(feeBigInt.toString()));
    const parsedDescriptor = resolved.descriptor;
    const descriptorString = parsedDescriptor?.descriptor ?? descriptor;
    const policyName =
      parsedDescriptor?.name ??
      (typeof resolved.policy.name === "string"
        ? resolved.policy.name
        : undefined);

    if (!descriptorString || descriptorString.length === 0) {
      return makeZeroOverlay();
    }

    if (parsedDescriptor?.policy === "null" || resolved.policy === NullFeePolicy) {
      return {
        amount: feeAmount,
        rate: new Big(0),
        info: {
          policy: FeePolicyKind.Null,
          descriptor: descriptorString,
          name: policyName ?? "NullFeePolicy",
        },
      };
    }

    if (parsedDescriptor?.policy === "percentage") {
      const bps = new Big(parsedDescriptor.bps!.toString());
      const rate = bps.div(new Big("10000"));

      return {
        amount: feeAmount,
        rate,
        info: {
          policy: FeePolicyKind.Percentage,
          descriptor: descriptorString,
          name: policyName,
          bps,
        },
      };
    }

    const effectiveRate =
      baseAmount.gt(0) && feeAmount.gt(0)
        ? feeAmount.div(baseAmount)
        : new Big(0);

    return {
      amount: feeAmount,
      rate: effectiveRate,
      info: {
        policy: FeePolicyKind.Custom,
        descriptor: descriptorString,
        name: policyName,
      },
    };
  }

  private validateTickRange(
    lowerTick: Tick,
    upperTick: Tick,
    market: Market
  ): void {
    if (lowerTick >= upperTick) {
      throw new ValidationError("Lower tick must be less than upper tick");
    }

    if (lowerTick < market.minTick || upperTick > market.maxTick) {
      throw new ValidationError("Tick range is out of market bounds");
    }

    if ((lowerTick - market.minTick) % market.tickSpacing !== 0) {
      throw new ValidationError("Lower tick is not aligned to tick spacing");
    }

    if ((upperTick - market.minTick) % market.tickSpacing !== 0) {
      throw new ValidationError("Upper tick is not aligned to tick spacing");
    }
  }

  private getAffectedSum(
    lowerTick: Tick,
    upperTick: Tick,
    distribution: MarketDistribution,
    market: Market
  ): WADAmount {
    // ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
    if (!distribution) {
      throw new ValidationError(
        "Distribution data is required but was undefined"
      );
    }

    if (!distribution.binFactors) {
      throw new ValidationError(
        "binFactors is required but was undefined. Make sure to include 'binFactors' field in your GraphQL query and use mapDistribution() to convert the data."
      );
    }

    if (!Array.isArray(distribution.binFactors)) {
      throw new ValidationError("binFactors must be an array");
    }

    // Ïª®Ìä∏ÎûôÌä∏ÏôÄ ÎèôÏùºÌïú _rangeToBins Î°úÏßÅ ÏÇ¨Ïö©
    const lowerBin = Math.floor(
      (lowerTick - market.minTick) / market.tickSpacing
    );
    const upperBin = Math.floor(
      (upperTick - market.minTick) / market.tickSpacing - 1
    );

    let affectedSum = new Big(0);

    // Ïª®Ìä∏ÎûôÌä∏ÏôÄ ÎèôÏùºÌïòÍ≤å inclusive Î≤îÏúÑÎ°ú Í≥ÑÏÇ∞ (lowerBin <= binIndex <= upperBin)
    for (let binIndex = lowerBin; binIndex <= upperBin; binIndex++) {
      if (binIndex >= 0 && binIndex < distribution.binFactors.length) {
        // Ïù¥ÎØ∏ WAD ÌòïÏãùÏùò Big Í∞ùÏ≤¥Ïù¥ÎØÄÎ°ú ÏßÅÏ†ë ÏÇ¨Ïö©
        affectedSum = affectedSum.plus(distribution.binFactors[binIndex]);
      }
    }

    return affectedSum;
  }
}

// ============================================================================
// CONVENIENCE FUNCTIONS
// ============================================================================

/**
 * Create CLMSR SDK instance
 */
export function createCLMSRSDK(): CLMSRSDK {
  return new CLMSRSDK();
}

```


## clmsr-sdk/src/fees.ts

```typescript
import { BigNumberish, toBigInt as toEthersBigInt } from "ethers";

export type TradeSide = "BUY" | "SELL";

export type Bytes32Like = `0x${string}`;

const ZERO_CONTEXT: Bytes32Like = `0x${"00".repeat(32)}`;

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

function toBigInt(value: BigNumberish): bigint {
  return toEthersBigInt(value);
}

function normalizeContext(context?: Bytes32Like): Bytes32Like {
  return (context ?? ZERO_CONTEXT) as Bytes32Like;
}

function normalizeTrader(trader?: string): string {
  if (!trader) {
    return ZERO_ADDRESS;
  }
  return trader;
}

function normalizeMarketId(marketId?: BigNumberish): bigint {
  if (marketId === undefined || marketId === null) {
    return 0n;
  }
  return toBigInt(marketId);
}

interface FeeQuoteParams {
  trader: string;
  marketId: bigint;
  lowerTick: bigint;
  upperTick: bigint;
  quantity6: bigint;
  baseAmount6: bigint;
  side: TradeSide;
  context: Bytes32Like;
}

export interface FeePolicy {
  quote(params: FeeQuoteParams): bigint;
  name?: string;
}

export const NullFeePolicy: FeePolicy = Object.freeze({
  quote: () => 0n,
  name: "NullFeePolicy",
});

export interface PercentageFeePolicyConfig {
  bps: BigNumberish;
  name?: string;
}

export function createPercentageFeePolicy(
  config: PercentageFeePolicyConfig
): FeePolicy {
  const bps = toBigInt(config.bps);
  const policyName = config.name ?? "PercentageFeePolicy";

  return {
    name: policyName,
    quote: ({ baseAmount6 }) => {
      return (baseAmount6 * bps) / 10_000n;
    },
  };
}

const FeePolicies = Object.freeze({
  Null: NullFeePolicy,
  Percentage: (config: PercentageFeePolicyConfig) =>
    createPercentageFeePolicy(config),
});

export type FeePolicyName = "Null" | "Percentage";

export function getFeePolicy(
  name: "Null"
): FeePolicy;
export function getFeePolicy(
  name: "Percentage",
  config: PercentageFeePolicyConfig
): FeePolicy;
export function getFeePolicy(
  name: FeePolicyName,
  config?: PercentageFeePolicyConfig
): FeePolicy {
  if (name === "Null") {
    return FeePolicies.Null;
  }
  if (name === "Percentage") {
    if (!config) {
      throw new Error("Percentage fee policy requires configuration");
    }
    return createPercentageFeePolicy(config);
  }
  throw new Error(`Unsupported fee policy: ${name as string}`);
}

export interface PreviewOpenFeeArgs {
  trader: string;
  marketId: BigNumberish;
  lowerTick: BigNumberish;
  upperTick: BigNumberish;
  quantity6: BigNumberish;
  cost6: BigNumberish;
  context?: Bytes32Like;
}

export interface PreviewSellFeeArgs {
  trader: string;
  marketId: BigNumberish;
  lowerTick: BigNumberish;
  upperTick: BigNumberish;
  sellQuantity6: BigNumberish;
  proceeds6: BigNumberish;
  context?: Bytes32Like;
}

function buildQuoteParams(
  side: TradeSide,
  args: PreviewOpenFeeArgs | PreviewSellFeeArgs
): FeeQuoteParams {
  return {
    trader: normalizeTrader(args.trader),
    marketId: normalizeMarketId(
      (args as PreviewOpenFeeArgs | PreviewSellFeeArgs).marketId
    ),
    lowerTick: toBigInt(args.lowerTick),
    upperTick: toBigInt(args.upperTick),
    quantity6:
      side === "BUY"
        ? toBigInt((args as PreviewOpenFeeArgs).quantity6)
        : toBigInt((args as PreviewSellFeeArgs).sellQuantity6),
    baseAmount6:
      side === "BUY"
        ? toBigInt((args as PreviewOpenFeeArgs).cost6)
        : toBigInt((args as PreviewSellFeeArgs).proceeds6),
    side,
    context: normalizeContext(args.context),
  };
}

interface ParsedFeePolicyDescriptor {
  policy: "null" | "percentage";
  name?: string;
  bps?: bigint;
  descriptor: string;
}

export interface EncodePercentageFeePolicyDescriptorParams {
  bps: BigNumberish;
  name?: string;
}

function parseBigIntParam(
  value: unknown,
  field: string,
  options?: { required?: boolean }
): bigint | undefined {
  if (value === undefined || value === null) {
    if (options?.required) {
      throw new Error(
        `Missing required parameter '${field}' in fee policy descriptor`
      );
    }
    return undefined;
  }
  try {
    return toBigInt(value as BigNumberish);
  } catch {
    throw new Error(
      `Invalid value for '${field}' in fee policy descriptor: ${value as string}`
    );
  }
}

function parseFeePolicyDescriptor(descriptor: string): ParsedFeePolicyDescriptor {
  let parsed: unknown;
  try {
    parsed = JSON.parse(descriptor);
  } catch (error) {
    throw new Error(
      `Invalid fee policy descriptor: ${descriptor}. ${String(error)}`
    );
  }

  if (typeof parsed !== "object" || parsed === null) {
    throw new Error("Fee policy descriptor must be a JSON object");
  }

  const { policy, params } = parsed as {
    policy?: string;
    params?: Record<string, unknown>;
    name?: string;
  };

  if (!policy || typeof policy !== "string") {
    throw new Error(
      "Fee policy descriptor must include a string 'policy' field"
    );
  }

  const normalizedPolicy = policy.toLowerCase();
  const paramBag = params ?? {};

  if (normalizedPolicy === "null") {
    return {
      policy: "null",
      name:
        typeof paramBag.name === "string"
          ? paramBag.name
          : parsed && typeof (parsed as any).name === "string"
          ? (parsed as any).name
          : undefined,
      descriptor,
    };
  }

  if (normalizedPolicy === "percentage") {
    const bps = parseBigIntParam(paramBag.bps, "bps", {
      required: true,
    })!;
    const name =
      typeof paramBag.name === "string"
        ? paramBag.name
        : typeof (parsed as any).name === "string"
        ? (parsed as any).name
        : undefined;

    return {
      policy: "percentage",
      name,
      bps,
      descriptor,
    };
  }

  throw new Error(`Unsupported fee policy '${policy}' in descriptor`);
}

export interface ResolvedFeePolicy {
  policy: FeePolicy;
  descriptor?: ParsedFeePolicyDescriptor;
}

export function resolveFeePolicyWithMetadata(
  input: FeePolicy | string
): ResolvedFeePolicy {
  if (typeof input !== "string") {
    return { policy: input };
  }

  const parsed = parseFeePolicyDescriptor(input);

  if (parsed.policy === "null") {
    if (parsed.name && parsed.name !== NullFeePolicy.name) {
      return {
        policy: {
          quote: NullFeePolicy.quote,
          name: parsed.name,
        },
        descriptor: parsed,
      };
    }
    return { policy: NullFeePolicy, descriptor: parsed };
  }

  const percentagePolicy = createPercentageFeePolicy({
    bps: parsed.bps!,
    name: parsed.name,
  });

  return {
    policy: percentagePolicy,
    descriptor: parsed,
  };
}

function quoteOpenFee(
  policyInput: FeePolicy | string,
  args: PreviewOpenFeeArgs
): bigint {
  const { policy } = resolveFeePolicyWithMetadata(policyInput);
  return policy.quote(buildQuoteParams("BUY", args));
}

function quoteSellFee(
  policyInput: FeePolicy | string,
  args: PreviewSellFeeArgs
): bigint {
  const { policy } = resolveFeePolicyWithMetadata(policyInput);
  return policy.quote(buildQuoteParams("SELL", args));
}

export function encodePercentageFeePolicyDescriptor(
  params: EncodePercentageFeePolicyDescriptorParams
): string {
  const bps = toBigInt(params.bps);
  if (bps < 0n) {
    throw new Error("Fee bps must be non-negative");
  }

  const descriptor = {
    policy: "percentage",
    params: {
      bps: bps.toString(),
      ...(params.name ? { name: params.name } : {}),
    },
    ...(params.name ? { name: params.name } : {}),
  };

  return JSON.stringify(descriptor);
}

export { quoteOpenFee, quoteSellFee };

```


## clmsr-sdk/src/index.ts

```typescript
/**
 * @signals/clmsr-v0 - CLMSR SDK for TypeScript
 *
 * Ïª®Ìä∏ÎûôÌä∏ Î∑∞Ìï®ÏàòÎì§Í≥º Ïó≠Ìï®Ïàò Ï†úÍ≥µ
 */

// Export main SDK class
export { CLMSRSDK } from "./clmsr-sdk";

// Export types
export {
  // Basic types
  WADAmount,
  USDCAmount,
  Quantity,
  Tick,

  // Raw GraphQL types (Î¨∏ÏûêÏó¥ Í∏∞Î∞ò)
  MarketDistributionRaw,
  MarketRaw,

  // SDK calculation types (Big Í∏∞Î∞ò)
  Market,
  MarketDistribution,
  Position,

  // Data adapters
  mapMarket,
  mapDistribution,

  // Result types
  OpenCostResult,
  IncreaseCostResult,
  DecreaseProceedsResult,
  CloseProceedsResult,
  ClaimResult,
  QuantityFromCostResult,
  QuantityFromProceedsResult,
  PositionValueResult,
  FeeInfo,

  // Errors
  ValidationError,
  CalculationError,
} from "./types";

// Export utility functions
export * as MathUtils from "./utils/math";

// Convenience functions
export { toWAD, toMicroUSDC } from "./clmsr-sdk";

// Version (keep in sync with package.json)
export const VERSION = "1.10.0";

```


## clmsr-sdk/src/types.ts

```typescript
import Big from "big.js";

// ============================================================================
// BASIC TYPES
// ============================================================================

/** WAD format amount (18 decimals) */
export type WADAmount = Big;

/** USDC amount (6 decimals) */
export type USDCAmount = Big;

/** Trade quantity (also 6 decimals like USDC) */
export type Quantity = Big;

/** Tick value (int256) */
export type Tick = number;

// ============================================================================
// RAW GRAPHQL TYPES (Î¨∏ÏûêÏó¥ Í∏∞Î∞ò - Ïù∏Îç±ÏÑúÏóêÏÑú ÏßÅÏ†ë Ïò® Îç∞Ïù¥ÌÑ∞)
// ============================================================================

/** Raw market distribution data from GraphQL (Î¨∏ÏûêÏó¥ ÌòïÌÉú) */
export interface MarketDistributionRaw {
  totalSum: string; // WAD ÌòïÏãù Î¨∏ÏûêÏó¥ (BigInt from GraphQL) - ÌïÑÏàò
  binFactors: string[]; // WAD ÌòïÏãù Î¨∏ÏûêÏó¥ Î∞∞Ïó¥ ["1000000000000000000", ...] - ÌïÑÏàò
  // ÏÑ†ÌÉùÏ†Å ÌïÑÎìúÎì§ (Ï†ïÎ≥¥ÏÑ±, Í≥ÑÏÇ∞Ïóê ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏùå)
  minFactor?: string; // WAD ÌòïÏãù Î¨∏ÏûêÏó¥ (BigInt from GraphQL)
  maxFactor?: string; // WAD ÌòïÏãù Î¨∏ÏûêÏó¥ (BigInt from GraphQL)
  avgFactor?: string; // WAD ÌòïÏãù Î¨∏ÏûêÏó¥ (BigInt from GraphQL)
  totalVolume?: string; // 6 decimals raw USDC (BigInt from GraphQL)
  binVolumes?: string[]; // 6 decimals raw USDC Î¨∏ÏûêÏó¥ Î∞∞Ïó¥ ["1000000", ...]
  tickRanges?: string[]; // Tick range strings: [tick, tick+spacing)
}

/** Raw market data from GraphQL */
export interface MarketRaw {
  liquidityParameter: string; // WAD ÌòïÏãù Î¨∏ÏûêÏó¥
  minTick: number;
  maxTick: number;
  tickSpacing: number;
  feePolicyDescriptor?: string;
  isSettled?: boolean; // ÎßàÏºì Ï†ïÏÇ∞ Ïó¨Î∂Ä
  settlementValue?: string; // Ï†ïÏÇ∞Í∞í (6 decimal) - "115500000"
  settlementTick?: number; // Ï†ïÏÇ∞ Ìã± (Ï†ïÏàò) - 115
}

// ============================================================================
// SDK CALCULATION TYPES (Big Í∏∞Î∞ò - ÏàúÏàò Í≥ÑÏÇ∞Ïö©)
// ============================================================================

/** Market data for SDK calculations (Ïà´Ïûê Í∞ùÏ≤¥Îßå) */
export interface Market {
  liquidityParameter: WADAmount; // Œ± Í∞í
  minTick: Tick;
  maxTick: Tick;
  tickSpacing: Tick;
  feePolicyDescriptor?: string;
  isSettled?: boolean; // ÎßàÏºì Ï†ïÏÇ∞ Ïó¨Î∂Ä
  settlementValue?: USDCAmount; // Ï†ïÏÇ∞Í∞í (6 decimal)
  settlementTick?: Tick; // Ï†ïÏÇ∞ Ìã± (Ï†ïÏàò)
}

/** Market distribution data for SDK calculations (WAD Í∏∞Î∞ò) */
export interface MarketDistribution {
  totalSum: WADAmount; // WAD Í≥ÑÏÇ∞Ïö© Í∞í (18 decimals) - Ïª®Ìä∏ÎûôÌä∏ÏôÄ ÏùºÏπò - ÌïÑÏàò
  binFactors: WADAmount[]; // WAD ÌòïÏãùÏùò bin factor Î∞∞Ïó¥ (18 decimals) - ÌïµÏã¨ Í≥ÑÏÇ∞Ïö© - ÌïÑÏàò
  // ÏÑ†ÌÉùÏ†Å ÌïÑÎìúÎì§ (Ï†ïÎ≥¥ÏÑ±, Í≥ÑÏÇ∞Ïóê ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏùå)
  minFactor?: WADAmount; // ÏµúÏÜå factor Í∞í (WAD, 18 decimals)
  maxFactor?: WADAmount; // ÏµúÎåÄ factor Í∞í (WAD, 18 decimals)
  avgFactor?: WADAmount; // ÌèâÍ∑† factor Í∞í (WAD, 18 decimals)
  totalVolume?: USDCAmount; // Ï†ÑÏ≤¥ Í±∞ÎûòÎüâ (raw 6 decimals) - Ï†ïÎ≥¥ÏÑ±, Í≥ÑÏÇ∞Ïóê ÎØ∏ÏÇ¨Ïö©
  binVolumes?: USDCAmount[]; // bin volume Î∞∞Ïó¥ (raw 6 decimals) - Ï†ïÎ≥¥ÏÑ±, Í≥ÑÏÇ∞Ïóê ÎØ∏ÏÇ¨Ïö©
  tickRanges?: string[]; // Tick range strings: [tick, tick+spacing)
}

/** Position data */
export interface Position {
  lowerTick: Tick;
  upperTick: Tick;
  quantity: Quantity;
}

// ============================================================================
// FEE DETAILS
// ============================================================================

export const FeePolicyKind = {
  Null: "null",
  Percentage: "percentage",
  Custom: "custom",
} as const;

export type FeePolicyKind =
  (typeof FeePolicyKind)[keyof typeof FeePolicyKind];

interface BaseFeeInfo {
  policy: FeePolicyKind;
  descriptor?: string;
  name?: string;
}

interface NullFeeInfo extends BaseFeeInfo {
  policy: typeof FeePolicyKind.Null;
}

interface PercentageFeeInfo extends BaseFeeInfo {
  policy: typeof FeePolicyKind.Percentage;
  bps: Big;
}

interface CustomFeeInfo extends BaseFeeInfo {
  policy: typeof FeePolicyKind.Custom;
}

export type FeeInfo = NullFeeInfo | PercentageFeeInfo | CustomFeeInfo;

// ============================================================================
// DATA ADAPTERS (GraphQL ‚Üî SDK ÌÉÄÏûÖ Î≥ÄÌôò)
// ============================================================================

/**
 * Convert raw GraphQL market data to SDK calculation format
 * @param raw Raw market data from GraphQL
 * @returns Market data for SDK calculations
 */
export function mapMarket(raw: MarketRaw): Market {
  return {
    liquidityParameter: new Big(raw.liquidityParameter),
    minTick: raw.minTick,
    maxTick: raw.maxTick,
    tickSpacing: raw.tickSpacing,
    ...(raw.feePolicyDescriptor !== undefined && {
      feePolicyDescriptor: raw.feePolicyDescriptor,
    }),
    ...(raw.isSettled !== undefined && { isSettled: raw.isSettled }),
    ...(raw.settlementValue !== undefined && {
      settlementValue: new Big(raw.settlementValue),
    }),
    ...(raw.settlementTick !== undefined && {
      settlementTick: raw.settlementTick,
    }),
  };
}

/**
 * Convert raw GraphQL distribution data to SDK calculation format
 * @param raw Raw distribution data from GraphQL
 * @returns Distribution data for SDK calculations
 */

export function mapDistribution(
  raw: MarketDistributionRaw
): MarketDistribution {
  return {
    // ÌïÑÏàò ÌïÑÎìúÎì§
    totalSum: new Big(raw.totalSum),
    binFactors: raw.binFactors.map((s) => new Big(s)),
    // ÏÑ†ÌÉùÏ†Å ÌïÑÎìúÎì§ (Ï†ïÎ≥¥ÏÑ±, Í≥ÑÏÇ∞Ïóê ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏùå)
    ...(raw.minFactor !== undefined && { minFactor: new Big(raw.minFactor) }),
    ...(raw.maxFactor !== undefined && { maxFactor: new Big(raw.maxFactor) }),
    ...(raw.avgFactor !== undefined && { avgFactor: new Big(raw.avgFactor) }),
    ...(raw.totalVolume !== undefined && {
      totalVolume: new Big(raw.totalVolume),
    }),
    ...(raw.binVolumes !== undefined && {
      binVolumes: raw.binVolumes.map((s) => new Big(s)),
    }),
    ...(raw.tickRanges !== undefined && { tickRanges: raw.tickRanges }),
  };
}

// ============================================================================
// CALCULATION RESULTS
// ============================================================================

/** calculateOpenCost Í≤∞Í≥º */
export interface OpenCostResult {
  cost: USDCAmount;
  averagePrice: USDCAmount;
  feeAmount: USDCAmount;
  feeRate: Big;
  feeInfo: FeeInfo;
}

/** calculateIncreaseCost Í≤∞Í≥º */
export interface IncreaseCostResult {
  additionalCost: USDCAmount;
  averagePrice: USDCAmount;
  feeAmount: USDCAmount;
  feeRate: Big;
  feeInfo: FeeInfo;
}

/** calculateDecreaseProceeds Í≤∞Í≥º */
export interface DecreaseProceedsResult {
  proceeds: USDCAmount;
  averagePrice: USDCAmount;
  feeAmount: USDCAmount;
  feeRate: Big;
  feeInfo: FeeInfo;
}

/** calculateCloseProceeds Í≤∞Í≥º */
export interface CloseProceedsResult {
  proceeds: USDCAmount;
  averagePrice: USDCAmount;
  feeAmount: USDCAmount;
  feeRate: Big;
  feeInfo: FeeInfo;
}

/** calculateClaim Í≤∞Í≥º */
export interface ClaimResult {
  payout: USDCAmount;
}

/** calculateQuantityFromCost Í≤∞Í≥º */
export interface QuantityFromCostResult {
  quantity: Quantity;
  actualCost: USDCAmount;
  feeAmount: USDCAmount; // ÏàòÏàòÎ£å Í∏àÏï°
  feeRate: Big; // ÏàòÏàòÎ£åÏú®
  feeInfo: FeeInfo; // ÏàòÏàòÎ£å Ï†ïÏ±Ö Ï†ïÎ≥¥
}

/** calculateQuantityFromProceeds Í≤∞Í≥º (Îß§ÎèÑÏö© Ïó≠Ìï®Ïàò) */
export interface QuantityFromProceedsResult {
  quantity: Quantity; // Îß§ÎèÑÌï† ÏàòÎüâ (ÏñëÏàò)
  actualProceeds: USDCAmount; // ÏàòÏàòÎ£å Ï∞®Í∞ê Ï†Ñ Í∏∞Ï§Ä(base proceeds)
  feeAmount: USDCAmount; // ÏàòÏàòÎ£å Í∏àÏï°
  feeRate: Big; // ÏàòÏàòÎ£åÏú®
  feeInfo: FeeInfo; // ÏàòÏàòÎ£å Ï†ïÏ±Ö Ï†ïÎ≥¥
}

/** calculatePositionValue Í≤∞Í≥º (Ìè¨ÏßÄÏÖò ÌòÑÏû¨ Í∞ÄÏπò Í≥ÑÏÇ∞) */
export interface PositionValueResult {
  currentValue: USDCAmount; // ÌòÑÏû¨ Ìè¨ÏßÄÏÖò Í∞ÄÏπò (Îß§ÎèÑ Ïãú Î∞õÏùÑ Ïàò ÏûàÎäî Í∏àÏï°, ÏàòÏàòÎ£å Ï†úÏô∏)
  unrealizedPnL: USDCAmount; // ÎØ∏Ïã§ÌòÑ ÏÜêÏùµ (currentValue - totalCost)
  averagePrice: USDCAmount; // ÌòÑÏû¨ ÌèâÍ∑† Í∞ÄÍ≤©
  feeAmount: USDCAmount; // Îß§ÎèÑ Ïãú ÏàòÏàòÎ£å
  feeRate: Big; // ÏàòÏàòÎ£åÏú®
  feeInfo: FeeInfo; // ÏàòÏàòÎ£å Ï†ïÏ±Ö Ï†ïÎ≥¥
}

// ============================================================================
// ERRORS
// ============================================================================

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}

export class CalculationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "CalculationError";
  }
}

```


## clmsr-sdk/src/utils/math.ts

```typescript
import Big from "big.js";
import {
  WADAmount,
  USDCAmount,
  ValidationError,
  CalculationError,
} from "../types";

// ============================================================================
// CONSTANTS
// ============================================================================

/** WAD format constant: 1e18 */
export const WAD = new Big("1e18");

/** Scale difference between USDC (6 decimals) and WAD (18 decimals): 1e12 */
export const SCALE_DIFF = new Big("1e12");
export const HALF_SCALE_DIFF = SCALE_DIFF.div(2);

/** USDC precision constant: 1e6 */
export const USDC_PRECISION = new Big("1000000");

/** Maximum safe input for exp() function: 1.0 * 1e18 */
export const MAX_EXP_INPUT_WAD = new Big("1000000000000000000"); // 1.0 * 1e18

/** Maximum number of chunks per transaction */
export const MAX_CHUNKS_PER_TX = 1000;

/** Minimum and maximum factor bounds for segment tree operations */
export const MIN_FACTOR = new Big("0.01e18"); // 1%
export const MAX_FACTOR = new Big("100e18"); // 100x

export const HALF_WAD = WAD.div(2);

// Big.js configuration for precision (optimized for performance)
Big.DP = 30; // 30 decimal places for internal calculations (sufficient for CLMSR precision)
Big.RM = Big.roundHalfUp; // Round half up

// ============================================================================
// SCALING FUNCTIONS
// ============================================================================

/**
 * Convert 6-decimal USDC amount to 18-decimal WAD format
 * @param amt6 Amount in 6-decimal format
 * @returns Amount in WAD format
 */
export function toWad(amt6: USDCAmount): WADAmount {
  return amt6.mul(SCALE_DIFF);
}

/**
 * Convert 18-decimal WAD format to 6-decimal USDC amount (truncates)
 * @param amtWad Amount in WAD format
 * @returns Amount in 6-decimal format
 */
export function fromWad(amtWad: WADAmount): USDCAmount {
  if (amtWad.eq(0)) {
    return new Big(0);
  }

  return amtWad.div(SCALE_DIFF).round(0, Big.roundDown);
}

/**
 * Convert 18-decimal WAD format to 6-decimal USDC amount with round-up
 * Always rounds up to ensure minimum 1 micro unit cost
 * @param amtWad Amount in WAD format
 * @returns Amount in 6-decimal format (rounded up)
 */
export function fromWadRoundUp(amtWad: WADAmount): USDCAmount {
  if (amtWad.eq(0)) {
    return new Big(0);
  }

  const numerator = amtWad.plus(SCALE_DIFF.minus(1));
  return numerator.div(SCALE_DIFF).round(0, Big.roundDown);
}

/**
 * Convert 18-decimal WAD format to 6-decimal USDC amount with nearest rounding (ties up)
 * @param amtWad Amount in WAD format
 * @returns Amount in 6-decimal format (rounded to nearest)
 */
export function fromWadNearest(amtWad: WADAmount): USDCAmount {
  if (amtWad.eq(0)) {
    return new Big(0);
  }

  const shifted = amtWad.plus(HALF_SCALE_DIFF);
  return shifted.div(SCALE_DIFF).round(0, Big.roundDown);
}

/**
 * Convert 18-decimal WAD format to 6-decimal USDC amount with nearest rounding
 * but enforce minimum 1 micro unit when the input is non-zero.
 * @param amtWad Amount in WAD format
 * @returns Amount in 6-decimal format (rounded to nearest, minimum 1 if non-zero)
 */
export function fromWadNearestMin1(amtWad: WADAmount): USDCAmount {
  if (amtWad.eq(0)) {
    return new Big(0);
  }

  const rounded = fromWadNearest(amtWad);
  return rounded.eq(0) ? new Big(1) : rounded;
}

/**
 * Convert WAD format to regular number (divide by 1e18)
 * @param amtWad Amount in WAD format
 * @returns Regular number
 */
export function wadToNumber(amtWad: WADAmount): Big {
  return amtWad.div(WAD);
}

/**
 * Format USDC amount to 6 decimal places maximum
 * @param amount USDC amount (in micro USDC)
 * @returns Formatted amount with max 6 decimals
 */
export function formatUSDC(amount: USDCAmount): USDCAmount {
  // amountÎäî Ïù¥ÎØ∏ micro USDC Îã®ÏúÑÏù¥ÎØÄÎ°ú Ï†ïÏàòÏó¨Ïïº Ìï®
  return new Big(amount.toFixed(0, Big.roundDown));
}

// ============================================================================
// BASIC MATH OPERATIONS
// ============================================================================

/**
 * WAD multiplication: (a * b) / WAD
 * @param a First operand
 * @param b Second operand
 * @returns Product in WAD format
 */
export function wMul(a: WADAmount, b: WADAmount): WADAmount {
  return a.mul(b).div(WAD);
}

/**
 * WAD multiplication with nearest rounding (ties up)
 * Mirrors on-chain wMulNearest helper.
 * @param a First operand
 * @param b Second operand
 * @returns Product in WAD format rounded to nearest
 */
export function wMulNearest(a: WADAmount, b: WADAmount): WADAmount {
  if (a.eq(0) || b.eq(0)) {
    return new Big(0);
  }

  return a.mul(b).plus(HALF_WAD).div(WAD).round(0, Big.roundDown);
}

/**
 * WAD division: (a * WAD) / b
 * @param a Dividend
 * @param b Divisor
 * @returns Quotient in WAD format
 */
export function wDiv(a: WADAmount, b: WADAmount): WADAmount {
  if (b.eq(0)) {
    throw new ValidationError("Division by zero");
  }
  return a.mul(WAD).div(b);
}

/**
 * WAD division with rounding up: ceil((a * WAD) / b)
 * @param a Dividend
 * @param b Divisor
 * @returns Quotient in WAD format rounded up
 */
export function wDivUp(a: WADAmount, b: WADAmount): WADAmount {
  if (b.eq(0)) {
    throw new ValidationError("Division by zero");
  }

  const numerator = a.mul(WAD);
  const baseQuotient = numerator.div(b).round(0, Big.roundDown);

  if (baseQuotient.mul(b).eq(numerator)) {
    return baseQuotient;
  }

  return baseQuotient.plus(1);
}

/**
 * WAD exponentiation: e^x
 * Uses Taylor series expansion for accurate results
 * @param x Exponent in WAD format
 * @returns e^x in WAD format
 */
export function wExp(x: WADAmount): WADAmount {
  if (x.gt(MAX_EXP_INPUT_WAD)) {
    throw new ValidationError(
      `Exponent too large: ${x.toString()}, max: ${MAX_EXP_INPUT_WAD.toString()}`
    );
  }

  // Convert to regular number for Math.exp, then back to Big
  // For high precision, we could implement Taylor series, but Math.exp is sufficient for our use case
  const xNumber = parseFloat(x.div(WAD).toString());
  const result = Math.exp(xNumber);

  return new Big(result.toString()).mul(WAD);
}

/**
 * WAD natural logarithm: ln(x)
 * @param x Input in WAD format (must be > 0)
 * @returns ln(x) in WAD format
 */
export function wLn(x: WADAmount): WADAmount {
  if (x.lte(0)) {
    throw new ValidationError("Logarithm input must be positive");
  }

  // Convert to regular number for Math.log, then back to Big
  const xNumber = parseFloat(x.div(WAD).toString());
  const result = Math.log(xNumber);

  return new Big(result.toString()).mul(WAD);
}

/**
 * WAD square root: ‚àöx
 * @param x Input in WAD format
 * @returns ‚àöx in WAD format
 */
export function wSqrt(x: WADAmount): WADAmount {
  if (x.lt(0)) {
    throw new ValidationError("Square root input must be non-negative");
  }

  // Use Big.js sqrt method
  const xScaled = x.div(WAD);
  const result = xScaled.sqrt();

  return result.mul(WAD);
}

// ============================================================================
// AGGREGATION FUNCTIONS
// ============================================================================

/**
 * Sum of exponentials: Œ£ exp(v_i)
 * @param values Array of values in WAD format
 * @returns Sum of exponentials in WAD format
 */
export function sumExp(values: WADAmount[]): WADAmount {
  if (values.length === 0) {
    throw new ValidationError("Empty array provided to sumExp");
  }

  let sum = new Big(0);

  for (const v of values) {
    const expV = wExp(v);
    sum = sum.plus(expV);
  }

  return sum;
}

/**
 * Logarithm of sum of exponentials: ln(Œ£ exp(v_i))
 * Uses numerical stability techniques (subtract max value)
 * @param values Array of values in WAD format
 * @returns ln(Œ£ exp(v_i)) in WAD format
 */
export function logSumExp(values: WADAmount[]): WADAmount {
  if (values.length === 0) {
    throw new ValidationError("Empty array provided to logSumExp");
  }

  // Find maximum value for numerical stability
  let maxVal = values[0];
  for (let i = 1; i < values.length; i++) {
    if (values[i].gt(maxVal)) {
      maxVal = values[i];
    }
  }

  // Calculate sum of exp(x - max) with proper scaling
  let sumScaled = new Big(0);

  for (const v of values) {
    // Safe subtraction to avoid underflow
    const diff = v.gte(maxVal) ? v.minus(maxVal) : new Big(0);
    const eScaled = wExp(diff);
    sumScaled = sumScaled.plus(eScaled);
  }

  if (sumScaled.eq(0)) {
    throw new CalculationError("Sum scaled to zero in logSumExp");
  }

  return maxVal.plus(wLn(sumScaled));
}

// ============================================================================
// CLMSR-SPECIFIC FUNCTIONS
// ============================================================================

/**
 * Calculate CLMSR price from exponential values
 * Price = exp(q/Œ±) / Œ£ exp(q_i/Œ±)
 * @param expValue Pre-computed exp(q/Œ±) value for this tick
 * @param totalSumExp Sum of all exponentials Œ£ exp(q/Œ±)
 * @returns Normalized price in WAD format
 */
export function clmsrPrice(
  expValue: WADAmount,
  totalSumExp: WADAmount
): WADAmount {
  if (totalSumExp.eq(0)) {
    throw new ValidationError("Total sum of exponentials is zero");
  }

  return wDiv(expValue, totalSumExp);
}

/**
 * Calculate CLMSR cost: Œ± * ln(Œ£_after / Œ£_before)
 * @param alpha Liquidity parameter Œ± in WAD format
 * @param sumBefore Sum of exponentials before trade
 * @param sumAfter Sum of exponentials after trade
 * @returns Trade cost in WAD format (always positive)
 */
export function clmsrCost(
  alpha: WADAmount,
  sumBefore: WADAmount,
  sumAfter: WADAmount
): WADAmount {
  if (sumBefore.eq(0)) {
    throw new ValidationError("Sum before trade is zero");
  }

  const ratio = wDiv(sumAfter, sumBefore);

  if (ratio.lt(WAD)) {
    throw new ValidationError("Ratio < 1 not supported in unsigned version");
  }

  const lnRatio = wLn(ratio);
  return wMul(alpha, lnRatio);
}

/**
 * Calculate CLMSR proceeds (for selling): Œ± * ln(Œ£_before / Œ£_after)
 * @param alpha Liquidity parameter Œ± in WAD format
 * @param sumBefore Sum of exponentials before sell
 * @param sumAfter Sum of exponentials after sell
 * @returns Trade proceeds in WAD format
 */
export function clmsrProceeds(
  alpha: WADAmount,
  sumBefore: WADAmount,
  sumAfter: WADAmount
): WADAmount {
  if (sumBefore.eq(0) || sumAfter.eq(0)) {
    throw new ValidationError("Sum before or after trade is zero");
  }

  if (sumBefore.lte(sumAfter)) {
    return new Big(0); // No proceeds if sum doesn't decrease
  }

  const ratio = wDiv(sumBefore, sumAfter);
  const lnRatio = wLn(ratio);
  return wMul(alpha, lnRatio);
}

// ============================================================================
// SAFE EXPONENTIAL WITH CHUNKING
// ============================================================================

/**
 * Calculate exp(q/Œ±) safely by chunking large values to avoid overflow
 * Equivalent to contract's _safeExp function
 * @param q Quantity in WAD format
 * @param alpha Liquidity parameter in WAD format
 * @returns Result of exp(q/Œ±) in WAD format
 */
export function safeExp(q: WADAmount, alpha: WADAmount): WADAmount {
  if (alpha.eq(0)) {
    throw new ValidationError("Alpha cannot be zero");
  }

  const maxPerChunk = wMul(alpha, MAX_EXP_INPUT_WAD); // Œ± * 1.0
  let result = WAD; // 1.0
  let remaining = new Big(q.toString());

  while (remaining.gt(0)) {
    const chunk = remaining.gt(maxPerChunk) ? maxPerChunk : remaining;
    const factor = wExp(wDiv(chunk, alpha)); // Safe: chunk/Œ± ‚â§ 1.0
    result = wMul(result, factor);
    remaining = remaining.minus(chunk);
  }

  return result;
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Check if a factor is within safe bounds for segment tree operations
 * @param factor Factor to check
 * @returns true if factor is within bounds
 */
export function isFactorSafe(factor: WADAmount): boolean {
  return factor.gte(MIN_FACTOR) && factor.lte(MAX_FACTOR);
}

/**
 * Create a new Big number from string, number, or Big
 * @param value Input value
 * @returns Big number
 */
export function toBig(value: string | number | Big): Big {
  return new Big(value);
}

/**
 * Create WAD amount from numeric value (multiply by 1e18)
 * Use this for converting regular numbers to WAD format
 * @param value Input value in regular units (e.g., 1.5 USDC)
 * @returns WAD amount (18 decimals)
 */
export function toWAD(value: string | number): WADAmount {
  return new Big(value).mul(WAD);
}

/**
 * Create micro-USDC amount from USDC value (multiply by 1e6)
 * Use this for converting user input USDC amounts to SDK format
 * @param value Input value in USDC (e.g., "100" = 100 USDC)
 * @returns USDC amount in 6-decimal format (micro-USDC)
 */
export function toMicroUSDC(value: string | number): USDCAmount {
  return new Big(value).mul(USDC_PRECISION);
}

```


## clmsr-sdk/package.json

```json
{
  "name": "@whworjs7946/clmsr-v0",
  "version": "1.13.0",
  "description": "TypeScript SDK for CLMSR market calculations and utilities",
  "main": "dist/index.js",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src/**/*.ts",
    "format": "prettier --write src/**/*.ts",
    "clean": "rm -rf dist",
    "rebuild": "npm run clean && npm run build"
  },
  "keywords": [
    "clmsr",
    "prediction-markets",
    "lmsr",
    "typescript",
    "defi"
  ],
  "author": "Signals Team",
  "license": "MIT",
  "devDependencies": {
    "@types/big.js": "^6.2.2",
    "@types/jest": "^30.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "ts-jest": "^29.1.0",
    "typedoc": "^0.28.10",
    "typedoc-docusaurus-theme": "^1.4.2",
    "typedoc-plugin-markdown": "^4.8.1",
    "typescript": "^5.0.0"
  },
  "dependencies": {
    "big.js": "^6.2.1",
    "ethers": "^6.14.3"
  },
  "files": [
    "dist"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/signals-protocol/signals-v0.git"
  },
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./package.json": "./package.json"
  }
}

```


## clmsr-sdk/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020"],
    "module": "CommonJS",
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "resolveJsonModule": true,
    "types": ["jest", "node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}

```

## Subgraph Source


## clmsr-subgraph/src/_safeload.ts

```typescript
// src/_safeload.ts
import { log } from "@graphprotocol/graph-ts";
import { Market, UserPosition, BinState } from "../generated/schema";

export function loadMarketOrSkip(id: string, where: string): Market | null {
  const m = Market.load(id);
  if (m == null) {
    log.warning("[{}] Market {} not found. Skip.", [where, id]);
  }
  return m;
}

export function loadPosOrSkip(id: string, where: string): UserPosition | null {
  const p = UserPosition.load(id);
  if (p == null) {
    log.warning("[{}] UserPosition {} not found. Skip.", [where, id]);
  }
  return p;
}

export function loadBinOrSkip(id: string, where: string): BinState | null {
  const b = BinState.load(id);
  if (b == null) {
    log.warning("[{}] BinState {} not found. Continue.", [where, id]);
  }
  return b;
}

```


## clmsr-subgraph/src/clmsr-market-core.ts

```typescript
import {
  BigInt,
  BigDecimal,
  Bytes,
  Address,
  dataSource,
  log,
} from "@graphprotocol/graph-ts";
import { loadMarketOrSkip, loadPosOrSkip, loadBinOrSkip } from "./_safeload";
import { wad, zero, one } from "./constants";
import { computeRangeFactorCorrection } from "./range-factor-correction";
import {
  checkActivityLimit,
  calcActivityPoints,
  calcPerformancePoints,
  calcRiskBonusPoints,
  addActivityPoints,
  addPerformancePoints,
  addRiskBonusPoints,
} from "./points";
import {
  PositionOpened as PositionOpenedEvent,
  PositionIncreased as PositionIncreasedEvent,
  PositionDecreased as PositionDecreasedEvent,
  PositionClosed as PositionClosedEvent,
  PositionClaimed as PositionClaimedEvent,
  MarketReopened as MarketReopenedEvent,
  PositionSettled as PositionSettledEvent,
  MarketCreated as MarketCreatedEvent,
  MarketSettled as MarketSettledEvent,
  MarketSettlementValueSubmitted as MarketSettlementValueSubmittedEvent,
  MarketTimingUpdated as MarketTimingUpdatedEvent,
  SettlementTimestampUpdated as SettlementTimestampUpdatedEvent,
  RangeFactorApplied as RangeFactorAppliedEvent,
  MarketActivationUpdated as MarketActivationUpdatedEvent,
  MarketFeePolicySet as MarketFeePolicySetEvent,
  TradeFeeCharged as TradeFeeChargedEvent,
} from "../generated/CLMSRMarketCore/CLMSRMarketCore";

import {
  Market,
  UserPosition,
  Trade,
  UserStats,
  MarketStats,
  BinState,
} from "../generated/schema";
import { ICLMSRFeePolicy } from "../generated/CLMSRMarketCore/ICLMSRFeePolicy";

// ============= ID HELPER FUNCTIONS =============

/**
 * Í≥µÌÜµ ID ÏÉùÏÑ± Ìó¨Ìçº Ìï®Ïàò
 */
export function buildId(raw: BigInt): string {
  return raw.toString();
}

/**
 * MarketId Í∏∞Î∞ò ID ÏÉùÏÑ± (Market, MarketStats Ïö©)
 */
export function buildMarketId(marketId: BigInt): string {
  return buildId(marketId);
}

/**
 * PositionId Í∏∞Î∞ò ID ÏÉùÏÑ± (UserPosition Ïö©)
 */
export function buildPositionId(positionId: BigInt): string {
  return buildId(positionId);
}

/**
 * BinState ID ÏÉùÏÑ± (marketId-binIndex ÌòïÏãù)
 */
export function buildBinStateId(marketId: BigInt, binIndex: i32): string {
  let marketIdStr = buildMarketId(marketId);
  return marketIdStr + "-" + binIndex.toString();
}

/**
 * Market ID Î¨∏ÏûêÏó¥ÏóêÏÑú raw BigInt Ï∂îÏ∂ú
 */
export function extractRawMarketId(marketIdStr: string): BigInt {
  return BigInt.fromString(marketIdStr);
}

export function getOrCreateUserStats(userAddress: Bytes): UserStats {
  let userStats = UserStats.load(userAddress);

  if (userStats == null) {
    userStats = new UserStats(userAddress);
    userStats.user = userAddress;
    userStats.totalTrades = BigInt.fromI32(0);
    userStats.totalVolume = BigInt.fromI32(0);
    userStats.totalCosts = BigInt.fromI32(0);
    userStats.totalProceeds = BigInt.fromI32(0);
    userStats.totalRealizedPnL = BigInt.fromI32(0);
    userStats.totalGasFees = BigInt.fromI32(0);
    userStats.totalFeesPaid = BigInt.fromI32(0);
    userStats.netPnL = BigInt.fromI32(0);
    userStats.activePositionsCount = BigInt.fromI32(0);
    userStats.winningTrades = BigInt.fromI32(0);
    userStats.losingTrades = BigInt.fromI32(0);
    userStats.winRate = BigDecimal.fromString("0");
    userStats.avgTradeSize = BigInt.fromI32(0);
    userStats.firstTradeAt = BigInt.fromI32(0);
    userStats.lastTradeAt = BigInt.fromI32(0);
    userStats.totalPoints = BigInt.fromI32(0);
    userStats.activityPoints = BigInt.fromI32(0);
    userStats.performancePoints = BigInt.fromI32(0);
    userStats.riskBonusPoints = BigInt.fromI32(0);
    userStats.activityPointsToday = BigInt.fromI32(0); // ÏÉà ÌïÑÎìú Ï¥àÍ∏∞Ìôî
    userStats.lastActivityDay = BigInt.fromI32(0); // ÏÉà ÌïÑÎìú Ï¥àÍ∏∞Ìôî
    userStats.save();
  }

  return userStats;
}

function getOrCreateMarketStats(marketId: string): MarketStats {
  let marketStats = MarketStats.load(marketId);

  if (marketStats == null) {
    marketStats = new MarketStats(marketId);
    marketStats.market = marketId;
    marketStats.totalVolume = BigInt.fromI32(0);
    marketStats.totalTrades = BigInt.fromI32(0);
    marketStats.totalFees = BigInt.fromI32(0);
    marketStats.highestPrice = BigInt.fromI32(0);
    marketStats.lowestPrice = BigInt.fromString("999999999999999"); // Very high initial value
    marketStats.currentPrice = BigInt.fromI32(0);
    marketStats.priceChange24h = BigDecimal.fromString("0");
    marketStats.volume24h = BigInt.fromI32(0);
    marketStats.lastUpdated = BigInt.fromI32(0);

    // PnL ÌïÑÎìú Ï¥àÍ∏∞Ìôî
    marketStats.totalBetReceived = BigInt.fromI32(0);
    marketStats.totalBetPaidOut = BigInt.fromI32(0);
    marketStats.bettingNetIncome = BigInt.fromI32(0);
    marketStats.totalSettlementPayout = BigInt.fromI32(0);
    marketStats.totalClaimedPayout = BigInt.fromI32(0);
    marketStats.unclaimedPayout = BigInt.fromI32(0);
    marketStats.totalMarketPnL = BigInt.fromI32(0);
    marketStats.realizedMarketPnL = BigInt.fromI32(0);

    marketStats.save(); // B-1 fix: save new entity immediately
  }

  return marketStats;
}

// Helper function to calculate raw price (cost * 1e6 / quantity)
function calculateRawPrice(cost: BigInt, quantity: BigInt): BigInt {
  if (quantity.equals(BigInt.fromI32(0))) {
    return BigInt.fromI32(0);
  }
  // Calculate price as (cost * 1e6) / quantity to maintain 6 decimal precision
  return cost.times(BigInt.fromString("1000000")).div(quantity);
}

// Helper function to update market PnL calculations
function updateMarketPnL(marketStats: MarketStats): void {
  // Î≤†ÌåÖ Îã®Í≥Ñ ÏàúÏàòÏùµ = Î∞õÏùÄ Í∏àÏï° - ÏßÄÍ∏âÌïú Í∏àÏï°
  marketStats.bettingNetIncome = marketStats.totalBetReceived.minus(
    marketStats.totalBetPaidOut
  );

  // ÏïÑÏßÅ Ï≤≠Íµ¨ÎêòÏßÄ ÏïäÏùÄ Í∏àÏï° = Ï†ïÏÇ∞ ÏòàÏ†ï Í∏àÏï° - Ïã§Ï†ú Ï≤≠Íµ¨Îêú Í∏àÏï°
  marketStats.unclaimedPayout = marketStats.totalSettlementPayout.minus(
    marketStats.totalClaimedPayout
  );

  // Ï†ÑÏ≤¥ ÎßàÏºì ÏÜêÏùµ = Î≤†ÌåÖ ÏàúÏàòÏùµ - Ï†ïÏÇ∞ ÏòàÏ†ï Í∏àÏï° (ÏµúÏ¢Ö ÏòàÏÉÅ ÏÜêÏùµ)
  marketStats.totalMarketPnL = marketStats.bettingNetIncome.minus(
    marketStats.totalSettlementPayout
  );

  // Ïã§ÌòÑÎêú ÎßàÏºì ÏÜêÏùµ = Î≤†ÌåÖ ÏàúÏàòÏùµ - Ïã§Ï†ú Ï≤≠Íµ¨Îêú Í∏àÏï° (ÌòÑÏû¨ÍπåÏßÄ Ïã§ÌòÑÎêú ÏÜêÏùµ)
  marketStats.realizedMarketPnL = marketStats.bettingNetIncome.minus(
    marketStats.totalClaimedPayout
  );
}

// Helper function to calculate BigDecimal price for display
function calculateDisplayPrice(cost: BigInt, quantity: BigInt): BigDecimal {
  if (quantity.equals(BigInt.fromI32(0))) {
    return BigDecimal.fromString("0");
  }
  let costDecimal = cost.toBigDecimal().div(BigDecimal.fromString("1000000"));
  let quantityDecimal = quantity
    .toBigDecimal()
    .div(BigDecimal.fromString("1000000"));
  return costDecimal.div(quantityDecimal);
}

// ============= Í∏∞Ï°¥ Ìó¨Ìçº Ìï®ÏàòÎì§ =============

// Helper function to update bin volumes for given tick range
function updateBinVolumes(
  marketId: BigInt,
  lowerTick: BigInt,
  upperTick: BigInt,
  volume: BigInt
): void {
  let market = loadMarketOrSkip(buildMarketId(marketId), "updateBinVolumes");
  if (market == null) return;

  // B-6 fix: Convert tick range to bin indices with overflow protection
  let lowerBinBigInt = lowerTick.minus(market.minTick).div(market.tickSpacing);
  let upperBinBigInt = upperTick
    .minus(market.minTick)
    .div(market.tickSpacing)
    .minus(BigInt.fromI32(1));

  // Check for potential overflow before casting to i32
  let maxSafeI32 = BigInt.fromI32(2147483647); // MAX_INT32
  if (lowerBinBigInt.gt(maxSafeI32)) lowerBinBigInt = maxSafeI32;
  if (upperBinBigInt.gt(maxSafeI32)) upperBinBigInt = maxSafeI32;
  if (lowerBinBigInt.lt(BigInt.fromI32(0))) lowerBinBigInt = BigInt.fromI32(0);
  if (upperBinBigInt.lt(BigInt.fromI32(0))) upperBinBigInt = BigInt.fromI32(0);

  let lowerBinIndex = lowerBinBigInt.toI32();
  let upperBinIndex = upperBinBigInt.toI32();

  // Safety check: limit bin index range
  let maxBinIndex = market.numBins.toI32() - 1;
  if (lowerBinIndex < 0) lowerBinIndex = 0;
  if (lowerBinIndex > maxBinIndex) lowerBinIndex = maxBinIndex;
  if (upperBinIndex < 0) upperBinIndex = 0;
  if (upperBinIndex > maxBinIndex) upperBinIndex = maxBinIndex;

  // Update each affected bin's volume
  for (let binIndex = lowerBinIndex; binIndex <= upperBinIndex; binIndex++) {
    let binStateId = buildBinStateId(marketId, binIndex);
    let binState = loadBinOrSkip(binStateId, "updateBinVolumes");
    if (binState == null) {
      // get-or-create: create missing BinState with defaults
      let lowerTickBin = market.minTick.plus(
        BigInt.fromI32(binIndex).times(market.tickSpacing)
      );
      let upperTickBin = lowerTickBin.plus(market.tickSpacing);
      binState = new BinState(binStateId);
      binState.market = buildMarketId(marketId);
      binState.binIndex = BigInt.fromI32(binIndex);
      binState.lowerTick = lowerTickBin;
      binState.upperTick = upperTickBin;
      binState.currentFactor = BigInt.fromString("1000000000000000000");
      binState.lastUpdated = market.lastUpdated;
      binState.updateCount = BigInt.fromI32(0);
      binState.totalVolume = BigInt.fromI32(0);
    }
    binState.totalVolume = binState.totalVolume.plus(volume);
    binState.save();
  }

  // MarketDistribution Ï†úÍ±∞Î°ú ÏÑ±Îä• ÏµúÏ†ÅÌôî - BinStateÎßå ÏóÖÎç∞Ïù¥Ìä∏
}

export function handleMarketCreated(event: MarketCreatedEvent): void {
  let marketIdStr = buildMarketId(event.params.marketId);
  let market = new Market(marketIdStr);
  market.marketId = event.params.marketId;
  market.minTick = event.params.minTick;
  market.maxTick = event.params.maxTick;
  market.tickSpacing = event.params.tickSpacing;
  market.startTimestamp = event.params.startTimestamp;
  market.endTimestamp = event.params.endTimestamp;
  market.settlementTimestamp = event.params.endTimestamp; // fallback for legacy compatibility
  market.numBins = event.params.numBins;
  market.liquidityParameter = event.params.liquidityParameter;
  market.isActive = false;
  market.isSettled = false;
  market.settlementValue = null;
  market.settlementTick = null;
  market.lastUpdated = event.block.timestamp;
  market.feePolicyAddress = Bytes.fromHexString(
    "0x0000000000000000000000000000000000000000"
  ) as Bytes;
  market.feePolicyDescriptor = null;
  market.save();

  let marketStats = getOrCreateMarketStats(marketIdStr);
  marketStats.lastUpdated = event.block.timestamp;
  marketStats.save();

  // Î∞∞Ïó¥ Ï†úÍ±∞Î°ú ÏÑ±Îä• ÏµúÏ†ÅÌôî - BinStateÎßå ÏÉùÏÑ±
  for (let binIndex = 0; binIndex < event.params.numBins.toI32(); binIndex++) {
    let lowerTick = event.params.minTick.plus(
      BigInt.fromI32(binIndex).times(event.params.tickSpacing)
    );
    let upperTick = lowerTick.plus(event.params.tickSpacing);

    let binId = buildBinStateId(event.params.marketId, binIndex);
    let binState = new BinState(binId);
    binState.market = market.id;
    binState.binIndex = BigInt.fromI32(binIndex);
    binState.lowerTick = lowerTick;
    binState.upperTick = upperTick;
    binState.currentFactor = BigInt.fromString("1000000000000000000");
    binState.lastUpdated = event.block.timestamp;
    binState.updateCount = BigInt.fromI32(0);
    binState.totalVolume = BigInt.fromI32(0);
    binState.save();
  }

  // MarketDistribution Ï†úÍ±∞Î°ú ÏÑ±Îä• ÏµúÏ†ÅÌôî - BinStateÎßå ÏÉùÏÑ±
}

export function handleMarketSettled(event: MarketSettledEvent): void {
  const marketId = buildMarketId(event.params.marketId);
  const market = loadMarketOrSkip(marketId, "handleMarketSettled");
  if (market == null) return;
  market.isSettled = true;
  market.isActive = false;
  market.settlementTick = event.params.settlementTick;
  // Calculate settlementValue by appending 6 zeros (multiply by 1,000,000)
  market.settlementValue = event.params.settlementTick.times(
    BigInt.fromI32(1000000)
  );
  market.lastUpdated = event.block.timestamp;
  market.save();
}

export function handleMarketSettlementValueSubmitted(
  event: MarketSettlementValueSubmittedEvent
): void {
  const market = loadMarketOrSkip(
    buildMarketId(event.params.marketId),
    "handleMarketSettlementValueSubmitted"
  );
  if (market == null) return;
  market.settlementValue = event.params.settlementValue;
  market.lastUpdated = event.block.timestamp;
  market.save();
}

export function handleMarketTimingUpdated(
  event: MarketTimingUpdatedEvent
): void {
  const market = loadMarketOrSkip(
    buildMarketId(event.params.marketId),
    "handleMarketTimingUpdated"
  );
  if (market == null) return;
  market.startTimestamp = event.params.newStartTimestamp;
  market.endTimestamp = event.params.newEndTimestamp;
  market.lastUpdated = event.block.timestamp;
  market.save();
}

export function handleSettlementTimestampUpdated(
  event: SettlementTimestampUpdatedEvent
): void {
  const market = loadMarketOrSkip(
    buildMarketId(event.params.marketId),
    "handleSettlementTimestampUpdated"
  );
  if (market == null) return;
  market.settlementTimestamp = event.params.settlementTimestamp;
  market.lastUpdated = event.block.timestamp;
  market.save();
}

export function handleMarketReopened(event: MarketReopenedEvent): void {
  const market = loadMarketOrSkip(
    buildMarketId(event.params.marketId),
    "handleMarketReopened"
  );
  if (market == null) return;
  // Ïû¨Ïò§Ìîà Ïãú Ï†ïÏÇ∞ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî Î∞è ÌôúÏÑ±Ìôî
  market.isSettled = false;
  market.isActive = true;
  market.settlementTick = null;
  market.settlementValue = null;
  market.lastUpdated = event.block.timestamp;
  market.save();

  // MarketStatsÎäî Íµ¨Ï°∞ ÏûêÏ≤¥Î•º Ï¥àÍ∏∞ÌôîÌï† ÌïÑÏöî ÏóÜÏùå. lastUpdatedÎßå Í∞±Ïã†
  const stats = getOrCreateMarketStats(market.id);
  stats.lastUpdated = event.block.timestamp;
  stats.save();
}

export function handleMarketActivationUpdated(
  event: MarketActivationUpdatedEvent
): void {
  const market = loadMarketOrSkip(
    buildMarketId(event.params.marketId),
    "handleMarketActivationUpdated"
  );
  if (market == null) return;
  market.isActive = event.params.isActive;
  market.lastUpdated = event.block.timestamp;
  market.save();

  const stats = getOrCreateMarketStats(market.id);
  stats.lastUpdated = event.block.timestamp;
  stats.save();
}

export function handleMarketFeePolicySet(event: MarketFeePolicySetEvent): void {
  const marketId = buildMarketId(event.params.marketId);
  const market = loadMarketOrSkip(marketId, "handleMarketFeePolicySet");
  if (market == null) return;
  const newPolicy = event.params.newPolicy;
  market.feePolicyAddress = newPolicy;

  // ÏÑ±Îä• ÏµúÏ†ÅÌôî: RPC Ìò∏Ï∂ú Ï†úÍ±∞ - descriptorÎäî ÌïÑÏöîÏãú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú Ï°∞Ìöå
  // RPC Ìò∏Ï∂úÏùÄ Ïù∏Îç±Ïã± ÏÜçÎèÑÎ•º ÌÅ¨Í≤å Ï†ÄÌïòÏãúÌÇ¥
  market.feePolicyDescriptor = null;

  market.lastUpdated = event.block.timestamp;
  market.save();

  const stats = getOrCreateMarketStats(marketId);
  stats.lastUpdated = event.block.timestamp;
  stats.save();
}

export function handleTradeFeeCharged(event: TradeFeeChargedEvent): void {
  const marketIdStr = buildMarketId(event.params.marketId);
  const logIndex = event.logIndex.toI32();
  let matched = false;

  // Search backwards for a matching trade within the same tx
  for (let offset = 1; offset <= 16 && logIndex - offset >= 0; offset++) {
    let candidateId = event.transaction.hash.concatI32(logIndex - offset);
    let trade = Trade.load(candidateId);
    if (trade == null) {
      continue;
    }

    if (trade.market != marketIdStr) {
      continue;
    }
    if (!trade.positionId.equals(event.params.positionId)) {
      continue;
    }
    if (!trade.feeAmount.equals(BigInt.fromI32(0))) {
      continue;
    }

    let isMatchingType = event.params.isBuy
      ? trade.type == "OPEN" || trade.type == "INCREASE"
      : trade.type == "DECREASE" || trade.type == "CLOSE";

    if (!isMatchingType) {
      continue;
    }

    trade.feeAmount = event.params.feeAmount;
    trade.feePolicyAddress = event.params.policy;
    trade.save();

    let userPosition = UserPosition.load(trade.userPosition);
    if (userPosition != null) {
      userPosition.totalFeesPaid = userPosition.totalFeesPaid.plus(
        event.params.feeAmount
      );
      userPosition.save();

      let userStats = getOrCreateUserStats(userPosition.user);
      userStats.totalFeesPaid = userStats.totalFeesPaid.plus(
        event.params.feeAmount
      );
      userStats.save();
    }

    matched = true;
    break;
  }

  if (!matched) {
    log.warning(
      "[handleTradeFeeCharged] Matching trade not found for tx {} log {}",
      [event.transaction.hash.toHex(), event.logIndex.toString()]
    );
  }

  let marketStats = getOrCreateMarketStats(marketIdStr);
  marketStats.totalFees = marketStats.totalFees.plus(event.params.feeAmount);
  marketStats.lastUpdated = event.block.timestamp;
  marketStats.save();
}

function applySettlementOnce(
  positionId: BigInt,
  trader: Bytes,
  payout: BigInt,
  ts: BigInt,
  txHash: Bytes,
  logIndex: BigInt
): void {
  const userPosition = loadPosOrSkip(
    buildPositionId(positionId),
    "applySettlementOnce"
  );
  if (userPosition == null) return;
  if (userPosition.outcome != "OPEN") return;

  userPosition.outcome = payout.gt(BigInt.fromI32(0)) ? "WIN" : "LOSS";
  userPosition.totalProceeds = userPosition.totalProceeds.plus(payout);
  // realizedPnL = totalProceeds - totalCosts
  let calculatedPnL = userPosition.totalProceeds.minus(userPosition.totalCosts);
  userPosition.realizedPnL = calculatedPnL;
  userPosition.isClaimed = false;
  userPosition.lastUpdated = ts;

  let holdingSeconds = ts.minus(userPosition.weightedEntryTime);
  let userRange = userPosition.upperTick.minus(userPosition.lowerTick);
  let market = loadMarketOrSkip(userPosition.market, "applySettlementOnce");
  if (market == null) return;
  let marketRange = market.maxTick.minus(market.minTick);

  let userStats = getOrCreateUserStats(trader);
  let performancePt = calcPerformancePoints(calculatedPnL);
  if (performancePt.gt(BigInt.fromI32(0)))
    addPerformancePoints(userStats, performancePt);

  let riskBonusPt = calcRiskBonusPoints(
    userPosition.activityRemaining,
    userRange,
    marketRange,
    holdingSeconds
  );
  if (riskBonusPt.gt(BigInt.fromI32(0)))
    addRiskBonusPoints(userStats, riskBonusPt);

  userPosition.activityRemaining = BigInt.fromI32(0);
  userPosition.weightedEntryTime = BigInt.fromI32(0);
  userPosition.save();

  userStats.totalRealizedPnL = userStats.totalRealizedPnL.plus(calculatedPnL);
  if (payout.gt(BigInt.fromI32(0))) {
    userStats.winningTrades = userStats.winningTrades.plus(BigInt.fromI32(1));
  } else {
    userStats.losingTrades = userStats.losingTrades.plus(BigInt.fromI32(1));
  }
  userStats.save();

  let trade = new Trade(txHash.concatI32(logIndex.toI32()));
  trade.userPosition = userPosition.id;
  trade.user = trader;
  trade.market = userPosition.market;
  trade.positionId = positionId;
  trade.type = "SETTLE";
  trade.lowerTick = userPosition.lowerTick;
  trade.upperTick = userPosition.upperTick;
  trade.quantity = BigInt.fromI32(0);
  trade.costOrProceeds = payout;
  trade.price = BigInt.fromI32(0);
  trade.gasUsed = BigInt.fromI32(0);
  trade.gasPrice = BigInt.fromI32(0);
  trade.timestamp = ts;
  trade.blockNumber = BigInt.fromI32(0);
  trade.transactionHash = txHash;
  trade.feeAmount = BigInt.fromI32(0);
  trade.feePolicyAddress = Address.zero();
  trade.activityPt = BigInt.fromI32(0);
  trade.performancePt = performancePt;
  trade.riskBonusPt = riskBonusPt;
  trade.save();

  let marketStats = getOrCreateMarketStats(userPosition.market);
  marketStats.totalSettlementPayout =
    marketStats.totalSettlementPayout.plus(payout);
  updateMarketPnL(marketStats);
  marketStats.lastUpdated = ts;
  marketStats.save();
}

export function handlePositionSettled(event: PositionSettledEvent): void {
  applySettlementOnce(
    event.params.positionId,
    event.params.trader,
    event.params.payout,
    event.block.timestamp,
    event.transaction.hash,
    event.logIndex
  );
}

export function handlePositionClaimed(event: PositionClaimedEvent): void {
  // Î≥¥Í∞ï: Í≥ºÍ±∞ "ÌÅ¥Î†àÏûÑÎßå ÏûàÍ≥† Ï†ïÏÇ∞ Ïù¥Î≤§Ìä∏Í∞Ä ÏóÜÎçò" ÏºÄÏù¥Ïä§ÎèÑ Î≥µÍµ¨
  const current = loadPosOrSkip(
    buildPositionId(event.params.positionId),
    "handlePositionClaimed"
  );
  if (current == null) return;
  if (current.outcome == "OPEN") {
    applySettlementOnce(
      event.params.positionId,
      event.params.trader,
      event.params.payout,
      event.block.timestamp,
      event.transaction.hash,
      event.logIndex
    );
  }
  // Reload to avoid overwriting settlement fields updated above
  const updated = loadPosOrSkip(
    buildPositionId(event.params.positionId),
    "handlePositionClaimed:reload"
  );
  if (updated == null) return;
  updated.isClaimed = true;
  updated.lastUpdated = event.block.timestamp;
  updated.save();

  // ÎßàÏºì PnL ÏóÖÎç∞Ïù¥Ìä∏ - PositionClaimedÏóêÏÑú Ïã§Ï†ú Ï≤≠Íµ¨Îêú Í∏àÏï° Ï∂îÍ∞Ä
  let marketStats = getOrCreateMarketStats(updated.market);
  marketStats.totalClaimedPayout = marketStats.totalClaimedPayout.plus(
    event.params.payout
  );
  updateMarketPnL(marketStats);
  marketStats.lastUpdated = event.block.timestamp;
  marketStats.save();
}

export function handlePositionClosed(event: PositionClosedEvent): void {
  const userPosition = loadPosOrSkip(
    buildPositionId(event.params.positionId),
    "handlePositionClosed"
  );
  if (userPosition == null) return;
  let closedQuantity = userPosition.currentQuantity;
  let tradeRealizedPnL = event.params.proceeds.minus(userPosition.currentCost);

  userPosition.currentQuantity = BigInt.fromI32(0);
  userPosition.totalQuantitySold =
    userPosition.totalQuantitySold.plus(closedQuantity);
  userPosition.totalProceeds = userPosition.totalProceeds.plus(
    event.params.proceeds
  );
  // Store values before resetting for risk calculation
  let originalActivityRemaining = userPosition.activityRemaining;
  let originalWeightedEntryTime = userPosition.weightedEntryTime;

  // totalCostsÎäî Ïú†ÏßÄ (Ï†àÎåÄ Î≥ÄÍ≤Ω Ïïà Ìï®)
  userPosition.currentCost = BigInt.fromI32(0); // ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÎπÑÏö© 0ÏúºÎ°ú Î¶¨ÏÖã
  // realizedPnL = totalProceeds - totalCosts
  userPosition.realizedPnL = userPosition.totalProceeds.minus(
    userPosition.totalCosts
  );
  userPosition.outcome = "CLOSED";
  userPosition.activityRemaining = BigInt.fromI32(0);
  userPosition.weightedEntryTime = BigInt.fromI32(0);
  userPosition.averageEntryPrice = BigInt.fromI32(0);
  userPosition.lastUpdated = event.block.timestamp;
  userPosition.tradeCount = userPosition.tradeCount.plus(BigInt.fromI32(1));
  userPosition.save();

  let userStats = getOrCreateUserStats(event.params.trader);
  userStats.activePositionsCount = userStats.activePositionsCount.minus(
    BigInt.fromI32(1)
  );

  // Performance & Risk Bonus Points Ï≤òÎ¶¨
  let userRange = userPosition.upperTick.minus(userPosition.lowerTick);
  let market = loadMarketOrSkip(userPosition.market, "handlePositionClosed");
  if (market == null) return;
  let marketRange = market.maxTick.minus(market.minTick);
  let holdingSeconds = event.block.timestamp.minus(originalWeightedEntryTime);

  // Performance Points Í≥ÑÏÇ∞ Î∞è Ï†ÅÎ¶Ω
  let performancePt = calcPerformancePoints(tradeRealizedPnL);
  if (performancePt.gt(BigInt.fromI32(0))) {
    addPerformancePoints(userStats, performancePt);
  }

  // Risk Bonus Points Í≥ÑÏÇ∞ Î∞è Ï†ÅÎ¶Ω
  let riskBonusPt = calcRiskBonusPoints(
    originalActivityRemaining,
    userRange,
    marketRange,
    holdingSeconds
  );
  if (riskBonusPt.gt(BigInt.fromI32(0))) {
    addRiskBonusPoints(userStats, riskBonusPt);
  }

  let trade = new Trade(
    event.transaction.hash.concatI32(event.logIndex.toI32())
  );
  trade.userPosition = userPosition.id;
  trade.user = event.params.trader;
  trade.market = userPosition.market;
  trade.positionId = event.params.positionId;
  trade.type = "CLOSE";
  trade.lowerTick = userPosition.lowerTick;
  trade.upperTick = userPosition.upperTick;
  trade.quantity = closedQuantity.times(BigInt.fromI32(-1));
  trade.costOrProceeds = event.params.proceeds;
  // Î∂ÑÎ™® 0 Í∞ÄÎìú
  let price = BigInt.fromI32(0);
  if (!closedQuantity.equals(BigInt.fromI32(0))) {
    price = event.params.proceeds
      .times(BigInt.fromString("1000000"))
      .div(closedQuantity);
  } else {
    log.warning(
      "[handlePositionClosed] closedQuantity is 0, skip price calc",
      []
    );
  }
  trade.price = price;
  trade.gasUsed = event.receipt ? event.receipt!.gasUsed : BigInt.fromI32(0);
  trade.gasPrice = event.transaction.gasPrice;
  trade.timestamp = event.block.timestamp;
  trade.blockNumber = event.block.number;
  trade.transactionHash = event.transaction.hash;
  trade.feeAmount = BigInt.fromI32(0);
  trade.feePolicyAddress = Address.zero();

  trade.activityPt = BigInt.fromI32(0);
  trade.performancePt = performancePt;
  trade.riskBonusPt = riskBonusPt;
  trade.save();

  userStats.totalTrades = userStats.totalTrades.plus(BigInt.fromI32(1));
  userStats.totalVolume = userStats.totalVolume.plus(event.params.proceeds);
  userStats.totalProceeds = userStats.totalProceeds.plus(event.params.proceeds);
  userStats.totalRealizedPnL = userStats.totalRealizedPnL.plus(
    userPosition.realizedPnL
  );
  userStats.lastTradeAt = event.block.timestamp;
  userStats.avgTradeSize = userStats.totalVolume.div(userStats.totalTrades);
  userStats.save();

  updateBinVolumes(
    extractRawMarketId(userPosition.market),
    userPosition.lowerTick,
    userPosition.upperTick,
    event.params.proceeds
  );

  let marketStats = getOrCreateMarketStats(userPosition.market);

  // PnL ÏóÖÎç∞Ïù¥Ìä∏ - CLOSEÏóêÏÑú ÎßàÏºìÏù¥ proceedsÎ•º ÏßÄÍ∏â
  marketStats.totalBetPaidOut = marketStats.totalBetPaidOut.plus(
    event.params.proceeds
  );
  updateMarketPnL(marketStats);

  marketStats.totalVolume = marketStats.totalVolume.plus(event.params.proceeds);
  marketStats.totalTrades = marketStats.totalTrades.plus(BigInt.fromI32(1));
  marketStats.currentPrice = trade.price;
  marketStats.lastUpdated = event.block.timestamp;

  if (trade.price.gt(marketStats.highestPrice)) {
    marketStats.highestPrice = trade.price;
  }
  if (trade.price.lt(marketStats.lowestPrice)) {
    marketStats.lowestPrice = trade.price;
  }
  marketStats.save();
}

export function handlePositionDecreased(event: PositionDecreasedEvent): void {
  const userPosition = loadPosOrSkip(
    buildPositionId(event.params.positionId),
    "handlePositionDecreased"
  );
  if (userPosition == null) return;
  let oldQuantity = userPosition.currentQuantity;
  // Î∂ÑÎ™® 0 Í∞ÄÎìú
  if (oldQuantity.equals(BigInt.fromI32(0))) {
    log.warning(
      "[handlePositionDecreased] oldQuantity is 0, skip portions",
      []
    );
    return;
  }
  let costPortion = userPosition.currentCost
    .times(event.params.sellQuantity)
    .div(oldQuantity);

  let tradeRealizedPnL = event.params.proceeds.minus(costPortion);

  userPosition.currentQuantity = event.params.newQuantity;
  // totalCostsÎäî Ïú†ÏßÄ (Ï†àÎåÄ Í∞êÏÜåÌïòÏßÄ ÏïäÏùå)
  userPosition.currentCost = userPosition.currentCost.minus(costPortion); // ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÎπÑÏö©Îßå ÎπÑÎ°Ä Í∞êÏÜå
  userPosition.totalQuantitySold = userPosition.totalQuantitySold.plus(
    event.params.sellQuantity
  );
  userPosition.totalProceeds = userPosition.totalProceeds.plus(
    event.params.proceeds
  );
  userPosition.realizedPnL = userPosition.realizedPnL.plus(tradeRealizedPnL);

  userPosition.averageEntryPrice = calculateRawPrice(
    userPosition.currentCost,
    userPosition.currentQuantity
  );

  let activityPortion = userPosition.activityRemaining
    .times(event.params.sellQuantity)
    .div(oldQuantity);

  // Store original weightedEntryTime before potentially resetting it
  let originalWeightedEntryTime = userPosition.weightedEntryTime;

  userPosition.activityRemaining =
    userPosition.activityRemaining.minus(activityPortion);

  if (event.params.newQuantity.equals(BigInt.fromI32(0))) {
    userPosition.outcome = "CLOSED";
    userPosition.weightedEntryTime = BigInt.fromI32(0);

    let userStats = getOrCreateUserStats(event.params.trader);
    userStats.activePositionsCount = userStats.activePositionsCount.minus(
      BigInt.fromI32(1)
    );
    userStats.save();
  }

  userPosition.tradeCount = userPosition.tradeCount.plus(BigInt.fromI32(1));
  userPosition.lastUpdated = event.block.timestamp;
  userPosition.save();

  // Performance & Risk Bonus Points Ï≤òÎ¶¨
  let userStats = getOrCreateUserStats(event.params.trader);
  let userRange = userPosition.upperTick.minus(userPosition.lowerTick);
  let market = loadMarketOrSkip(userPosition.market, "handlePositionDecreased");
  if (market == null) return;
  let marketRange = market.maxTick.minus(market.minTick);
  let holdingSeconds = event.block.timestamp.minus(originalWeightedEntryTime);

  // Performance Points Í≥ÑÏÇ∞ Î∞è Ï†ÅÎ¶Ω
  let performancePt = calcPerformancePoints(tradeRealizedPnL);
  if (performancePt.gt(BigInt.fromI32(0))) {
    addPerformancePoints(userStats, performancePt);
  }

  // Risk Bonus Points Í≥ÑÏÇ∞ Î∞è Ï†ÅÎ¶Ω
  let riskBonusPt = calcRiskBonusPoints(
    activityPortion,
    userRange,
    marketRange,
    holdingSeconds
  );
  if (riskBonusPt.gt(BigInt.fromI32(0))) {
    addRiskBonusPoints(userStats, riskBonusPt);
  }

  let trade = new Trade(
    event.transaction.hash.concatI32(event.logIndex.toI32())
  );
  trade.userPosition = userPosition.id;
  trade.user = event.params.trader;
  trade.market = userPosition.market;
  trade.positionId = event.params.positionId;
  trade.type = "DECREASE";
  trade.lowerTick = userPosition.lowerTick;
  trade.upperTick = userPosition.upperTick;
  trade.quantity = event.params.sellQuantity.times(BigInt.fromI32(-1));
  trade.costOrProceeds = event.params.proceeds;
  trade.price = calculateRawPrice(
    event.params.proceeds,
    event.params.sellQuantity
  );
  trade.gasUsed = event.receipt ? event.receipt!.gasUsed : BigInt.fromI32(0);
  trade.gasPrice = event.transaction.gasPrice;
  trade.timestamp = event.block.timestamp;
  trade.blockNumber = event.block.number;
  trade.transactionHash = event.transaction.hash;
  trade.feeAmount = BigInt.fromI32(0);
  trade.feePolicyAddress = Address.zero();

  trade.activityPt = BigInt.fromI32(0);
  trade.performancePt = performancePt;
  trade.riskBonusPt = riskBonusPt;
  trade.save();

  updateBinVolumes(
    extractRawMarketId(userPosition.market),
    userPosition.lowerTick,
    userPosition.upperTick,
    event.params.proceeds
  );

  userStats.totalTrades = userStats.totalTrades.plus(BigInt.fromI32(1));
  userStats.totalVolume = userStats.totalVolume.plus(event.params.proceeds);
  userStats.totalProceeds = userStats.totalProceeds.plus(event.params.proceeds);
  userStats.lastTradeAt = event.block.timestamp;
  userStats.save();

  let marketStats = getOrCreateMarketStats(userPosition.market);

  // PnL ÏóÖÎç∞Ïù¥Ìä∏ - DECREASEÏóêÏÑú ÎßàÏºìÏù¥ proceedsÎ•º ÏßÄÍ∏â
  marketStats.totalBetPaidOut = marketStats.totalBetPaidOut.plus(
    event.params.proceeds
  );
  updateMarketPnL(marketStats);

  marketStats.totalVolume = marketStats.totalVolume.plus(event.params.proceeds);
  marketStats.totalTrades = marketStats.totalTrades.plus(BigInt.fromI32(1));
  marketStats.currentPrice = trade.price;
  marketStats.lastUpdated = event.block.timestamp;

  if (trade.price.gt(marketStats.highestPrice)) {
    marketStats.highestPrice = trade.price;
  }
  if (trade.price.lt(marketStats.lowestPrice)) {
    marketStats.lowestPrice = trade.price;
  }
  marketStats.save();
}

export function handlePositionIncreased(event: PositionIncreasedEvent): void {
  // ========================================
  // PnL TRACKING: UPDATE USER POSITION & CREATE TRADE
  // ========================================

  // Update UserPosition
  const userPosition = loadPosOrSkip(
    buildPositionId(event.params.positionId),
    "handlePositionIncreased"
  );
  if (userPosition == null) return;

  userPosition.totalCosts = userPosition.totalCosts.plus(event.params.cost); // Ï¥ù Îß§Ïàò ÎπÑÏö© ÎàÑÏ†Å
  userPosition.currentCost = userPosition.currentCost.plus(event.params.cost); // ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÎπÑÏö© Ï¶ùÍ∞Ä
  userPosition.totalQuantityBought = userPosition.totalQuantityBought.plus(
    event.params.additionalQuantity
  );
  userPosition.currentQuantity = event.params.newQuantity;

  userPosition.averageEntryPrice = calculateRawPrice(
    userPosition.currentCost,
    userPosition.currentQuantity
  );

  let currentTime = event.block.timestamp;
  let oldQuantity = userPosition.currentQuantity.minus(
    event.params.additionalQuantity
  );
  userPosition.weightedEntryTime = userPosition.weightedEntryTime
    .times(oldQuantity)
    .plus(currentTime.times(event.params.additionalQuantity))
    .div(userPosition.currentQuantity);

  userPosition.tradeCount = userPosition.tradeCount.plus(BigInt.fromI32(1));
  userPosition.lastUpdated = event.block.timestamp;
  userPosition.save();

  // Activity Points Ï≤òÎ¶¨ (ÌïòÎ£® 3Î≤à Ï†úÌïú)
  let userStats = getOrCreateUserStats(event.params.trader);
  let activityPt = BigInt.fromI32(0);

  if (checkActivityLimit(userStats, event.block.timestamp)) {
    activityPt = calcActivityPoints(event.params.cost);
    addActivityPoints(userStats, activityPt);
  }

  let trade = new Trade(
    event.transaction.hash.concatI32(event.logIndex.toI32())
  );
  trade.userPosition = userPosition.id;
  trade.user = event.params.trader;
  trade.market = userPosition.market;
  trade.positionId = event.params.positionId;
  trade.type = "INCREASE";
  trade.lowerTick = userPosition.lowerTick;
  trade.upperTick = userPosition.upperTick;
  trade.quantity = event.params.additionalQuantity;
  trade.costOrProceeds = event.params.cost;
  trade.price = calculateRawPrice(
    event.params.cost,
    event.params.additionalQuantity
  );
  trade.gasUsed = event.receipt ? event.receipt!.gasUsed : BigInt.fromI32(0);
  trade.gasPrice = event.transaction.gasPrice;
  trade.timestamp = event.block.timestamp;
  trade.blockNumber = event.block.number;
  trade.transactionHash = event.transaction.hash;
  trade.feeAmount = BigInt.fromI32(0);
  trade.feePolicyAddress = Address.zero();

  trade.activityPt = activityPt;
  trade.performancePt = BigInt.fromI32(0);
  trade.riskBonusPt = BigInt.fromI32(0);
  trade.save();

  userPosition.activityRemaining =
    userPosition.activityRemaining.plus(activityPt);
  userPosition.save();

  updateBinVolumes(
    extractRawMarketId(userPosition.market),
    userPosition.lowerTick,
    userPosition.upperTick,
    event.params.cost
  );

  userStats.totalTrades = userStats.totalTrades.plus(BigInt.fromI32(1));
  userStats.totalVolume = userStats.totalVolume.plus(event.params.cost);
  userStats.totalCosts = userStats.totalCosts.plus(event.params.cost);
  userStats.lastTradeAt = event.block.timestamp;
  userStats.save();

  let marketStats = getOrCreateMarketStats(userPosition.market);

  // PnL ÏóÖÎç∞Ïù¥Ìä∏ - INCREASEÏóêÏÑú ÎßàÏºìÏù¥ costÎ•º Î∞õÏùå
  marketStats.totalBetReceived = marketStats.totalBetReceived.plus(
    event.params.cost
  );
  updateMarketPnL(marketStats);

  marketStats.totalVolume = marketStats.totalVolume.plus(event.params.cost);
  marketStats.totalTrades = marketStats.totalTrades.plus(BigInt.fromI32(1));
  marketStats.currentPrice = trade.price;
  marketStats.lastUpdated = event.block.timestamp;

  if (trade.price.gt(marketStats.highestPrice)) {
    marketStats.highestPrice = trade.price;
  }
  if (trade.price.lt(marketStats.lowestPrice)) {
    marketStats.lowestPrice = trade.price;
  }
  marketStats.save();
}

export function handlePositionOpened(event: PositionOpenedEvent): void {
  let userPosition = new UserPosition(buildPositionId(event.params.positionId));
  userPosition.positionId = event.params.positionId;
  userPosition.user = event.params.trader;
  userPosition.stats = event.params.trader;
  userPosition.market = buildMarketId(event.params.marketId);
  userPosition.lowerTick = event.params.lowerTick;
  userPosition.upperTick = event.params.upperTick;

  userPosition.currentQuantity = event.params.quantity;
  userPosition.totalCosts = event.params.cost; // Ïã†Í∑ú: Ï¥ù Îß§Ïàò ÎπÑÏö© ÎàÑÏ†Å
  userPosition.currentCost = event.params.cost; // Ïã†Í∑ú: ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÎπÑÏö©
  userPosition.averageEntryPrice = calculateRawPrice(
    event.params.cost,
    event.params.quantity
  );
  userPosition.totalQuantityBought = event.params.quantity;
  userPosition.totalQuantitySold = BigInt.fromI32(0);
  userPosition.totalProceeds = BigInt.fromI32(0);
  userPosition.totalFeesPaid = BigInt.fromI32(0);
  userPosition.realizedPnL = BigInt.fromI32(0);
  userPosition.tradeCount = BigInt.fromI32(1);
  userPosition.outcome = "OPEN";
  userPosition.isClaimed = false;
  userPosition.createdAt = event.block.timestamp;
  userPosition.lastUpdated = event.block.timestamp;
  userPosition.activityRemaining = BigInt.fromI32(0);
  userPosition.weightedEntryTime = event.block.timestamp;
  userPosition.save();

  // Activity Points Ï≤òÎ¶¨ (ÌïòÎ£® 3Î≤à Ï†úÌïú)
  let userStats = getOrCreateUserStats(event.params.trader);
  let activityPt = BigInt.fromI32(0);

  if (checkActivityLimit(userStats, event.block.timestamp)) {
    activityPt = calcActivityPoints(event.params.cost);
    addActivityPoints(userStats, activityPt);
  }

  let trade = new Trade(
    event.transaction.hash.concatI32(event.logIndex.toI32())
  );
  trade.userPosition = userPosition.id;
  trade.user = event.params.trader;
  trade.market = buildMarketId(event.params.marketId);
  trade.positionId = event.params.positionId;
  trade.type = "OPEN";
  trade.lowerTick = event.params.lowerTick;
  trade.upperTick = event.params.upperTick;
  trade.quantity = event.params.quantity;
  trade.costOrProceeds = event.params.cost;
  trade.price = userPosition.averageEntryPrice;
  trade.gasUsed = event.receipt ? event.receipt!.gasUsed : BigInt.fromI32(0);
  trade.gasPrice = event.transaction.gasPrice;
  trade.timestamp = event.block.timestamp;
  trade.blockNumber = event.block.number;
  trade.transactionHash = event.transaction.hash;
  trade.feeAmount = BigInt.fromI32(0);
  trade.feePolicyAddress = Address.zero();

  trade.activityPt = activityPt;
  trade.performancePt = BigInt.fromI32(0);
  trade.riskBonusPt = BigInt.fromI32(0);
  trade.save();

  userPosition.activityRemaining = activityPt;
  userPosition.save();

  updateBinVolumes(
    event.params.marketId,
    event.params.lowerTick,
    event.params.upperTick,
    event.params.cost
  );

  userStats.activePositionsCount = userStats.activePositionsCount.plus(
    BigInt.fromI32(1)
  );
  userStats.totalTrades = userStats.totalTrades.plus(BigInt.fromI32(1));
  userStats.totalVolume = userStats.totalVolume.plus(event.params.cost);
  userStats.totalCosts = userStats.totalCosts.plus(event.params.cost);
  userStats.lastTradeAt = event.block.timestamp;
  if (userStats.firstTradeAt.equals(BigInt.fromI32(0))) {
    userStats.firstTradeAt = event.block.timestamp;
  }

  userStats.avgTradeSize = userStats.totalVolume.div(userStats.totalTrades);
  userStats.save();

  let marketStats = getOrCreateMarketStats(
    buildMarketId(event.params.marketId)
  );

  // PnL ÏóÖÎç∞Ïù¥Ìä∏ - OPENÏóêÏÑú ÎßàÏºìÏù¥ costÎ•º Î∞õÏùå
  marketStats.totalBetReceived = marketStats.totalBetReceived.plus(
    event.params.cost
  );
  updateMarketPnL(marketStats);

  marketStats.totalVolume = marketStats.totalVolume.plus(event.params.cost);
  marketStats.totalTrades = marketStats.totalTrades.plus(BigInt.fromI32(1));
  marketStats.currentPrice = userPosition.averageEntryPrice;
  marketStats.lastUpdated = event.block.timestamp;

  if (userPosition.averageEntryPrice.gt(marketStats.highestPrice)) {
    marketStats.highestPrice = userPosition.averageEntryPrice;
  }
  if (userPosition.averageEntryPrice.lt(marketStats.lowestPrice)) {
    marketStats.lowestPrice = userPosition.averageEntryPrice;
  }
  marketStats.save();
}

export function handleRangeFactorApplied(event: RangeFactorAppliedEvent): void {
  const market = loadMarketOrSkip(
    buildMarketId(event.params.marketId),
    "handleRangeFactorApplied"
  );
  if (market == null) return;

  // Event lo/hi are TICK boundaries [lo, hi); convert to inclusive bin indices
  // and clamp to valid range
  let lo = event.params.lo
    .minus(market.minTick)
    .div(market.tickSpacing)
    .toI32();
  let hi =
    event.params.hi.minus(market.minTick).div(market.tickSpacing).toI32() - 1;
  const maxIdx = market.numBins.toI32() - 1;
  if (lo < 0) lo = 0;
  if (hi < 0) hi = 0;
  if (lo > maxIdx) lo = maxIdx;
  if (hi > maxIdx) hi = maxIdx;

  const bins = new Array<BinState>();
  const values = new Array<BigInt>();

  for (let i = lo; i <= hi; i++) {
    const id = buildBinStateId(event.params.marketId, i);
    let bin = loadBinOrSkip(id, "handleRangeFactorApplied");
    let binState: BinState;
    if (bin == null) {
      const lowerTickBin = market.minTick.plus(
        BigInt.fromI32(i).times(market.tickSpacing)
      );
      const upperTickBin = lowerTickBin.plus(market.tickSpacing);
      binState = new BinState(id);
      binState.market = market.id;
      binState.binIndex = BigInt.fromI32(i);
      binState.lowerTick = lowerTickBin;
      binState.upperTick = upperTickBin;
      binState.currentFactor = wad();
      binState.lastUpdated = event.block.timestamp;
      binState.updateCount = zero();
      binState.totalVolume = zero();
    } else {
      binState = bin;
    }
    bins.push(binState);
    values.push(binState.currentFactor);
  }

  const correction = computeRangeFactorCorrection(values, event.params.factor);

  for (let i = 0; i < bins.length; i++) {
    const binState = bins[i];
    const nextValue = correction.correctedValues[i];
    binState.currentFactor = nextValue;
    binState.lastUpdated = event.block.timestamp;
    binState.updateCount = binState.updateCount.plus(one());
    binState.save();
  }

  // MarketDistribution ÏôÑÏ†Ñ Ï†úÍ±∞Î°ú ÏÑ±Îä• ÏµúÏ†ÅÌôî - Î≥ÑÎèÑ Ï≤òÎ¶¨ Î∂àÌïÑÏöî

  market.lastUpdated = event.block.timestamp;
  market.save();
}

```


## clmsr-subgraph/src/constants.ts

```typescript
import { BigInt } from "@graphprotocol/graph-ts";

export const WAD_STRING = "1000000000000000000";

export function wad(): BigInt {
  return BigInt.fromString(WAD_STRING);
}

export function zero(): BigInt {
  return BigInt.fromI32(0);
}

export function one(): BigInt {
  return BigInt.fromI32(1);
}

```


## clmsr-subgraph/src/points.ts

```typescript
import { BigInt, BigDecimal, Bytes } from "@graphprotocol/graph-ts";
import { UserStats } from "../generated/schema";
import { PointsGranted } from "../generated/PointsGranter/PointsGranter";
import { getOrCreateUserStats } from "./clmsr-market-core";

// ============= Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§ =============

/** UTC Í∏∞Ï§Ä ÏùºÏûê Í≥ÑÏÇ∞ (timestampÎ•º Ïùº Îã®ÏúÑÎ°ú floor) */
export function getUtcDay(timestamp: BigInt): BigInt {
  const secondsPerDay = BigInt.fromI32(86400); // 24 * 60 * 60
  return timestamp.div(secondsPerDay);
}

/** Activity Point ÌïòÎ£® 3Î≤à Ï†úÌïú Ï≤¥ÌÅ¨ */
export function checkActivityLimit(
  userStats: UserStats,
  timestamp: BigInt
): boolean {
  const currentDay = getUtcDay(timestamp);

  // ÏÉàÎ°úÏö¥ ÎÇ†Ïù¥Î©¥ Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã
  if (userStats.lastActivityDay.lt(currentDay)) {
    userStats.activityPointsToday = BigInt.fromI32(0);
    userStats.lastActivityDay = currentDay;
  }

  // ÌïòÎ£® 3Î≤à Ï†úÌïú Ï≤¥ÌÅ¨
  return userStats.activityPointsToday.lt(BigInt.fromI32(3));
}

// ============= ÏàúÏàò Í≥ÑÏÇ∞ Ìï®ÏàòÎì§ =============

/** Activity Ìè¨Ïù∏Ìä∏ Í≥ÑÏÇ∞ */
export function calcActivityPoints(cost: BigInt): BigInt {
  return cost.div(BigInt.fromI32(10)); // A = cost / 10
}

/** Performance Ìè¨Ïù∏Ìä∏ Í≥ÑÏÇ∞ */
export function calcPerformancePoints(realizedPnL: BigInt): BigInt {
  return realizedPnL.gt(BigInt.fromI32(0)) ? realizedPnL : BigInt.fromI32(0);
}

/** Risk Î≥¥ÎÑàÏä§ Ìè¨Ïù∏Ìä∏ Í≥ÑÏÇ∞ (Î≥¥Ïú†ÏãúÍ∞Ñ >= 1ÏãúÍ∞ÑÏùº ÎïåÎßå) */
export function calcRiskBonusPoints(
  activityPoints: BigInt,
  userRange: BigInt,
  marketRange: BigInt,
  holdingSeconds: BigInt
): BigInt {
  // 1ÏãúÍ∞Ñ(3600Ï¥à) ÎØ∏ÎßåÏù¥Î©¥ 0 Ìè¨Ïù∏Ìä∏
  if (holdingSeconds.lt(BigInt.fromI32(3600))) {
    return BigInt.fromI32(0);
  }

  // Î≤îÏúÑ Ï∞®Ïù¥ Í≥ÑÏÇ∞
  let rangeDiff = marketRange.minus(userRange);
  if (rangeDiff.lt(BigInt.fromI32(0))) rangeDiff = BigInt.fromI32(0);

  // multiplier = 1 + rangeDiff/marketRange (ÏµúÎåÄ 2.0ÏúºÎ°ú Ï†úÌïú)
  let multiplier = BigInt.fromI32(1000000).plus(
    rangeDiff.times(BigInt.fromI32(1000000)).div(marketRange)
  ); // 1000000 = 100%
  if (multiplier.gt(BigInt.fromI32(2000000)))
    multiplier = BigInt.fromI32(2000000); // ÏµúÎåÄ 200%

  // R = A √ó 0.3 √ó multiplier = A √ó 300000 / 1000000
  let risk = activityPoints
    .times(BigInt.fromI32(300000))
    .div(BigInt.fromI32(1000000))
    .times(multiplier)
    .div(BigInt.fromI32(1000000));

  // min(R, 2A)
  let maxRisk = activityPoints.times(BigInt.fromI32(2));
  return risk.gt(maxRisk) ? maxRisk : risk;
}

// ============= Îã®Ïàú Ï†ÅÎ¶Ω Ìó¨ÌçºÎì§ =============

/** Activity Points Ï†ÅÎ¶Ω (Ïπ¥Ïö¥ÌÑ∞ Ï¶ùÍ∞Ä Ìè¨Ìï®) */
export function addActivityPoints(userStats: UserStats, amount: BigInt): void {
  userStats.totalPoints = userStats.totalPoints.plus(amount);
  userStats.activityPoints = userStats.activityPoints.plus(amount);
  userStats.activityPointsToday = userStats.activityPointsToday.plus(
    BigInt.fromI32(1)
  );
}

/** Performance Points Ï†ÅÎ¶Ω */
export function addPerformancePoints(
  userStats: UserStats,
  amount: BigInt
): void {
  userStats.totalPoints = userStats.totalPoints.plus(amount);
  userStats.performancePoints = userStats.performancePoints.plus(amount);
}

/** Risk Bonus Points Ï†ÅÎ¶Ω */
export function addRiskBonusPoints(userStats: UserStats, amount: BigInt): void {
  userStats.totalPoints = userStats.totalPoints.plus(amount);
  userStats.riskBonusPoints = userStats.riskBonusPoints.plus(amount);
}

// ============= Points Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ =============

/** Map reason code to string */
function mapReason(code: i32): string {
  if (code == 1) return "ACTIVITY";
  if (code == 2) return "PERFORMANCE";
  if (code == 3) return "RISK_BONUS";
  return "MANUAL";
}

/** Handle manual grant from PointsGranter */
export function handlePointsGranted(e: PointsGranted): void {
  const ts = e.params.contextTs.notEqual(BigInt.zero())
    ? e.params.contextTs
    : e.block.timestamp;

  const reason = mapReason(e.params.reason as i32);
  const userStats = getOrCreateUserStats(e.params.user);

  // Ìè¨Ïù∏Ìä∏ Ï†ÅÎ¶Ω
  userStats.totalPoints = userStats.totalPoints.plus(e.params.amount);
  if (reason == "ACTIVITY") {
    userStats.activityPoints = userStats.activityPoints.plus(e.params.amount);
  } else if (reason == "PERFORMANCE") {
    userStats.performancePoints = userStats.performancePoints.plus(
      e.params.amount
    );
  } else if (reason == "RISK_BONUS") {
    userStats.riskBonusPoints = userStats.riskBonusPoints.plus(e.params.amount);
  }
  userStats.save();
}

```


## clmsr-subgraph/src/range-factor-correction.ts

```typescript
import { BigInt, log } from "@graphprotocol/graph-ts";

import { wad, zero } from "./constants";

class CorrectionRow {
  index: i32;
  quotient: BigInt;
  remainder: BigInt;

  constructor(index: i32, quotient: BigInt, remainder: BigInt) {
    this.index = index;
    this.quotient = quotient;
    this.remainder = remainder;
  }
}

function adjustResidual(rows: Array<CorrectionRow>, residual: BigInt): void {
  if (residual.equals(zero())) {
    return;
  }

  const step = wad();
  const positive = residual.gt(zero());
  let remaining = positive ? residual : residual.times(BigInt.fromI32(-1));
  const steps = remaining.div(step).toI32();

  if (steps === 0) {
    return;
  }

  for (let s = 0; s < steps; s++) {
    let target = rows[0];
    for (let i = 1; i < rows.length; i++) {
      const candidate = rows[i];
      if (positive) {
        if (
          candidate.remainder.gt(target.remainder) ||
          (candidate.remainder.equals(target.remainder) &&
            candidate.index < target.index)
        ) {
          target = candidate;
        }
      } else {
        if (
          candidate.remainder.lt(target.remainder) ||
          (candidate.remainder.equals(target.remainder) &&
            candidate.index < target.index)
        ) {
          target = candidate;
        }
      }
    }

    if (positive) {
      target.quotient = target.quotient.plus(step);
    } else {
      target.quotient = target.quotient.minus(step);
    }
  }
}

export class RangeFactorCorrectionResult {
  correctedValues: Array<BigInt>;
  sumBefore: BigInt;
  targetAfter: BigInt;
  tildeSum: BigInt;
  afterSum: BigInt;
  residual: BigInt;

  constructor(
    correctedValues: Array<BigInt>,
    sumBefore: BigInt,
    targetAfter: BigInt,
    tildeSum: BigInt,
    afterSum: BigInt,
    residual: BigInt
  ) {
    this.correctedValues = correctedValues;
    this.sumBefore = sumBefore;
    this.targetAfter = targetAfter;
    this.tildeSum = tildeSum;
    this.afterSum = afterSum;
    this.residual = residual;
  }
}

export function computeRangeFactorCorrection(
  values: Array<BigInt>,
  factor: BigInt
): RangeFactorCorrectionResult {
  const size = values.length;
  const rows = new Array<CorrectionRow>(size);
  let sumBefore = zero();
  let tildeSum = zero();
  const half = wad().div(BigInt.fromI32(2));

  for (let i = 0; i < size; i++) {
    const value = values[i];
    sumBefore = sumBefore.plus(value);

    const product = value.times(factor);
    const quotient = product.plus(half).div(wad());
    const remainder = product.mod(wad());

    rows[i] = new CorrectionRow(i, quotient, remainder);
    tildeSum = tildeSum.plus(quotient);
  }

  const targetAfter = sumBefore.times(factor).plus(half).div(wad());
  const residual = targetAfter.minus(tildeSum);

  const correctedValues = new Array<BigInt>(size);
  adjustResidual(rows, residual);
  let afterSum = zero();
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    correctedValues[row.index] = row.quotient;
  }

  for (let i = 0; i < correctedValues.length; i++) {
    afterSum = afterSum.plus(correctedValues[i]);
  }

  if (!afterSum.equals(targetAfter)) {
    log.warning(
      "[range-factor] After-sum {} mismatches target {} (residual {})",
      [afterSum.toString(), targetAfter.toString(), residual.toString()]
    );
  }

  return new RangeFactorCorrectionResult(
    correctedValues,
    sumBefore,
    targetAfter,
    tildeSum,
    afterSum,
    targetAfter.minus(afterSum)
  );
}

```


## clmsr-subgraph/schema.graphql

```graphql
# ÎßàÏºìÏùò ÌòÑÏû¨ ÏÉÅÌÉú
type Market @entity(immutable: false) {
  id: String! # marketId
  marketId: BigInt!
  minTick: BigInt! # int256 - ÏµúÏÜå Ìã± Í∞í
  maxTick: BigInt! # int256 - ÏµúÎåÄ Ìã± Í∞í
  tickSpacing: BigInt! # int256 - Ìã± Í∞ÑÍ≤©
  startTimestamp: BigInt!
  endTimestamp: BigInt!
  settlementTimestamp: BigInt # uint64 - Ï†ïÏÇ∞ Í∏∞Ï§Ä ÏãúÍ∞Å (Ïã†Í∑ú ÌïÑÎìú, nullable)
  numBins: BigInt! # uint32 - Í≥ÑÏÇ∞Îêú Îπà Í∞úÏàò
  liquidityParameter: BigInt!
  isActive: Boolean!
  isSettled: Boolean!
  settlementValue: BigInt # int256 (6 decimals, original value)
  settlementTick: BigInt # int256 (calculated from settlementValue)
  lastUpdated: BigInt!
  feePolicyAddress: Bytes!
  feePolicyDescriptor: String
  # Í¥ÄÍ≥Ñ ÌïÑÎìúÎì§
  bins: [BinState!]! @derivedFrom(field: "market")
}

# Segment TreeÏùò Í∞Å binÎ≥Ñ ÌòÑÏû¨ ÏÉÅÌÉú
type BinState @entity(immutable: false) {
  id: String! # marketId-binIndex
  market: Market!
  binIndex: BigInt! # uint32 - segment treeÏóêÏÑúÏùò 0-based Ïù∏Îç±Ïä§
  lowerTick: BigInt! # int256 - Ïù¥ binÏù¥ Ïª§Î≤ÑÌïòÎäî Ïã§Ï†ú Ìã± Î≤îÏúÑ ÏãúÏûë
  upperTick: BigInt! # int256 - Ïù¥ binÏù¥ Ïª§Î≤ÑÌïòÎäî Ïã§Ï†ú Ìã± Î≤îÏúÑ ÎÅù (exclusive)
  currentFactor: BigInt! # ÌòÑÏû¨ ÎàÑÏ†Å factor Í∞í (WAD ÌòïÏãù, 18 decimals)
  lastUpdated: BigInt!
  updateCount: BigInt! # ÏóÖÎç∞Ïù¥Ìä∏Îêú ÌöüÏàò
  totalVolume: BigInt! # Ïù¥ binÏóêÏÑú Î∞úÏÉùÌïú Ï¥ù Í±∞ÎûòÎüâ (6 decimals, raw USDC)
}

# ÏÇ¨Ïö©ÏûêÎ≥Ñ Ìè¨ÏßÄÏÖò ÌòÑÌô© (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏)
type UserPosition @entity(immutable: false) {
  # ===== Í∏∞Î≥∏ Ï†ïÎ≥¥ =====
  id: String! # positionId
  positionId: BigInt!
  user: Bytes! # address
  stats: UserStats! # reference to UserStats
  market: Market!
  lowerTick: BigInt! # int256
  upperTick: BigInt! # int256
  # ===== ÌòÑÏû¨ Î≥¥Ïú† ÏÉÅÌÉú =====
  currentQuantity: BigInt! # ÌòÑÏû¨ Î≥¥Ïú†Îüâ (6 decimals, raw USDC)
  currentCost: BigInt! # ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÎπÑÏö© (DECREASE Ïãú ÎπÑÎ°Ä Í∞êÏÜå) (6 decimals, raw USDC)
  averageEntryPrice: BigInt! # ÌèâÍ∑† ÏßÑÏûÖÍ∞Ä (currentCost / currentQuantity) (6 decimals, raw cost per raw quantity)
  # ===== Îß§Ïàò ÎàÑÏ†Å =====
  totalCosts: BigInt! # Ï¥ù Îß§Ïàò ÎπÑÏö© ÎàÑÏ†Å (OPEN + INCREASE, Ï†àÎåÄ Í∞êÏÜå Ïïà Ìï®) (6 decimals, raw USDC)
  totalQuantityBought: BigInt! # Ï¥ù Îß§ÏàòÎüâ (6 decimals, raw USDC)
  # ===== Îß§ÎèÑ ÎàÑÏ†Å =====
  totalProceeds: BigInt! # Ï¥ù Îß§ÎèÑ ÏàòÏùµ (6 decimals, raw USDC)
  totalQuantitySold: BigInt! # Ï¥ù Îß§ÎèÑÎüâ (6 decimals, raw USDC)
  totalFeesPaid: BigInt! # Ïù¥ Ìè¨ÏßÄÏÖòÏóêÏÑú ÎÇ∏ Ï¥ù ÏàòÏàòÎ£å (6 decimals, raw USDC)
  tradeCount: BigInt! # Ìè¨ÏßÄÏÖò Îã®ÏúÑ Ï≤¥Í≤∞ ÌöüÏàò
  # ===== ÏÜêÏùµ =====
  realizedPnL: BigInt! # Ïã§ÌòÑ ÏÜêÏùµ (totalProceeds - totalCosts) (6 decimals, raw USDC, signed)
  # ===== ÏÉÅÌÉú Î∞è ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ =====
  outcome: PositionOutcome! # Ìè¨ÏßÄÏÖò ÏÉÅÌÉú (OPEN/CLOSED/WIN/LOSS)
  isClaimed: Boolean! # ÏäπÎ¶¨ Ìè¨ÏßÄÏÖò ÏàòÎ†π Ïó¨Î∂Ä
  createdAt: BigInt!
  lastUpdated: BigInt!

  # ===== Ìè¨Ïù∏Ìä∏ Í≥ÑÏÇ∞Ïö© =====
  activityRemaining: BigInt! # OPEN+INCREASE ÎàÑÏ†Å, DECREASE/CLOSE/CLAIMÎ°ú Ï∞®Í∞ê (6 decimals)
  weightedEntryTime: BigInt! # Î™®Îì† ÎÇ®ÏùÄ ÏàòÎüâÏùò Í∞ÄÏ§ë ÌèâÍ∑† ÏßÑÏûÖ ÏãúÍ∞Å
}

# Í∞úÎ≥Ñ Í±∞Îûò Í∏∞Î°ù (Îß§Ïàò/Îß§ÎèÑ)
type Trade @entity(immutable: true) {
  id: Bytes! # transactionHash-logIndex
  userPosition: String! # UserPosition ID
  user: Bytes! # address
  market: Market!
  positionId: BigInt!
  type: TradeType! # OPEN, INCREASE, DECREASE, CLOSE, CLAIM
  lowerTick: BigInt! # int256
  upperTick: BigInt! # int256
  quantity: BigInt! # Í±∞ÎûòÎüâ (6 decimals, raw USDC, DECREASE/CLOSEÎäî ÏùåÏàò)
  costOrProceeds: BigInt! # ÎπÑÏö© ÎòêÎäî ÏàòÏùµ (6 decimals, raw USDC)
  price: BigInt! # Îã®ÏúÑÎãπ Í∞ÄÍ≤© (6 decimals, raw USDC)
  gasUsed: BigInt! # Í∞ÄÏä§ ÏÇ¨Ïö©Îüâ
  gasPrice: BigInt! # Í∞ÄÏä§ Í∞ÄÍ≤©
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  feeAmount: BigInt! # Í±∞ÎûòÏóê Î∂ÄÍ≥ºÎêú ÏàòÏàòÎ£å (6 decimals, raw USDC)
  feePolicyAddress: Bytes! # ÏàòÏàòÎ£å Ï†ïÏ±Ö Ï£ºÏÜå
  activityPt: BigInt! # OPEN¬∑INCREASEÏóêÏÑú Î∞úÏÉùÌïòÎäî Activity Ìè¨Ïù∏Ìä∏ (6 decimals)
  performancePt: BigInt! # DECREASE¬∑CLOSE¬∑SETTLEÏóêÏÑú PnL Í∏∞Î∞ò Performance Ìè¨Ïù∏Ìä∏ (6 decimals)
  riskBonusPt: BigInt! # DECREASE¬∑CLOSE¬∑SETTLEÏóêÏÑú Ï°∞Í±¥ Ï∂©Ï°± Ïãú Risk Bonus Ìè¨Ïù∏Ìä∏ (6 decimals)
}

enum TradeType {
  OPEN
  INCREASE
  DECREASE
  CLOSE
  SETTLE
}

enum PositionOutcome {
  OPEN
  CLOSED
  WIN
  LOSS
}

# ÏÇ¨Ïö©ÏûêÎ≥Ñ Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ Î∞è PnL
type UserStats @entity(immutable: false) {
  id: Bytes! # user address
  user: Bytes! # address
  totalTrades: BigInt! # Ï¥ù Í±∞Îûò ÌöüÏàò (OPEN, INCREASE, DECREASE, CLOSEÎßå Ìè¨Ìï®, CLAIM Ï†úÏô∏)
  totalVolume: BigInt! # Ï¥ù Í±∞Îûò Í∏àÏï° (Îß§Ïàò: cost, Îß§ÎèÑ: proceeds) (6 decimals, raw USDC)
  totalCosts: BigInt! # Ï¥ù Îß§Ïàò ÎπÑÏö© (6 decimals, raw USDC)
  totalProceeds: BigInt! # Ï¥ù Îß§ÎèÑ ÏàòÏùµ (6 decimals, raw USDC)
  totalFeesPaid: BigInt! # Ï¥ù ÎÇ©Î∂Ä ÏàòÏàòÎ£å (6 decimals, raw USDC)
  totalRealizedPnL: BigInt! # Ï¥ù Ïã§ÌòÑ ÏÜêÏùµ (6 decimals, raw USDC, signed)
  totalGasFees: BigInt! # Ï¥ù Í∞ÄÏä§ ÎπÑÏö© (wei Îã®ÏúÑ)
  netPnL: BigInt! # Ïàú ÏÜêÏùµ (6 decimals, raw USDC, signed)
  activePositionsCount: BigInt! # ÌôúÏÑ± Ìè¨ÏßÄÏÖò Ïàò
  winningTrades: BigInt! # ÏàòÏùµ Í±∞Îûò Ïàò (ÎßåÎ£åÍπåÏßÄ Í∏∞Îã§Î¶∞ claimÎßå Ìï¥Îãπ)
  losingTrades: BigInt! # ÏÜêÏã§ Í±∞Îûò Ïàò (ÎßåÎ£åÍπåÏßÄ Í∏∞Îã§Î¶∞ claimÎßå Ìï¥Îãπ)
  winRate: BigDecimal! # ÏäπÎ•† (0.0 ~ 1.0 ÌçºÏÑºÌä∏, ÎßåÎ£åÍπåÏßÄ Í∏∞Îã§Î¶∞ Í≤ÉÎì§Îßå Í≥ÑÏÇ∞)
  avgTradeSize: BigInt! # ÌèâÍ∑† Í±∞Îûò ÌÅ¨Í∏∞ (Ï¥ù Í±∞Îûò Í∏àÏï° / Ï¥ù Í±∞Îûò ÌöüÏàò) (6 decimals, raw USDC)
  firstTradeAt: BigInt! # Ï≤´ Í±∞Îûò ÏãúÏ†ê
  lastTradeAt: BigInt! # ÎßàÏßÄÎßâ Í±∞Îûò ÏãúÏ†ê
  totalPoints: BigInt! # ÏÇ¨Ïö©Ïûê ÎàÑÏ†Å Ìè¨Ïù∏Ìä∏ ÏûîÍ≥† (6 decimals)
  activityPoints: BigInt! # ÎàÑÏ†Å Activity Ìè¨Ïù∏Ìä∏ (OPEN, INCREASEÏóêÏÑú Î∞úÏÉù) (6 decimals)
  performancePoints: BigInt! # ÎàÑÏ†Å Performance Ìè¨Ïù∏Ìä∏ (DECREASE, CLOSE, SETTLEÏóêÏÑú PnL Í∏∞Î∞ò) (6 decimals)
  riskBonusPoints: BigInt! # ÎàÑÏ†Å Risk Bonus Ìè¨Ïù∏Ìä∏ (DECREASE, CLOSE, SETTLEÏóêÏÑú Ï°∞Í±¥ Ï∂©Ï°± Ïãú) (6 decimals)
  activityPointsToday: BigInt! # Ïò§Îäò ÌöçÎìùÌïú Activity Ìè¨Ïù∏Ìä∏ ÌöüÏàò (0-3, UTC Í∏∞Ï§Ä)
  lastActivityDay: BigInt! # ÎßàÏßÄÎßâ Activity Ìè¨Ïù∏Ìä∏ ÌöçÎìù ÏùºÏûê (UTC Í∏∞Ï§Ä timestampÎ•º Ïùº Îã®ÏúÑÎ°ú floor)
  positions: [UserPosition!]! @derivedFrom(field: "stats")
}

# ÏãúÏû•Î≥Ñ Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
type MarketStats @entity(immutable: false) {
  id: String! # marketId
  market: Market!
  totalVolume: BigInt! # Ï¥ù Í±∞Îûò Í∏àÏï° (Îß§Ïàò: cost, Îß§ÎèÑ: proceeds) (6 decimals, raw USDC)
  totalTrades: BigInt! # Ï¥ù Í±∞Îûò Ïàò (OPEN, INCREASE, DECREASE, CLOSEÎßå Ìè¨Ìï®, CLAIM Ï†úÏô∏)
  totalFees: BigInt! # Ï¥ù ÏàòÏàòÎ£å (6 decimals, raw USDC)
  highestPrice: BigInt! # ÏµúÍ≥†Í∞Ä (6 decimals, raw cost per raw quantity)
  lowestPrice: BigInt! # ÏµúÏ†ÄÍ∞Ä (6 decimals, raw cost per raw quantity)
  currentPrice: BigInt! # ÌòÑÏû¨Í∞Ä (ÎßàÏßÄÎßâ Í±∞Îûò Í∞ÄÍ≤©, 6 decimals raw)
  priceChange24h: BigDecimal! # 24ÏãúÍ∞Ñ Í∞ÄÍ≤© Î≥ÄÌôîÏú® (ÌçºÏÑºÌä∏)
  volume24h: BigInt! # 24ÏãúÍ∞Ñ Í±∞ÎûòÎüâ (6 decimals, raw USDC)
  lastUpdated: BigInt!

  # === ÎßàÏºì PnL & Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ ===
  # Î≤†ÌåÖ Îã®Í≥Ñ ÏàòÏùµ/ÎπÑÏö©
  totalBetReceived: BigInt! # ÎßàÏºìÏù¥ Î∞õÏùÄ Ï¥ù Î≤†ÌåÖ Í∏àÏï° (OPEN + INCREASE cost) (6 decimals, raw USDC)
  totalBetPaidOut: BigInt! # ÎßàÏºìÏù¥ ÏßÄÍ∏âÌïú Ï¥ù Î≤†ÌåÖ ÏàòÏùµ (DECREASE + CLOSE proceeds) (6 decimals, raw USDC)
  bettingNetIncome: BigInt! # Î≤†ÌåÖ Îã®Í≥Ñ ÏàúÏàòÏùµ (Î∞õÏùÄ Í∏àÏï° - ÏßÄÍ∏â Í∏àÏï°) (6 decimals, raw USDC, signed)
  # Ï†ïÏÇ∞ Îã®Í≥Ñ ÏÜêÏã§ (Claim ÏòàÏÉÅ ÏÜêÏã§)
  totalSettlementPayout: BigInt! # Ï†ïÏÇ∞ ÌõÑ Ï¥ù ÏßÄÍ∏â ÏòàÏ†ï Í∏àÏï° (PositionSettledÏóêÏÑú WIN Ïãú payout Ìï©Í≥Ñ) (6 decimals, raw USDC)
  totalClaimedPayout: BigInt! # Ïã§Ï†ú Ï≤≠Íµ¨Îêú Ï¥ù Í∏àÏï° (PositionClaimed payout Ìï©Í≥Ñ) (6 decimals, raw USDC)
  unclaimedPayout: BigInt! # ÏïÑÏßÅ Ï≤≠Íµ¨ÎêòÏßÄ ÏïäÏùÄ Í∏àÏï° (settlementPayout - claimedPayout) (6 decimals, raw USDC)
  # Ï†ÑÏ≤¥ ÎßàÏºì ÏÜêÏùµ
  totalMarketPnL: BigInt! # Ï†ÑÏ≤¥ ÎßàÏºì ÏàúÏÜêÏùµ (bettingNetIncome - totalSettlementPayout) (6 decimals, raw USDC, signed)
  realizedMarketPnL: BigInt! # Ïã§ÌòÑÎêú ÎßàÏºì ÏÜêÏùµ (bettingNetIncome - totalClaimedPayout) (6 decimals, raw USDC, signed)
}

```


## clmsr-subgraph/subgraph-citrea-dev.yaml

```yaml
specVersion: 1.3.0
schema:
  file: ./schema.graphql
dataSources:
  # ===== ÏΩîÏñ¥ Ïª®Ìä∏ÎûôÌä∏ =====

  - kind: ethereum
    name: CLMSRMarketCore
    network: citrea-testnet-tangerine
    source:
      address: "0x971F9bcE130743BB3eFb37aeAC2050cD44d7579a"
      abi: CLMSRMarketCore
      startBlock: 14044300
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.9
      language: wasm/assemblyscript
      entities:
        - Market
        - MarketDistribution
        - BinState
        - UserPosition
        - Trade
        - MarketStats
        - UserStats
      abis:
        - name: CLMSRMarketCore
          file: ./abis/CLMSRMarketCore.json
        - name: ICLMSRFeePolicy
          file: ./abis/ICLMSRFeePolicy.json
      eventHandlers:
        - event: MarketCreated(indexed uint256,uint64,uint64,int256,int256,int256,uint32,uint256)
          handler: handleMarketCreated
        - event: MarketActivationUpdated(indexed uint256,bool)
          handler: handleMarketActivationUpdated
        - event: MarketFeePolicySet(indexed uint256,indexed address,indexed address)
          handler: handleMarketFeePolicySet
        - event: MarketSettled(indexed uint256,int256)
          handler: handleMarketSettled
        - event: MarketReopened(indexed uint256)
          handler: handleMarketReopened
        - event: PositionClaimed(indexed uint256,indexed address,uint256)
          handler: handlePositionClaimed
        - event: PositionClosed(indexed uint256,indexed address,uint256)
          handler: handlePositionClosed
        - event: PositionDecreased(indexed uint256,indexed address,uint128,uint128,uint256)
          handler: handlePositionDecreased
        - event: PositionIncreased(indexed uint256,indexed address,uint128,uint128,uint256)
          handler: handlePositionIncreased
        - event: PositionOpened(indexed uint256,indexed address,indexed uint256,int256,int256,uint128,uint256)
          handler: handlePositionOpened
        - event: PositionSettled(indexed uint256,indexed address,uint256,bool)
          handler: handlePositionSettled
        - event: RangeFactorApplied(indexed uint256,indexed int256,indexed int256,uint256)
          handler: handleRangeFactorApplied
        - event: MarketTimingUpdated(indexed uint256,uint64,uint64)
          handler: handleMarketTimingUpdated
        - event: MarketSettlementValueSubmitted(indexed uint256,int256)
          handler: handleMarketSettlementValueSubmitted
        - event: SettlementTimestampUpdated(indexed uint256,uint64)
          handler: handleSettlementTimestampUpdated
        - event: TradeFeeCharged(indexed address,indexed uint256,indexed uint256,bool,uint256,uint256,address)
          handler: handleTradeFeeCharged
      file: ./src/clmsr-market-core.ts

  # ===== PointsGranter Ïª®Ìä∏ÎûôÌä∏ =====
  - kind: ethereum
    name: PointsGranter
    network: citrea-testnet-tangerine
    source:
      address: "0x59eb810fa5e7c0646902C29D9e8bfdaDf25Ce274"
      abi: PointsGranter
      startBlock: 14044300
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.9
      language: wasm/assemblyscript
      entities:
        - UserStats
      abis:
        - name: PointsGranter
          file: ./abis/PointsGranter.json
      eventHandlers:
        - event: PointsGranted(indexed address,uint256,uint8,uint64)
          handler: handlePointsGranted
      file: ./src/clmsr-market-core.ts

```


## clmsr-subgraph/networks.json

```json
{
  "base-prod": {
    "CLMSRMarketCore": {
      "address": "0xbBf5703b1755B462FC5FC7319A1d3ACA4E1988Bc",
      "startBlock": 33772759
    }
  },
  "base-dev": {
    "CLMSRMarketCore": {
      "address": "0x894C07d390D7585c5205f2B81b9845e5432282B6",
      "startBlock": 33772759
    }
  },
  "citrea-dev": {
    "CLMSRMarketCore": {
      "address": "0x971F9bcE130743BB3eFb37aeAC2050cD44d7579a",
      "startBlock": 14044300
    }
  },
  "citrea-prod": {
    "CLMSRMarketCore": {
      "address": "0xE480ca1C63B6dd929af1EeA4D3de1073942F3cEf",
      "startBlock": 14176879
    }
  }
}

```

## Scripts


## scripts/actions/close-market.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

/**
 * Close a market by setting its endTimestamp to current time
 * This prevents further trading without settling the market
 */
export async function closeMarketAction(
  environment: Environment
): Promise<void> {
  // üéØ Configuration (can be overridden via environment variables)
  const marketId = parseInt(process.env.MARKET_ID || "55");

  console.log(`üö´ Closing market ${marketId} on ${environment}`);
  console.log(`   (Setting endTimestamp to current time to stop trading)`);

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  console.log("üìã Core Proxy:", addresses.CLMSRMarketCoreProxy);

  // Connect to Core contract
  const coreContract = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy
  );

  // Get current market info
  let market;
  try {
    market = await coreContract.getMarket(marketId);
    if (!market.isActive) {
      console.log(`‚ö†Ô∏è  Market ${marketId} is already inactive`);
      return;
    }
    if (market.settled) {
      console.log(`‚ö†Ô∏è  Market ${marketId} is already settled`);
      return;
    }
  } catch (error) {
    throw new Error(`Market ${marketId} not found or invalid`);
  }

  console.log("\nüìä Current Market Info:");
  console.log(`  Market ID: ${marketId}`);
  console.log(`  Active: ${market.isActive}`);
  console.log(`  Settled: ${market.settled}`);
  console.log(
    `  Start Time: ${new Date(
      Number(market.startTimestamp) * 1000
    ).toISOString()}`
  );
  console.log(
    `  End Time: ${new Date(Number(market.endTimestamp) * 1000).toISOString()}`
  );
  console.log(
    `  Settlement Time: ${new Date(
      Number(market.settlementTimestamp) * 1000
    ).toISOString()}`
  );

  // Calculate new timestamps
  const currentTime = Math.floor(Date.now() / 1000);
  const newStartTimestamp = Number(market.startTimestamp); // Keep original start
  const newEndTimestamp = currentTime; // Close immediately
  const newSettlementTimestamp = currentTime + 3600; // 1 hour buffer for settlement

  console.log("\nüîß New Timing:");
  console.log(
    `  Start Time: ${new Date(
      newStartTimestamp * 1000
    ).toISOString()} (unchanged)`
  );
  console.log(
    `  End Time: ${new Date(
      newEndTimestamp * 1000
    ).toISOString()} (NOW - closes trading)`
  );
  console.log(
    `  Settlement Time: ${new Date(
      newSettlementTimestamp * 1000
    ).toISOString()} (+1 hour buffer)`
  );

  // Validate timing
  if (newStartTimestamp >= newEndTimestamp) {
    throw new Error(
      "Invalid timing: start time would be >= end time after closing"
    );
  }
  if (newEndTimestamp >= newSettlementTimestamp) {
    throw new Error(
      "Invalid timing: end time would be >= settlement time after closing"
    );
  }

  // Update market timing to close it
  console.log("\nüö´ Closing market by updating timing...");
  const tx = await coreContract.updateMarketTiming(
    marketId,
    newStartTimestamp,
    newEndTimestamp,
    newSettlementTimestamp
  );

  const receipt = await tx.wait();
  console.log("‚úÖ Market closed successfully!");
  console.log(`üìä Transaction hash: ${receipt?.hash}`);
  console.log(`‚õΩ Gas used: ${receipt?.gasUsed?.toString()}`);

  // Verify updated state
  const updatedMarket = await coreContract.getMarket(marketId);
  console.log("\nüìã Updated Market Info:");
  console.log(`  Active: ${updatedMarket.isActive}`);
  console.log(
    `  End Time: ${new Date(
      Number(updatedMarket.endTimestamp) * 1000
    ).toISOString()}`
  );
  console.log(
    `  Settlement Time: ${new Date(
      Number(updatedMarket.settlementTimestamp) * 1000
    ).toISOString()}`
  );
  console.log("\nüí° Trading is now closed for this market.");
  console.log("   You can still settle it later using settle-market action.");
}

// CLI entry point
export async function closeMarketCLI(environment: Environment): Promise<void> {
  await closeMarketAction(environment);
}

```


## scripts/actions/compensate-susd.ts

```typescript
import { ethers } from "hardhat";
import * as fs from "fs";
import * as path from "path";
import type { Environment } from "../types/environment";
import { envManager } from "../utils/environment";

interface CsvRow {
  user: string;
  total_cost_microUSDC: string;
  total_proceeds_microUSDC: string;
  net_microUSDC: string;
  total_cost_USDC: string;
  total_proceeds_USDC: string;
  net_USDC: string;
  trades_count: string;
}

function parseCsv(filePath: string): CsvRow[] {
  const raw = fs.readFileSync(filePath, "utf8");
  const lines = raw
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter((l) => l.length > 0);
  if (lines.length < 2) return [];
  const header = lines[0].split(",").map((h) => h.trim());
  const rows: CsvRow[] = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split(",");
    const row: any = {};
    for (let j = 0; j < header.length && j < cols.length; j++) {
      row[header[j]] = cols[j].trim();
    }
    rows.push(row as CsvRow);
  }
  return rows;
}

export async function compensateSUSDAction(
  environment: Environment
): Promise<void> {
  const marketId = process.env.MARKET_ID || "24";
  const csvPathArg =
    process.env.CSV ||
    path.resolve(
      __dirname,
      `../../verification/investors-market-${marketId}.csv`
    );
  const batch = parseInt(process.env.BATCH || "50");
  const dryRun = (process.env.DRY_RUN || "false").toLowerCase() === "true";

  console.log(`üí∏ Compensate SUSD - environment=${environment}`);
  console.log(`üìÑ CSV: ${csvPathArg}`);
  console.log(`üß™ DryRun: ${dryRun}`);
  console.log(`üì¶ Batch size: ${batch}`);

  const [signer] = await ethers.getSigners();
  console.log("üë§ Sender:", signer.address);

  // Load SUSD address from environment file
  const susdAddress = envManager.getSUSDAddress(environment);
  if (!susdAddress) {
    throw new Error(`SUSD address not set in ${environment} environment`);
  }
  console.log("ü™ô SUSD:", susdAddress);

  const token = await ethers.getContractAt("MockERC20", susdAddress);

  // Load CSV
  if (!fs.existsSync(csvPathArg)) {
    throw new Error(`CSV not found: ${csvPathArg}`);
  }
  const records = parseCsv(csvPathArg);
  if (records.length === 0) {
    console.log("‚ö†Ô∏è  No records to process.");
    return;
  }

  // Compute totals
  const payouts = records.map((r) => ({
    user: r.user,
    amountMicro: BigInt(r.total_cost_microUSDC) * 2n,
  }));
  const totalMicro = payouts.reduce((s, p) => s + p.amountMicro, 0n);

  const toUsdc = (micro: bigint) => {
    const sign = micro < 0n ? "-" : "";
    const abs = micro < 0n ? -micro : micro;
    const intPart = abs / 1000000n;
    const frac = (abs % 1000000n).toString().padStart(6, "0");
    return `${sign}${intPart.toString()}.${frac}`;
  };

  console.log(`üìä Recipients: ${payouts.length}`);
  console.log(
    `Œ£ payout: ${totalMicro.toString()} micro (${toUsdc(totalMicro)} SUSD)`
  );

  // Balance / mint guard
  const balance = await token.balanceOf(signer.address);
  const balanceMicro = BigInt(balance.toString());
  console.log(
    `üí≥ Sender balance: ${balanceMicro.toString()} micro (${toUsdc(
      balanceMicro
    )} SUSD)`
  );

  if (balanceMicro < totalMicro) {
    console.log("‚ö†Ô∏è  Insufficient SUSD. Attempting mint by owner...");
    try {
      const mintTx = await token.mint(
        signer.address,
        totalMicro - balanceMicro
      );
      await mintTx.wait();
      console.log("‚úÖ Minted:", toUsdc(totalMicro - balanceMicro), "SUSD");
    } catch (e) {
      console.log(
        "‚ö†Ô∏è  Mint failed or not owner. You must fund the wallet before sending."
      );
    }
  }

  if (dryRun) {
    console.log(
      "üß™ Dry run only - Not sending transfers. Showing first 5 rows:"
    );
    payouts.slice(0, 5).forEach((p, i) => {
      console.log(`#${i + 1}`, p.user, toUsdc(p.amountMicro));
    });
    return;
  }

  // Execute transfers in batches
  let sent = 0;
  for (let i = 0; i < payouts.length; i += batch) {
    const slice = payouts.slice(i, i + batch);
    console.log(
      `\nüì¶ Sending batch ${i / batch + 1} (${slice.length} transfers)...`
    );
    for (const p of slice) {
      try {
        const tx = await token.transfer(p.user, p.amountMicro);
        const rcpt = await tx.wait();
        sent += 1;
        console.log(
          `‚úÖ Sent ${toUsdc(p.amountMicro)} to ${p.user} (tx: ${rcpt?.hash})`
        );
      } catch (err) {
        console.error(`‚ùå Failed to send to ${p.user}:`, err);
      }
    }
  }

  console.log(
    `\nüéâ Completed. Successful transfers: ${sent}/${payouts.length}`
  );
}

export async function compensateSUSDCLI(
  environment: Environment
): Promise<void> {
  await compensateSUSDAction(environment);
}

```


## scripts/actions/create-market.ts

```typescript
import { ethers as hardhatEthers, network } from "hardhat";
import { ethers, parseEther, Contract, Wallet, JsonRpcProvider } from "ethers";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";
import * as dotenv from "dotenv";

dotenv.config();

export async function createMarketAction(
  environment: Environment
): Promise<void> {
  console.log(`üè™ ÎßàÏºì ÏÉùÏÑ± ÏãúÏûë on ${environment}`);

  // RPC URL (ÌôòÍ≤ΩÎ≥ÄÏàò ÎòêÎäî Í∏∞Î≥∏ Citrea public RPC)
  const rpcUrl = process.env.CITREA_RPC_URL || "https://rpc.testnet.citrea.xyz";

  // ÏßÅÏ†ë ethers ProviderÏôÄ Wallet ÏÇ¨Ïö© (ÌïòÎìúÌñá Ïö∞Ìöå)
  const provider = new JsonRpcProvider(rpcUrl);

  const privateKey = process.env.PRIVATE_KEY;
  if (!privateKey) {
    throw new Error("PRIVATE_KEY not found in .env");
  }

  const deployer = new Wallet(privateKey, provider);
  console.log("Ìò∏Ï∂úÏûê Ï£ºÏÜå:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  // ÏàòÏàòÎ£å Ï†ïÏ±Ö Ï£ºÏÜå Í∞ÄÏ†∏Ïò§Í∏∞ (activePolicy ÎòêÎäî PercentFeePolicy100bps)
  const feePolicyAddress =
    addresses["FeePolicy:active"] ||
    addresses["FeePolicy:PercentFeePolicy100bps"] ||
    ethers.ZeroAddress;

  if (feePolicyAddress === ethers.ZeroAddress) {
    console.warn(
      "‚ö†Ô∏è  ÏàòÏàòÎ£å Ï†ïÏ±Ö Ï£ºÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ZeroAddressÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§."
    );
  } else {
    console.log("üí∞ ÏÇ¨Ïö©Ìï† ÏàòÏàòÎ£å Ï†ïÏ±Ö:", feePolicyAddress);
  }

  // ABI Í∞ÄÏ†∏Ïò§Í∏∞ (ÌïòÎìúÌñáÏóêÏÑúÎßå Í∞ÄÎä•) - ÎùºÏù¥Î∏åÎü¨Î¶¨ ÎßÅÌÇπ Ìè¨Ìï®
  const coreArtifact = await hardhatEthers.getContractFactory(
    "CLMSRMarketCore",
    {
      libraries: {
        FixedPointMathU: addresses.FixedPointMathU!,
        LazyMulSegmentTree: addresses.LazyMulSegmentTree!,
      },
    }
  );

  // Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞ (ÏßÅÏ†ë ethers ÏÇ¨Ïö©)
  const core = new Contract(
    addresses.CLMSRMarketCoreProxy,
    coreArtifact.interface,
    deployer
  );

  // BTC Daily 2025.09.29 ÎßàÏºì ÌååÎùºÎØ∏ÌÑ∞ ÏÑ§Ï†ï
  const minTick = 90000;
  const maxTick = 110000;
  const tickSpacing = 100;

  // Bin Í∞úÏàò Í≥ÑÏÇ∞: (maxTick - minTick) / tickSpacing
  const numBins = (maxTick - minTick) / tickSpacing; // 400Í∞úÏùò bin
  const numValidTicks = numBins + 1; // 401Í∞úÏùò Ïú†Ìö®Ìïú Ìã± Ìè¨Ïù∏Ìä∏

  // ÎßàÏºì ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ ÏÑ§Ï†ï (Ï¢ÖÎ£å 10Ïùº ÌõÑ)
  // ÏãúÏûë: ÌòÑÏû¨
  // Ï¢ÖÎ£å: 10Ïùº ÌõÑ
  // Ï†ïÏÇ∞: Ï¢ÖÎ£å 1ÏãúÍ∞Ñ ÌõÑ
  const now = Math.floor(Date.now() / 1000);
  const startTimestamp = now;
  const endTimestamp = now + 10 * 24 * 60 * 60; // 10Ïùº ÌõÑ
  const settlementTimestamp = endTimestamp + 60 * 60; // Ï¢ÖÎ£å 1ÏãúÍ∞Ñ ÌõÑ

  // liquidityParameter: 1000 ETH (Œ± = 1000)
  const liquidityParameter = parseEther("1000");

  console.log("\nüìä BTC Daily 2025.09.29 ÎßàÏºì ÏÑ§Ï†ï:");
  console.log("  - ÎßàÏºì ID: ÏûêÎèô ÏÉùÏÑ±Îê®");
  console.log("  - ÎßàÏºì Ïù¥Î¶Ñ: BTC Daily 2025.09.29");
  console.log("  - ÏµúÏÜå Ìã±:", minTick.toLocaleString());
  console.log("  - ÏµúÎåÄ Ìã±:", maxTick.toLocaleString(), "(ÏÉÅÌïú Î∂àÌè¨Ìï®)");
  console.log("  - Ìã± Í∞ÑÍ≤©:", tickSpacing);
  console.log("  - Ïú†Ìö®Ìïú Ìã± Ìè¨Ïù∏Ìä∏:", numValidTicks.toLocaleString(), "Í∞ú");
  console.log("  - Bin Í∞úÏàò (Range):", numBins.toLocaleString(), "Í∞ú");
  console.log(
    "  - ÏãúÏûë ÏãúÍ∞Ñ:",
    new Date(startTimestamp * 1000).toLocaleString() +
      " (2025-09-28 23:00:00 UTC)"
  );
  console.log(
    "  - Ï¢ÖÎ£å ÏãúÍ∞Ñ:",
    new Date(endTimestamp * 1000).toLocaleString() +
      " (2025-09-29 23:00:00 UTC)"
  );
  console.log(
    "  - Ï†ïÏÇ∞ ÏãúÍ∞Ñ:",
    new Date(settlementTimestamp * 1000).toLocaleString() +
      " (2025-09-30 00:00:00 UTC)"
  );
  console.log(
    "  - Ïú†ÎèôÏÑ± ÌååÎùºÎØ∏ÌÑ∞ (Œ±):",
    ethers.formatEther(liquidityParameter),
    "ETH"
  );
  console.log("  - ÏàòÏàòÎ£å Ï†ïÏ±Ö:", feePolicyAddress);

  try {
    // ÎßàÏºì ÏÉùÏÑ± (marketId ÏûêÎèô ÏÉùÏÑ±)
    const createMarketTx = await core.createMarket(
      minTick,
      maxTick,
      tickSpacing,
      startTimestamp,
      endTimestamp,
      settlementTimestamp,
      liquidityParameter,
      feePolicyAddress
    );

    console.log("\n‚è≥ ÎßàÏºì ÏÉùÏÑ± Ìä∏ÎûúÏû≠ÏÖò ÎåÄÍ∏∞ Ï§ë...");
    console.log("Ìä∏ÎûúÏû≠ÏÖò Ìï¥Ïãú:", createMarketTx.hash);

    const receipt = await createMarketTx.wait();

    // Ïù¥Î≤§Ìä∏ÏóêÏÑú ÏÉùÏÑ±Îêú marketId Ï∂îÏ∂ú
    const marketCreatedEvent = receipt?.logs.find((log) => {
      try {
        const parsed = core.interface.parseLog({
          topics: log.topics,
          data: log.data,
        });
        return parsed?.name === "MarketCreated";
      } catch {
        return false;
      }
    });

    let marketId: bigint | undefined;
    if (marketCreatedEvent) {
      const parsed = core.interface.parseLog({
        topics: marketCreatedEvent.topics,
        data: marketCreatedEvent.data,
      });
      marketId = parsed?.args[0]; // Ï≤´ Î≤àÏß∏ ÌååÎùºÎØ∏ÌÑ∞Í∞Ä marketId
    }

    console.log("‚úÖ ÎßàÏºì ÏÉùÏÑ± ÏÑ±Í≥µ!");
    console.log("  - ÏÉùÏÑ±Îêú ÎßàÏºì ID:", marketId?.toString() || "ÌôïÏù∏ Î∂àÍ∞Ä");
    console.log("  - Í∞ÄÏä§ ÏÇ¨Ïö©Îüâ:", receipt?.gasUsed.toString());

    const autoActivate = process.env.ACTIVATE_AFTER_CREATE === "true";

    if (autoActivate) {
      if (marketId === undefined) {
        console.warn(
          "‚ö†Ô∏è  ACTIVATE_AFTER_CREATE=true Ïù¥ÏßÄÎßå marketIdÎ•º ÌååÏã±ÌïòÏßÄ Î™ªÌï¥ ÌôúÏÑ±Ìôî Ïä§ÌÇµ"
        );
      } else {
        console.log(
          "\nüîì ACTIVATE_AFTER_CREATE=true -> ÎßàÏºì ÌôúÏÑ±Ìôî Ìä∏ÎûúÏû≠ÏÖò Ï†ÑÏÜ°..."
        );
        const activateTx = await core.setMarketActive(marketId, true);
        console.log("   ‚Ä¢ tx:", activateTx.hash);
        const activateReceipt = await activateTx.wait();
        console.log(
          "   ‚úÖ ÌôúÏÑ±Ìôî ÏôÑÎ£å (gas=",
          activateReceipt?.gasUsed?.toString() ?? "N/A",
          ")"
        );
      }
    } else {
      console.log(
        "\n‚ö†Ô∏è ÏÉàÎ°ú ÏÉùÏÑ±Îêú ÎßàÏºìÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎπÑÌôúÏÑ± ÏÉÅÌÉúÏûÖÎãàÎã§. ÏãúÎî© Î∞è Í≤ÄÏ¶ù ÏôÑÎ£å ÌõÑ ÏïÑÎûò Ïª§Îß®ÎìúÎ•º Ïã§ÌñâÌï¥ Í∞úÏû•ÌïòÏÑ∏Ïöî:"
      );
      if (marketId !== undefined) {
        console.log(
          `   COMMAND=set-market-active:${environment} MARKET_ID=${marketId.toString()} ACTIVE=true npx hardhat run scripts/dispatcher.ts --network ${environment}`
        );
      } else {
        console.log(
          "   (marketIdÎ•º ÌååÏã±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ÏóêÏÑú marketIdÎ•º ÌôïÏù∏Ìïú Îí§ set-market-active Ïä§ÌÅ¨Î¶ΩÌä∏Î•º Ïã§ÌñâÌïòÏÑ∏Ïöî)"
        );
      }
    }

    console.log("\nüéØ Market creation completed for", environment);
  } catch (error: any) {
    console.error("‚ùå ÎßàÏºì ÏÉùÏÑ± Ïã§Ìå®:", error.message);
    throw error;
  }
}

```


## scripts/actions/deploy-fee-policy.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

function parseArgs(raw: string | undefined): unknown[] {
  if (!raw || raw.trim().length === 0) {
    return [];
  }

  try {
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) {
      throw new Error("FEE_POLICY_ARGS must be a JSON array");
    }
    return parsed;
  } catch (error) {
    throw new Error(
      `Failed to parse FEE_POLICY_ARGS. Provide JSON array. Original error: ${
        (error as Error).message
      }`
    );
  }
}

export async function deployFeePolicyAction(
  environment: Environment
): Promise<void> {
  const contractName = process.env.FEE_POLICY_CONTRACT ?? "NullFeePolicy";
  const label = process.env.FEE_POLICY_LABEL ?? contractName;
  const constructorArgs = parseArgs(process.env.FEE_POLICY_ARGS);

  console.log(
    `ü™Ñ Deploying fee policy "${contractName}" (label: ${label}) on ${environment}`
  );
  if (constructorArgs.length > 0) {
    console.log("   ‚Ä¢ constructor args:", constructorArgs);
  }

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  const factory = await ethers.getContractFactory(contractName);
  const policy = await factory.deploy(...constructorArgs);
  await policy.waitForDeployment();
  const policyAddress = await policy.getAddress();

  console.log("‚úÖ Fee policy deployed at:", policyAddress);

  const targetEnvironments: Environment[] =
    environment === "citrea-dev" || environment === "citrea-prod"
      ? ["citrea-dev", "citrea-prod"]
      : [environment];

  for (const targetEnv of targetEnvironments) {
    envManager.loadOrInitializeEnvironment(targetEnv);
    envManager.updateFeePolicy(targetEnv, label, policyAddress);
  }

  console.log("\nüéâ Fee policy deployment complete!");
  console.log("   ‚Ä¢ Policy address:", policyAddress);
  console.log("   ‚Ä¢ Label:", label);
  if (targetEnvironments.length > 1) {
    console.log(
      `   ‚Ä¢ Recorded for environments: ${targetEnvironments.join(", ")}`
    );
  } else {
    console.log(`   ‚Ä¢ Recorded for environment: ${targetEnvironments[0]}`);
  }
  console.log(
    "   ‚Ä¢ Core configuration unchanged (use set-fee-policy to apply on-chain)"
  );
}

```


## scripts/actions/deploy-susd.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";

/**
 * Deploy new SUSD token for dev/prod environments (shared)
 */
export async function deploySUSDAction() {
  // ÎÑ§Ìä∏ÏõåÌÅ¨ Í∞êÏßÄ (ÌôòÍ≤ΩÎ≥ÄÏàò COMMANDÏóêÏÑú)
  const command = process.env.COMMAND || "";
  const isBase = command.includes("base");
  const isCitrea = command.includes("citrea");

  if (isBase) {
    console.log("ü™ô Deploying new SUSD for Base dev/prod environments");
  } else if (isCitrea) {
    console.log("ü™ô Deploying new SUSD for Citrea dev/prod environments");
  } else {
    console.log("ü™ô Deploying new SUSD for dev/prod environments");
  }

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  // Deploy MockERC20 as SUSD
  console.log("üèóÔ∏è Deploying SUSD token...");
  const MockERC20 = await ethers.getContractFactory("MockERC20");
  const susd = await MockERC20.deploy("Signals USD", "SUSD", 6);
  await susd.waitForDeployment();

  const susdAddress = await susd.getAddress();
  console.log("‚úÖ SUSD deployed:", susdAddress);

  // Update environments based on network
  if (isCitrea) {
    envManager.updateContract("citrea-dev", "tokens", "SUSD", susdAddress);

    // citrea-prod ÌååÏùºÏù¥ ÏóÜÏúºÎ©¥ Î®ºÏ†Ä Ï¥àÍ∏∞Ìôî
    if (!envManager.environmentExists("citrea-prod")) {
      envManager.initializeEnvironment("citrea-prod");
    }
    envManager.updateContract("citrea-prod", "tokens", "SUSD", susdAddress);
    console.log("‚úÖ Updated citrea-dev and citrea-prod environments");
  } else {
    // Default to base environments
    envManager.updateContract("base-dev", "tokens", "SUSD", susdAddress);
    envManager.updateContract("base-prod", "tokens", "SUSD", susdAddress);
    console.log("‚úÖ Updated base-dev and base-prod environments");
  }

  // Mint generous amounts to deployer
  const mintAmount = ethers.parseUnits("10000000", 6); // 10M SUSD (6 decimals)
  console.log("üí∞ Minting 10M SUSD to deployer...");

  try {
    const mintTx = await susd.mint(deployer.address, mintAmount);
    await mintTx.wait();
    console.log("‚úÖ 10M SUSD minted to:", deployer.address);
  } catch (error: any) {
    console.error("‚ùå Minting failed:", error.message);
    console.log("‚ö†Ô∏è Continuing without minting...");
  }

  // Get current balance
  const balance = await susd.balanceOf(deployer.address);
  const balanceFormatted = ethers.formatUnits(balance, 6);
  console.log(`üí≥ Deployer SUSD balance: ${balanceFormatted} SUSD`);

  console.log("\nüéâ SUSD deployment completed!");
  console.log("üìã Summary:");
  console.log(`  SUSD Address: ${susdAddress}`);
  console.log(`  Initial Supply: ${balanceFormatted} SUSD`);
  if (isCitrea) {
    console.log(`  Updated environments: citrea-dev, citrea-prod`);
  } else {
    console.log(`  Updated environments: base-dev, base-prod`);
  }

  return susdAddress;
}

```


## scripts/actions/deploy.ts

```typescript
import { ethers, upgrades } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

export async function deployAction(environment: Environment): Promise<void> {
  console.log(`üöÄ Deploying to ${environment}`);

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  // ÌôòÍ≤Ω ÌååÏùº ÌôïÏù∏ Î∞è ÌïÑÏöîÏãú Ï¥àÍ∏∞Ìôî
  if (!envManager.environmentExists(environment)) {
    console.log("üîß Initializing fresh environment for new deployment...");
    envManager.initializeEnvironment(environment);
  } else {
    console.log("üîç Using existing environment configuration...");
  }

  // SUSD Ï£ºÏÜå ÌôïÏù∏ (localhostÎäî ÏÉàÎ°ú Î∞∞Ìè¨, dev/prodÎäî Í∏∞Ï°¥ Í≤É ÏÇ¨Ïö©)
  let susdAddress: string | null | undefined;
  if (environment === "localhost") {
    susdAddress = null; // localhostÎäî Ìï≠ÏÉÅ ÏÉàÎ°ú Î∞∞Ìè¨
  } else {
    try {
      susdAddress = envManager.getSUSDAddress(environment);
    } catch (error) {
      susdAddress = null;
    }
  }

  if (!susdAddress) {
    if (environment === "localhost") {
      // LocalhostÎäî MockUSDC ÏÉàÎ°ú Î∞∞Ìè¨
      console.log("ü™ô Deploying MockUSDC for localhost...");
      const MockERC20 = await ethers.getContractFactory("MockERC20");
      const susd = await MockERC20.deploy("Signals USD", "SUSD", 6);
      await susd.waitForDeployment();
      susdAddress = await susd.getAddress();

      envManager.updateContract(environment, "tokens", "SUSD", susdAddress);
      console.log("‚úÖ MockUSDC deployed:", susdAddress);
    } else {
      // dev/prod: ÏÉàÎ°úÏö¥ SUSD ÌïÑÏöî (deploy-susd Ïä§ÌÅ¨Î¶ΩÌä∏Î°ú ÎØ∏Î¶¨ Î∞∞Ìè¨Ìï¥Ïïº Ìï®)
      const networkPrefix = environment.startsWith("citrea")
        ? "citrea"
        : "base";
      throw new Error(
        `‚ùå SUSD not found for ${environment}. Please run: npm run deploy-susd:${networkPrefix}`
      );
    }
  } else {
    console.log("‚úÖ Using existing SUSD:", susdAddress);
  }

  // ÎùºÏù¥Î∏åÎü¨Î¶¨ Î∞∞Ìè¨
  console.log("üìö Deploying libraries...");

  const FixedPointMathU = await ethers.getContractFactory("FixedPointMathU");
  const fixedPointMath = await FixedPointMathU.deploy();
  await fixedPointMath.waitForDeployment();
  const fixedPointMathAddress = await fixedPointMath.getAddress();
  envManager.updateContract(
    environment,
    "libraries",
    "FixedPointMathU",
    fixedPointMathAddress
  );

  const LazyMulSegmentTree = await ethers.getContractFactory(
    "LazyMulSegmentTree",
    { libraries: { FixedPointMathU: fixedPointMathAddress } }
  );
  const segmentTree = await LazyMulSegmentTree.deploy();
  await segmentTree.waitForDeployment();
  const segmentTreeAddress = await segmentTree.getAddress();
  envManager.updateContract(
    environment,
    "libraries",
    "LazyMulSegmentTree",
    segmentTreeAddress
  );

  console.log("‚úÖ Libraries deployed");

  console.log("üè¢ Deploying Manager contract...");
  const CLMSRMarketManager = await ethers.getContractFactory(
    "CLMSRMarketManager",
    {
      libraries: {
        LazyMulSegmentTree: segmentTreeAddress,
      },
    }
  );
  const manager = await CLMSRMarketManager.deploy();
  await manager.waitForDeployment();
  const managerAddress = await manager.getAddress();
  envManager.updateContract(
    environment,
    "core",
    "CLMSRMarketManager",
    managerAddress
  );
  console.log("‚úÖ Manager deployed:", managerAddress);

  // Position Ïª®Ìä∏ÎûôÌä∏ Î∞∞Ìè¨
  console.log("üé≠ Deploying Position contract...");

  const CLMSRPosition = await ethers.getContractFactory("CLMSRPosition");
  const positionProxy = await upgrades.deployProxy(
    CLMSRPosition,
    [ethers.ZeroAddress], // Temporary
    {
      kind: "uups",
      initializer: "initialize",
    }
  );
  await positionProxy.waitForDeployment();
  const positionProxyAddress = await positionProxy.getAddress();

  const positionImplAddress = await upgrades.erc1967.getImplementationAddress(
    positionProxyAddress
  );

  envManager.updateContract(
    environment,
    "core",
    "CLMSRPositionProxy",
    positionProxyAddress
  );
  envManager.updateContract(
    environment,
    "core",
    "CLMSRPositionImplementation",
    positionImplAddress
  );

  console.log("‚úÖ Position proxy deployed:", positionProxyAddress);

  // Core Ïª®Ìä∏ÎûôÌä∏ Î∞∞Ìè¨
  console.log("üèóÔ∏è Deploying Core contract...");

  const CLMSRMarketCore = await ethers.getContractFactory("CLMSRMarketCore", {
    libraries: {
      FixedPointMathU: fixedPointMathAddress,
      LazyMulSegmentTree: segmentTreeAddress,
    },
  });

  const coreProxy = await upgrades.deployProxy(
    CLMSRMarketCore,
    [susdAddress, positionProxyAddress],
    {
      kind: "uups",
      initializer: "initialize",
      unsafeAllow: ["external-library-linking", "delegatecall"],
    }
  );
  await coreProxy.waitForDeployment();
  const coreProxyAddress = await coreProxy.getAddress();

  const coreImplAddress = await upgrades.erc1967.getImplementationAddress(
    coreProxyAddress
  );

  envManager.updateContract(
    environment,
    "core",
    "CLMSRMarketCoreProxy",
    coreProxyAddress
  );
  envManager.updateContract(
    environment,
    "core",
    "CLMSRMarketCoreImplementation",
    coreImplAddress
  );

  console.log("‚úÖ Core proxy deployed:", coreProxyAddress);

  console.log("‚öôÔ∏è Configuring manager pointer...");
  await coreProxy.setManager(managerAddress);
  console.log("‚úÖ Manager linked to Core");

  // Position Ïª®Ìä∏ÎûôÌä∏ core Ï£ºÏÜå ÏóÖÎç∞Ïù¥Ìä∏
  console.log("üîó Updating Position contract...");
  await positionProxy.updateCore(coreProxyAddress);
  console.log("‚úÖ Position core address updated");

  // PointsGranter Î∞∞Ìè¨ (Ìï≠ÏÉÅ Î∞∞Ìè¨)
  console.log("üéØ Deploying PointsGranter (UUPS)...");
  const PointsGranter = await ethers.getContractFactory("PointsGranter");
  const pointsProxy = await upgrades.deployProxy(
    PointsGranter,
    [deployer.address],
    {
      kind: "uups",
      initializer: "initialize",
    }
  );
  await pointsProxy.waitForDeployment();
  const pointsProxyAddress = await pointsProxy.getAddress();
  const pointsImplAddress = await upgrades.erc1967.getImplementationAddress(
    pointsProxyAddress
  );

  envManager.updateContract(
    environment,
    "points" as any,
    "PointsGranterProxy",
    pointsProxyAddress
  );
  envManager.updateContract(
    environment,
    "points" as any,
    "PointsGranterImplementation",
    pointsImplAddress
  );
  console.log("‚úÖ PointsGranter deployed:", pointsProxyAddress);

  // localhostÏóêÏÑúÎßå Ï¥àÍ∏∞ SUSD ÎØºÌåÖ
  if (environment === "localhost") {
    console.log("üí∞ Minting initial SUSD...");
    const susdContract = await ethers.getContractAt("MockERC20", susdAddress);
    const mintAmount = ethers.parseUnits("1000000", 6);
    await susdContract.mint(deployer.address, mintAmount);
    console.log("‚úÖ Minted 1M SUSD to deployer");
  }

  // Î∞∞Ìè¨ Í∏∞Î°ù Ï†ÄÏû•
  envManager.addDeploymentRecord(environment, {
    version: "1.0.0",
    action: "deploy",
    contracts: {
      FixedPointMathU: fixedPointMathAddress,
      LazyMulSegmentTree: segmentTreeAddress,
      SUSD: susdAddress,
      CLMSRMarketManager: managerAddress,
      CLMSRPositionProxy: positionProxyAddress,
      CLMSRPositionImplementation: positionImplAddress,
      CLMSRMarketCoreProxy: coreProxyAddress,
      CLMSRMarketCoreImplementation: coreImplAddress,
      PointsGranterProxy: pointsProxyAddress,
      PointsGranterImplementation: pointsImplAddress,
    },
    deployer: deployer.address,
  });

  console.log("\nüéâ Deployment completed successfully!");
  envManager.printEnvironmentStatus(environment);
}

```


## scripts/actions/emit-position-settled.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

export async function emitPositionSettledAction(
  environment: Environment
): Promise<void> {
  // üéØ Í∏∞Î≥∏ ÏÑ§Ï†ïÍ∞í (ÌïÑÏöîÏãú ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ïò§Î≤ÑÎùºÏù¥Îìú Í∞ÄÎä•)
  const startMarketId = parseInt(process.env.START_MARKET_ID || "80");
  const endMarketId = parseInt(process.env.END_MARKET_ID || "100");
  const batchLimit = parseInt(process.env.BATCH_LIMIT || "100");

  console.log(
    `üì¢ Emitting PositionSettled events for markets ${startMarketId}-${endMarketId} on ${environment}`
  );
  console.log(`üì¶ Batch limit: ${batchLimit} positions per transaction`);

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  console.log("üìã Core Proxy:", addresses.CLMSRMarketCoreProxy);

  // Core Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
  const coreContract = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy
  );

  console.log("üìä Batch emission parameters:");
  console.log(`  Market Range: ${startMarketId} - ${endMarketId}`);
  console.log(`  Batch Limit: ${batchLimit}`);

  // Ï†ÑÏ≤¥ Ï≤òÎ¶¨ ÏÉÅÌÉú Ï∂îÏ†Å
  let totalMarketsProcessed = 0;
  let totalMarketsSkipped = 0;
  let totalBatchesProcessed = 0;
  let totalGasUsed = BigInt(0);

  console.log("\nüöÄ Starting multi-market emission...");

  // Í∞Å ÎßàÏºìÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
  for (let marketId = startMarketId; marketId <= endMarketId; marketId++) {
    console.log(
      `\nüìä Processing Market ${marketId} (${marketId - startMarketId + 1}/${
        endMarketId - startMarketId + 1
      })`
    );

    // ÎßàÏºì ÏÉÅÌÉú ÌôïÏù∏
    try {
      const market = await coreContract.getMarket(marketId);
      if (!market.settled) {
        console.log(`‚ö†Ô∏è  Market ${marketId} is not settled yet. Skipping...`);
        totalMarketsSkipped++;
        continue;
      }
      if (market.positionEventsEmitted) {
        console.log(
          `‚úÖ Market ${marketId} events already emitted. Skipping...`
        );
        totalMarketsSkipped++;
        continue;
      }
      console.log(
        `‚úÖ Market ${marketId} is settled and ready for batch emission`
      );
      console.log(`üìä Current cursor: ${market.positionEventsCursor}`);
    } catch (error) {
      console.error(
        `‚ùå Market ${marketId} validation failed: ${
          (error as Error).message
        }. Skipping...`
      );
      totalMarketsSkipped++;
      continue;
    }

    // ÌòÑÏû¨ ÎßàÏºìÏóê ÎåÄÌïú Î∞∞Ïπò Ïù¥Î≤§Ìä∏ emit
    let marketBatchCount = 0;
    let marketGasUsed = BigInt(0);

    console.log(`üöÄ Starting batch emission for market ${marketId}...`);

    while (true) {
      marketBatchCount++;
      console.log(
        `üì¶ Market ${marketId} - Processing batch ${marketBatchCount}...`
      );

      try {
        const tx = await coreContract.emitPositionSettledBatch(
          marketId,
          batchLimit
        );
        const receipt = await tx.wait();

        if (!receipt) {
          throw new Error("Transaction receipt is null");
        }

        console.log(
          `‚úÖ Market ${marketId} - Batch ${marketBatchCount} completed`
        );
        console.log(`üìä Transaction hash: ${receipt.hash}`);
        console.log(`‚õΩ Gas used: ${receipt.gasUsed.toString()}`);

        marketGasUsed += receipt.gasUsed;
        totalGasUsed += receipt.gasUsed;

        // Ïù¥Î≤§Ìä∏ Î°úÍ∑∏ÏóêÏÑú ÏßÑÌñâ ÏÉÅÌô© ÌôïÏù∏
        const positionEventsProgressLogs = receipt.logs.filter((log) => {
          try {
            const parsed = coreContract.interface.parseLog({
              topics: log.topics,
              data: log.data,
            });
            return parsed?.name === "PositionEventsProgress";
          } catch {
            return false;
          }
        });

        if (positionEventsProgressLogs.length > 0) {
          const progressLog = positionEventsProgressLogs[0];
          const parsed = coreContract.interface.parseLog({
            topics: progressLog.topics,
            data: progressLog.data,
          });

          if (parsed) {
            const { from, to, done } = parsed.args;
            console.log(
              `üìà Market ${marketId} - Progress: ${from} ‚Üí ${to} (done: ${done})`
            );

            if (done) {
              console.log(
                `üéâ Market ${marketId} - All position events emitted successfully!`
              );
              break;
            }
          }
        }

        // ÎßàÏºì ÏÉÅÌÉú Ïû¨ÌôïÏù∏
        const market = await coreContract.getMarket(marketId);
        if (market.positionEventsEmitted) {
          console.log(
            `üéâ Market ${marketId} - All position events emitted successfully!`
          );
          break;
        }
      } catch (error) {
        console.error(
          `‚ùå Market ${marketId} - Batch ${marketBatchCount} failed:`,
          (error as Error).message
        );
        console.error(`‚ùå Skipping market ${marketId} due to error`);
        totalMarketsSkipped++;
        break;
      }
    }

    // ÎßàÏºì Ï≤òÎ¶¨ ÏôÑÎ£å ÌõÑ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
    if (marketBatchCount > 0) {
      totalMarketsProcessed++;
      totalBatchesProcessed += marketBatchCount;
      console.log(`üìä Market ${marketId} Summary:`);
      console.log(`  Batches processed: ${marketBatchCount}`);
      console.log(`  Gas used: ${marketGasUsed.toString()}`);
    }
  }

  console.log("\nüìä Final Emission Summary:");
  console.log(
    `  Markets processed: ${totalMarketsProcessed}/${
      endMarketId - startMarketId + 1
    }`
  );
  console.log(`  Markets skipped: ${totalMarketsSkipped}`);
  console.log(`  Total batches processed: ${totalBatchesProcessed}`);
  console.log(`  Total gas used: ${totalGasUsed.toString()}`);
  console.log(
    `  Average gas per batch: ${
      totalBatchesProcessed > 0
        ? (totalGasUsed / BigInt(totalBatchesProcessed)).toString()
        : "0"
    }`
  );
}

// CLIÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÌï† Îïå ÏÇ¨Ïö©
export async function emitPositionSettledCLI(
  environment: Environment
): Promise<void> {
  await emitPositionSettledAction(environment);
}

```


## scripts/actions/pause-market.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

export async function pauseMarketAction(
  environment: Environment
): Promise<void> {
  // üéØ Í∏∞Î≥∏ ÏÑ§Ï†ïÍ∞í (ÌïÑÏöîÏãú ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ïò§Î≤ÑÎùºÏù¥Îìú Í∞ÄÎä•)
  const reason = process.env.PAUSE_REASON || "Emergency pause requested by admin";

  console.log(`‚è∏Ô∏è Pausing market contract on ${environment}`);
  console.log(`üìù Reason: ${reason}`);

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  console.log("üìã Core Proxy:", addresses.CLMSRMarketCoreProxy);

  // Core Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
  const coreContract = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy
  );

  // ÌòÑÏû¨ pause ÏÉÅÌÉú ÌôïÏù∏
  const isPaused = await coreContract.isPaused();
  if (isPaused) {
    console.log("‚ö†Ô∏è  Contract is already paused");
    return;
  }

  console.log("‚úÖ Contract is currently active");

  // ÎßàÏºì pause
  console.log("‚è∏Ô∏è Pausing contract...");
  const tx = await coreContract.pause(reason);

  const receipt = await tx.wait();
  console.log("‚úÖ Contract paused successfully!");
  console.log(`üìä Transaction hash: ${receipt?.hash}`);
  console.log(`‚õΩ Gas used: ${receipt?.gasUsed?.toString()}`);

  // Pause ÌõÑ ÏÉÅÌÉú ÌôïÏù∏
  const isPausedAfter = await coreContract.isPaused();
  console.log(`üîí Contract paused status: ${isPausedAfter}`);
}

// CLIÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÌï† Îïå ÏÇ¨Ïö©
export async function pauseMarketCLI(environment: Environment): Promise<void> {
  await pauseMarketAction(environment);
}

```


## scripts/actions/place-bet.ts

```typescript
import { ethers } from "hardhat";
import { parseUnits } from "ethers";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

export async function placeBetAction(environment: Environment): Promise<void> {
  console.log(`üéØ ÎßàÏºìÏóê Î≤†ÌåÖ ÏãúÏûë on ${environment}`);

  const [deployer] = await ethers.getSigners();
  console.log("Î≤†ÌÑ∞ Ï£ºÏÜå:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  if (!addresses.SUSD) {
    throw new Error(`SUSD not deployed in ${environment} environment`);
  }

  // Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
  const core = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy
  );

  const susd = await ethers.getContractAt("ERC20", addresses.SUSD);

  // Î≤†ÌåÖ ÌååÎùºÎØ∏ÌÑ∞ ÏÑ§Ï†ï - ÏÇ¨Ïö©Í∞ÄÎä•Ìïú ÏµúÏã† ÎßàÏºìÏùÑ Ï°∞ÌöåÌï¥ ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò, Í∏∞Î≥∏ 1Î≤à ÏÇ¨Ïö©
  const marketId = Number(process.env.MARKET_ID || 1);
  const startTick = 110000; // 110k
  const endTick = 115000; // 115k
  const costPerSegment = parseUnits("5", 6); // ÏÜåÏï° Î≤†ÌåÖ Í∏∞Î≥∏Í∞í

  // 1000 tickÏî© ÎÇòÎàÑÏñ¥ Î≤†ÌåÖ (110k-111k, 111k-112k, 112k-113k, 113k-114k, 114k-115k)
  const segments = [];
  for (let lower = startTick; lower < endTick; lower += 1000) {
    const upper = Math.min(lower + 1000, endTick);
    segments.push({ lower, upper });
  }

  console.log("\nüé≤ Î≤†ÌåÖ ÌååÎùºÎØ∏ÌÑ∞:");
  console.log(`  - ÎßàÏºì ID: ${marketId}`);
  console.log(
    `  - Ï†ÑÏ≤¥ Î≤†ÌåÖ Î≤îÏúÑ: ${startTick.toLocaleString()} ~ ${endTick.toLocaleString()}`
  );
  console.log(`  - ÏÑ∏Í∑∏Î®ºÌä∏ Í∞úÏàò: ${segments.length}`);
  console.log(`  - Í∞Å Íµ¨Í∞Ñ quantity: 1,000,000 (1Îã¨Îü¨Ïñ¥Ïπò payout)`);
  console.log(
    `  - ÏµúÎåÄ ÎπÑÏö© ÌïúÎèÑ(ÏÑ∏Í∑∏Î®ºÌä∏Îãπ): ${ethers.formatUnits(
      costPerSegment,
      6
    )} SUSD`
  );

  // Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏ Ï∂úÎ†•
  segments.forEach((seg, i) => {
    console.log(
      `    ${
        i + 1
      }. ${seg.lower.toLocaleString()} ~ ${seg.upper.toLocaleString()}`
    );
  });

  try {
    // 1. ÎßàÏºì Ï†ïÎ≥¥ ÌôïÏù∏
    console.log("\nüìä ÎßàÏºì Ï†ïÎ≥¥ ÌôïÏù∏...");
    const market = await core.getMarket(marketId);

    console.log("ÎßàÏºì Ï†ïÎ≥¥:");
    console.log(`  - ÌôúÏÑ± ÏÉÅÌÉú: ${market.isActive}`);
    console.log(`  - Ï†ïÏÇ∞ Ïó¨Î∂Ä: ${market.settled}`);
    console.log(
      `  - Ìã± Î≤îÏúÑ: ${market.minTick.toString()} ~ ${market.maxTick.toString()}`
    );
    console.log(`  - Ìã± Í∞ÑÍ≤©: ${market.tickSpacing.toString()}`);
    console.log(
      `  - ÏãúÏûë ÏãúÍ∞Ñ: ${new Date(
        Number(market.startTimestamp) * 1000
      ).toLocaleString()}`
    );
    console.log(
      `  - Ï¢ÖÎ£å ÏãúÍ∞Ñ: ${new Date(
        Number(market.endTimestamp) * 1000
      ).toLocaleString()}`
    );

    // ÎßàÏºì ÏÉÅÌÉú Í≤ÄÏ¶ù
    if (!market.isActive) {
      throw new Error("ÎßàÏºìÏù¥ ÎπÑÌôúÏÑ± ÏÉÅÌÉúÏûÖÎãàÎã§");
    }

    if (market.settled) {
      throw new Error("ÎßàÏºìÏù¥ Ïù¥ÎØ∏ Ï†ïÏÇ∞ÎêòÏóàÏäµÎãàÎã§");
    }

    // Ìã± Î≤îÏúÑ Í≤ÄÏ¶ù
    const minTick = Number(market.minTick);
    const maxTick = Number(market.maxTick);
    const tickSpacing = Number(market.tickSpacing);

    for (const segment of segments) {
      if (segment.lower < minTick || segment.upper > maxTick) {
        throw new Error(
          `Î≤†ÌåÖ Î≤îÏúÑÍ∞Ä ÎßàÏºì Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ©ÎãàÎã§. ÎßàÏºì Î≤îÏúÑ: ${minTick} ~ ${maxTick}`
        );
      }

      if ((segment.lower - minTick) % tickSpacing !== 0) {
        throw new Error(
          `lowerTickÏù¥ Ìã± Í∞ÑÍ≤©Ïóê ÎßûÏßÄ ÏïäÏäµÎãàÎã§. tickSpacing: ${tickSpacing}`
        );
      }

      if ((segment.upper - minTick) % tickSpacing !== 0) {
        throw new Error(
          `upperTickÏù¥ Ìã± Í∞ÑÍ≤©Ïóê ÎßûÏßÄ ÏïäÏäµÎãàÎã§. tickSpacing: ${tickSpacing}`
        );
      }

      if ((segment.upper - segment.lower) % tickSpacing !== 0) {
        throw new Error(
          `Î≤†ÌåÖ Î≤îÏúÑÍ∞Ä Ìã± Í∞ÑÍ≤©Ïùò Î∞∞ÏàòÍ∞Ä ÏïÑÎãôÎãàÎã§. tickSpacing: ${tickSpacing}`
        );
      }
    }

    // 2. USDC ÏûîÏï° ÌôïÏù∏
    const userBalance = await susd.balanceOf(deployer.address);
    const totalCost = BigInt(costPerSegment) * BigInt(segments.length + 2n);
    console.log(`\nüí∞ ÏûîÏï° ÌôïÏù∏:`);
    console.log(`ÌòÑÏû¨ USDC ÏûîÏï°: ${ethers.formatUnits(userBalance, 6)} USDC`);
    console.log(`ÌïÑÏöîÌïú Ï¥ù Í∏àÏï°: ${ethers.formatUnits(totalCost, 6)} USDC`);

    if (userBalance < totalCost) {
      throw new Error(
        `USDC ÏûîÏï°Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§. ÌïÑÏöî: ${ethers.formatUnits(
          totalCost,
          6
        )} USDC, Î≥¥Ïú†: ${ethers.formatUnits(userBalance, 6)} USDC`
      );
    }

    // 3. USDC ÏäπÏù∏ (Ï†ÑÏ≤¥ Í∏àÏï°Ïùò 110% Ïó¨Ïú†Î∂Ñ)
    const maxTotalCost = (totalCost * 120n) / 100n; // 20% Ïó¨Ïú†Î∂Ñ
    console.log(
      `\n‚úÖ USDC ÏäπÏù∏ Ï§ë... (${ethers.formatUnits(maxTotalCost, 6)} USDC)`
    );

    const approveTx = await susd.approve(
      addresses.CLMSRMarketCoreProxy,
      maxTotalCost
    );
    await approveTx.wait();
    console.log("USDC ÏäπÏù∏ ÏôÑÎ£å!");

    // 4. Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏Ïóê ÎåÄÌï¥ Î≤†ÌåÖ Ïã§Ìñâ
    const results = [];
    let totalActualCost = 0n;

    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      console.log(`\nüöÄ ÏÑ∏Í∑∏Î®ºÌä∏ ${i + 1}/${segments.length} Î≤†ÌåÖ Ïã§Ìñâ Ï§ë...`);
      console.log(
        `   Î≤îÏúÑ: ${segment.lower.toLocaleString()} ~ ${segment.upper.toLocaleString()}`
      );

      // quantityÎ•º loop Î∞ñÏúºÎ°ú Ïù¥Îèô
      const quantity = 1000000; // 1,000,000 Í≥†Ï†ï (1Îã¨Îü¨Ïñ¥Ïπò payout)
      const maxCost = costPerSegment * 10n; // Ïó¨Ïú†Î∂Ñ Ìè¨Ìï®

      try {
        // calculateCost Í±¥ÎÑàÎõ∞Í≥† Î∞îÎ°ú Î≤†ÌåÖ! Í≥†Ï†ï quantity ÏÇ¨Ïö©

        console.log(`   Í≥†Ï†ï quantity ÏÇ¨Ïö©: ${quantity.toString()}`);
        console.log(
          `   ÏµúÎåÄ ÎπÑÏö© ÌïúÎèÑ: ${ethers.formatUnits(maxCost, 6)} USDC`
        );
        const tx = await core.openPosition(
          marketId,
          segment.lower,
          segment.upper,
          quantity,
          maxCost
        );

        console.log(`   Ìä∏ÎûúÏû≠ÏÖò Ìï¥Ïãú: ${tx.hash}`);
        const receipt = await tx.wait();

        // Ìè¨ÏßÄÏÖò IDÏôÄ Ïã§Ï†ú ÎπÑÏö© Ï∂îÏ∂ú
        const events = receipt?.logs || [];
        let positionId = "Unknown";
        let actualCost = 0n;

        for (const log of events) {
          try {
            const parsed = core.interface.parseLog({
              topics: log.topics as string[],
              data: log.data,
            });

            if (parsed?.name === "PositionOpened") {
              positionId = parsed.args[0]?.toString() || "Unknown";
              actualCost = BigInt(parsed.args[6]?.toString() || "0"); // costÎäî 7Î≤àÏß∏ Ïù∏Ïûê (0Î∂ÄÌÑ∞ ÏãúÏûë)
              console.log(`   ‚úÖ Ìè¨ÏßÄÏÖò ID: ${positionId}`);
              console.log(
                `   üí∞ Ïã§Ï†ú ÎπÑÏö©: ${ethers.formatUnits(actualCost, 6)} USDC`
              );
              break;
            }
          } catch {
            // ÌååÏã± Ïã§Ìå®Îäî Î¨¥Ïãú
          }
        }

        if (actualCost === 0n) {
          console.log(`   ‚ö†Ô∏è  Ïã§Ï†ú ÎπÑÏö©ÏùÑ Ïù¥Î≤§Ìä∏ÏóêÏÑú Ï∂îÏ∂úÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§`);
          actualCost = maxCost; // fallbackÏúºÎ°ú ÏµúÎåÄ ÎπÑÏö© ÏÇ¨Ïö©
        }

        results.push({
          segment: `${segment.lower}-${segment.upper}`,
          positionId,
          quantity: quantity.toString(),
          actualCost: ethers.formatUnits(actualCost, 6),
          txHash: tx.hash,
          gasUsed: receipt?.gasUsed?.toString(),
        });

        totalActualCost += actualCost;
      } catch (error: any) {
        console.error(`   ‚ùå ÏÑ∏Í∑∏Î®ºÌä∏ ${i + 1} Î≤†ÌåÖ Ïã§Ìå®:`);
        console.error(`      ÏóêÎü¨ Î©îÏãúÏßÄ: ${error.message}`);

        // ÏûêÏÑ∏Ìïú ÏóêÎü¨ Ï†ïÎ≥¥ Ï∂úÎ†•
        if (error.reason) {
          console.error(`      ÏóêÎü¨ Ïù¥Ïú†: ${error.reason}`);
        }

        if (error.code) {
          console.error(`      ÏóêÎü¨ ÏΩîÎìú: ${error.code}`);
        }

        if (error.data) {
          console.error(`      ÏóêÎü¨ Îç∞Ïù¥ÌÑ∞: ${error.data}`);
        }

        if (error.transaction) {
          console.error(`      Ïã§Ìå®Ìïú Ìä∏ÎûúÏû≠ÏÖò:`, error.transaction);
        }

        if (error.receipt) {
          console.error(`      Ìä∏ÎûúÏû≠ÏÖò ÏòÅÏàòÏ¶ù:`, error.receipt);
        }

        // Ï†ÑÏ≤¥ ÏóêÎü¨ Í∞ùÏ≤¥ Ï∂úÎ†• (ÎîîÎ≤ÑÍπÖÏö©)
        console.error(`      Ï†ÑÏ≤¥ ÏóêÎü¨ Ï†ïÎ≥¥:`, JSON.stringify(error, null, 2));

        console.log(`   ‚è≠Ô∏è  Îã§Ïùå ÏÑ∏Í∑∏Î®ºÌä∏Î°ú Í≥ÑÏÜç ÏßÑÌñâ...`);

        // Ïã§Ìå®Ìïú ÏÑ∏Í∑∏Î®ºÌä∏ÎèÑ Í≤∞Í≥ºÏóê Í∏∞Î°ù
        results.push({
          segment: `${segment.lower}-${segment.upper}`,
          positionId: "FAILED",
          quantity: quantity.toString(),
          actualCost: "0",
          txHash: "FAILED",
          gasUsed: "0",
        });

        continue; // Îã§Ïùå ÏÑ∏Í∑∏Î®ºÌä∏Î°ú Í≥ÑÏÜç
      }
    }

    console.log("\nüéâ 1) ÎÑìÏùÄ ÌèâÎ≤î Î≤†ÌåÖ 5Í∞ú ÏôÑÎ£å!");

    // 5Í∞ú ÌèâÎ≤î Î≤†ÌåÖ Ïù¥ÌõÑ: ÏïÑÏ£º Ï¢ÅÏùÄ Íµ¨Í∞ÑÏóê ÌÅ∞ Î≤†ÌåÖ Ïú†ÎèÑ (flush Í∞ÄÎä•ÏÑ±)
    const narrowLower = 111500;
    const narrowUpper = 111600; // spacing=100Ïù¥Î©¥ Îã®Ïùº bin
    const narrowQuantity = 1000000; // 1e6 payout
    const narrowMaxCost = parseUnits("500", 6); // ÌÅ∞ Î≤†ÌåÖ ÎπÑÏö© ÏÉÅÌïú
    console.log(
      "\nüí• Ï¢ÅÏùÄ Íµ¨Í∞Ñ ÌÅ∞ Î≤†ÌåÖ Ïã§Ìñâ (flush Ïú†ÎèÑ):",
      narrowLower,
      narrowUpper
    );
    const txNarrow = await core.openPosition(
      marketId,
      narrowLower,
      narrowUpper,
      narrowQuantity,
      narrowMaxCost
    );
    console.log("   Ìä∏ÎûúÏû≠ÏÖò Ìï¥Ïãú:", txNarrow.hash);
    await txNarrow.wait();

    // Ïù¥Ïñ¥ÏÑú ÌèâÎ≤îÌïú Î≤†ÌåÖ 2Í∞ú Îçî
    const tailSegments = [
      { lower: 112000, upper: 112100 },
      { lower: 112100, upper: 112200 },
    ];
    for (const seg of tailSegments) {
      const txT = await core.openPosition(
        marketId,
        seg.lower,
        seg.upper,
        1000000,
        costPerSegment
      );
      console.log("   ÌõÑÏÜç ÌèâÎ≤î Î≤†ÌåÖ tx:", txT.hash);
      await txT.wait();
    }

    console.log("\nüéâ Î™®Îì† Î≤†ÌåÖ ÏãúÎÇòÎ¶¨Ïò§ ÏôÑÎ£å!");
    console.log("\nüìä Î≤†ÌåÖ ÏöîÏïΩ:");
    console.log(`  - ÎßàÏºì ID: ${marketId}`);
    console.log(
      `  - Ï†ÑÏ≤¥ Î≤îÏúÑ: ${startTick.toLocaleString()} ~ ${endTick.toLocaleString()}`
    );
    console.log(`  - ÏÑ∏Í∑∏Î®ºÌä∏ Ïàò: ${results.length}`);
    console.log(
      `  - Ï¥ù Ïã§Ï†ú ÎπÑÏö©: ${ethers.formatUnits(totalActualCost, 6)} USDC`
    );

    console.log("\nüìã Ìè¨ÏßÄÏÖò ÏÉÅÏÑ∏:");
    results.forEach((result, i) => {
      const status = result.positionId === "FAILED" ? "‚ùå Ïã§Ìå®" : "‚úÖ ÏÑ±Í≥µ";
      console.log(
        `  ${i + 1}. Î≤îÏúÑ: ${result.segment}, Ìè¨ÏßÄÏÖò ID: ${
          result.positionId
        }, ÎπÑÏö©: ${result.actualCost} USDC [${status}]`
      );
    });

    // ÏÑ±Í≥µ/Ïã§Ìå® ÌÜµÍ≥Ñ
    const successCount = results.filter(
      (r) => r.positionId !== "FAILED"
    ).length;
    const failCount = results.filter((r) => r.positionId === "FAILED").length;
    console.log(`\nüìà Í≤∞Í≥º: ÏÑ±Í≥µ ${successCount}Í∞ú, Ïã§Ìå® ${failCount}Í∞ú`);
  } catch (error: any) {
    console.error("\n‚ùå Ï¥àÍ∏∞Ìôî Ïã§Ìå®:");
    console.error(`Î©îÏãúÏßÄ: ${error.message}`);

    // ÏûêÏÑ∏Ìïú ÏóêÎü¨ Ï†ïÎ≥¥ Ï∂úÎ†•
    if (error.reason) {
      console.error(`ÏóêÎü¨ Ïù¥Ïú†: ${error.reason}`);
    }

    if (error.code) {
      console.error(`ÏóêÎü¨ ÏΩîÎìú: ${error.code}`);
    }

    if (error.data) {
      console.error(`ÏóêÎü¨ Îç∞Ïù¥ÌÑ∞: ${error.data}`);
    }

    if (error.transaction) {
      console.error(`Ïã§Ìå®Ìïú Ìä∏ÎûúÏû≠ÏÖò:`, error.transaction);
    }

    if (error.receipt) {
      console.error(`Ìä∏ÎûúÏû≠ÏÖò ÏòÅÏàòÏ¶ù:`, error.receipt);
    }

    // Ï†ÑÏ≤¥ ÏóêÎü¨ Í∞ùÏ≤¥ Ï∂úÎ†• (ÎîîÎ≤ÑÍπÖÏö©)
    console.error(`Ï†ÑÏ≤¥ ÏóêÎü¨ Ï†ïÎ≥¥:`, JSON.stringify(error, null, 2));

    throw error;
  }
}

```


## scripts/actions/range-sum.ts

```typescript
import hre from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

// ========================================
// üéØ CONFIGURATION - Ïó¨Í∏∞ÏÑú Í∞íÏùÑ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî
// ========================================
const CONFIG = {
  marketId: 23, // ÎßàÏºì ID
  low: 111000, // ÌïòÌïú tick
  high: 112000, // ÏÉÅÌïú tick
  testAmount: "100", // ÌÖåÏä§Ìä∏Ìï† Î≤†ÌåÖ Í∏àÏï° (SUSD)
};

export async function rangeSumAction(environment: Environment): Promise<void> {
  console.log(`\nüîç Getting Range Sum for ${environment}`);
  console.log(`üìä Market ID: ${CONFIG.marketId}`);
  console.log(`üìâ Range: [${CONFIG.low}, ${CONFIG.high}]`);

  try {
    // Î∞∞Ìè¨Îêú Ï£ºÏÜå Í∞ÄÏ†∏Ïò§Í∏∞
    const addresses = envManager.getDeployedAddresses(environment);
    if (!addresses.CLMSRMarketCoreProxy) {
      throw new Error(`‚ùå CLMSRMarketCoreProxy not deployed on ${environment}`);
    }

    console.log(`üìç Contract Address: ${addresses.CLMSRMarketCoreProxy}`);

    // Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
    const marketCore = await hre.ethers.getContractAt(
      "CLMSRMarketCore",
      addresses.CLMSRMarketCoreProxy
    );

    // ÎßàÏºì Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
    let market;
    try {
      market = await marketCore.getMarket(CONFIG.marketId);
      console.log(`‚úÖ Market found: ${market.name || "Unnamed Market"}`);
      console.log(`üìä Tick Spacing: ${market.tickSpacing}`);
    } catch (error) {
      throw new Error(`‚ùå Market ${CONFIG.marketId} not found`);
    }

    // getRangeSum Ìò∏Ï∂ú
    console.log(
      `\nüîÑ Calling getRangeSum(${CONFIG.marketId}, ${CONFIG.low}, ${CONFIG.high})...`
    );

    const rangeSum = await marketCore.getRangeSum(
      CONFIG.marketId,
      CONFIG.low,
      CONFIG.high
    );

    console.log(`\nüìä Range Sum Results:`);
    console.log(`  Market ID: ${CONFIG.marketId}`);
    console.log(`  Range: [${CONFIG.low}, ${CONFIG.high}]`);
    console.log(`  Sum (Raw): ${rangeSum.toString()}`);
    console.log(`  Sum (Formatted): ${hre.ethers.formatEther(rangeSum)} ETH`);

    // Ï∂îÍ∞Ä Ï†ïÎ≥¥: Íµ¨Í∞Ñ ÎÇ¥ Î™®Îì† tick Í∞íÎì§ Ï°∞Ìöå
    console.log(`\nüîç Individual Tick Values in Range:`);
    const tickSpacing = market.tickSpacing;
    const ticksInRange = [];

    // Íµ¨Í∞Ñ ÎÇ¥ Î™®Îì† tick ÏàòÏßë (tickSpacing Í∞ÑÍ≤©ÏúºÎ°ú)
    for (
      let tick = CONFIG.low;
      tick < CONFIG.high;
      tick += Number(tickSpacing)
    ) {
      ticksInRange.push(tick);
    }

    console.log(`  Total ticks in range: ${ticksInRange.length}`);

    // Ï†ÑÏ≤¥ ÎßàÏºìÏùò Íµ¨Í∞ÑÌï©ÏùÑ ÎØ∏Î¶¨ Í≥ÑÏÇ∞ (Í∞Å tick ÎπÑÏú® Í≥ÑÏÇ∞Ïö©)
    const totalMarketSum = await marketCore.getRangeSum(
      CONFIG.marketId,
      market.minTick,
      market.maxTick
    );

    for (const tick of ticksInRange) {
      try {
        const tickValue = await marketCore.getRangeSum(
          CONFIG.marketId,
          tick,
          tick + Number(tickSpacing)
        );
        const tickValueEth = Number(hre.ethers.formatEther(tickValue));
        const totalMarketSumEth = Number(
          hre.ethers.formatEther(totalMarketSum)
        );
        const tickPercentage = (tickValueEth / totalMarketSumEth) * 100;

        console.log(
          `  Tick ${tick}: ${hre.ethers.formatEther(
            tickValue
          )} ETH (${tickPercentage.toFixed(4)}% of total)`
        );
      } catch (error) {
        console.log(`  Tick ${tick}: ‚ùå Error (${error})`);
      }
    }

    // Price Impact Î∂ÑÏÑù: openCost vs Î∑∞Ìï®Ïàò ÎπÑÍµê
    console.log(`\nüí∞ Price Impact Analysis:`);
    console.log(`üìä Test Amount: ${CONFIG.testAmount} SUSD`);

    try {
      // SUSDÎäî 6 decimalsÏù¥ÎØÄÎ°ú parseUnits ÏÇ¨Ïö©
      const targetCostMicro = hre.ethers.parseUnits(CONFIG.testAmount, 6);

      // 1. calculateQuantityFromCostÎ°ú 100 SUSDÎ°ú ÏÇ¥ Ïàò ÏûàÎäî quantity Í≥ÑÏÇ∞
      const quantityFromCost = await marketCore.calculateQuantityFromCost(
        CONFIG.marketId,
        CONFIG.low,
        CONFIG.high,
        targetCostMicro
      );

      // 2. Í∑∏ quantityÎ°ú Ïã§Ï†ú cost Ïû¨Í≥ÑÏÇ∞
      const actualOpenCost = await marketCore.calculateOpenCost(
        CONFIG.marketId,
        CONFIG.low,
        CONFIG.high,
        quantityFromCost
      );

      console.log(`\nüìà Open Cost Analysis:`);
      console.log(`  Target Cost: ${CONFIG.testAmount} SUSD`);
      console.log(`  Quantity from Cost: ${quantityFromCost.toString()} units`);
      console.log(`  Actual Open Cost (Raw): ${actualOpenCost.toString()}`);
      console.log(
        `  Actual Open Cost: ${hre.ethers.formatUnits(actualOpenCost, 6)} SUSD`
      );

      // 2. Ï†ÑÏ≤¥ Íµ¨Í∞ÑÌï©Í≥º ÎπÑÍµê Í≥ÑÏÇ∞
      // Ï†ÑÏ≤¥ ÎßàÏºìÏùò Íµ¨Í∞ÑÌï©ÏùÑ Íµ¨Ìï¥Ïïº Ìï® (ÎßàÏºì Ï†ÑÏ≤¥ Î≤îÏúÑ)
      const totalRangeSum = await marketCore.getRangeSum(
        CONFIG.marketId,
        market.minTick,
        market.maxTick
      );

      const rangeSize = CONFIG.high - CONFIG.low;
      const totalRangeSize = market.maxTick - market.minTick;

      // 1. Î∂ÑÌè¨Î°úÎ∂ÄÌÑ∞ Ìï¥Îãπ Íµ¨Í∞ÑÏùò ÌôïÎ•† (ÎπÑÏú®)
      const rangeProbability =
        Number(hre.ethers.formatEther(rangeSum)) /
        Number(hre.ethers.formatEther(totalRangeSum));

      // 2. Î∂ÑÌè¨ Í∏∞Î∞ò Ïù¥Î°†Ï†Å ÎπÑÏö© (ÌôïÎ•† * 100Îã¨Îü¨)
      const distributionBasedCost =
        parseFloat(CONFIG.testAmount) * rangeProbability;

      // 3. Ïã§Ï†ú 100Îã¨Îü¨Î°ú Íµ¨Îß§Ïãú ÌèâÍ∑†Í∞ÄÍ≤© Í≥ÑÏÇ∞
      const actualQuantity = Number(quantityFromCost.toString()) / 1e6; // micro units to SUSD units
      const actualAvgPrice = parseFloat(CONFIG.testAmount) / actualQuantity; // 100 SUSD / quantity

      // 4. Î∂ÑÌè¨ Í∏∞Î∞ò ÌèâÍ∑†Í∞ÄÍ≤© Í≥ÑÏÇ∞
      const distributionAvgPrice = rangeSum / totalRangeSum;

      console.log(`\nüìä Range Analysis:`);
      console.log(
        `  Target Range: [${CONFIG.low}, ${CONFIG.high}] (${rangeSize} ticks)`
      );
      console.log(
        `  Total Range: [${market.minTick}, ${market.maxTick}] (${totalRangeSize} ticks)`
      );
      console.log(
        `  Target Range Sum: ${hre.ethers.formatEther(rangeSum)} ETH`
      );
      console.log(
        `  Total Range Sum: ${hre.ethers.formatEther(totalRangeSum)} ETH`
      );
      console.log(
        `  Range Probability: ${(rangeProbability * 100).toFixed(4)}%`
      );
      console.log(
        `  Distribution Based Cost: ${distributionBasedCost.toFixed(6)} SUSD`
      );
      console.log(
        `  Actual Quantity Bought: ${actualQuantity.toFixed(6)} units`
      );
      console.log(
        `  Actual Average Price: ${actualAvgPrice.toFixed(6)} SUSD/unit`
      );
      console.log(
        `  Distribution Average Price: ${distributionAvgPrice.toFixed(
          6
        )} ETH/tick`
      );

      // 5. ÎπÑÏú® ÎåÄ ÎπÑÏú®Î°ú Price Impact Í≥ÑÏÇ∞
      const distributionCostRatio = distributionBasedCost / 100; // Î∂ÑÌè¨ Í∏∞Î∞ò Ïù¥Î°† ÎπÑÏö©

      const priceImpact = (actualAvgPrice / distributionCostRatio) * 100;

      console.log(`\nüéØ Price Impact Analysis (Ratio-based):`);
      console.log(
        `  Actual Cost Ratio: ${actualAvgPrice.toFixed(6)} SUSD (fixed)`
      );
      console.log(
        `  Distribution Cost Ratio: ${distributionCostRatio.toFixed(6)}`
      );
      console.log(`  Price Impact: ${priceImpact.toFixed(2)}%`);
      console.log(
        `  Cost Multiplier: ${(
          actualAvgPrice / distributionCostRatio -
          1
        ).toFixed(2)}x`
      );

      // 6. Îã®ÏúÑ ÌÜµÏùºÌï¥ÏÑú ÌèâÍ∑†Í∞ÄÍ≤© ÎπÑÍµê
      // actualAvgPriceÎäî SUSD/unit, distributionAvgPriceÎäî ETH/tick
      // Îã®ÏúÑÎ•º ÎßûÏ∂∞ÏÑú ÎπÑÍµêÌï¥Ïïº Ìï®
      console.log(`\nüìä Price Analysis:`);
      console.log(`  Actual Avg Price: ${actualAvgPrice.toFixed(6)} SUSD/unit`);
      console.log(
        `  Distribution Avg Price: ${distributionAvgPrice.toFixed(6)} ETH/tick`
      );
      console.log(`  Note: Different units - direct comparison not meaningful`);

      if (priceImpact > 0) {
        console.log(
          `  üìà Cost is ${priceImpact.toFixed(2)}% higher due to price impact`
        );
      } else {
        console.log(
          `  üìâ Cost is ${Math.abs(priceImpact).toFixed(
            2
          )}% lower than linear expectation`
        );
      }
    } catch (error) {
      console.log(`  ‚ùå Error calculating price impact: ${error}`);
    }

    console.log(
      `\n‚úÖ Range sum and price impact analysis completed successfully!`
    );
  } catch (error) {
    console.error(`‚ùå Error getting range sum:`, error);
    throw error;
  }
}

```


## scripts/actions/reopen-market.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

export async function reopenMarketAction(
  environment: Environment
): Promise<void> {
  // üéØ Í∏∞Î≥∏ ÏÑ§Ï†ïÍ∞í (ÌïÑÏöîÏãú ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ïò§Î≤ÑÎùºÏù¥Îìú Í∞ÄÎä•)
  const marketId = parseInt(process.env.MARKET_ID || "24");

  console.log(`üîÑ Reopening market ${marketId} on ${environment}`);

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  console.log("üìã Core Proxy:", addresses.CLMSRMarketCoreProxy);

  // Core Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
  const coreContract = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy
  );

  console.log("üìä Reopen parameters:");
  console.log(`  Market ID: ${marketId}`);

  // ÎßàÏºì ÏÉÅÌÉú ÌôïÏù∏
  try {
    const market = await coreContract.getMarket(marketId);
    if (!market.settled) {
      throw new Error(
        `Market ${marketId} is not settled - cannot reopen unsettled market`
      );
    }
    if (market.isActive) {
      throw new Error(`Market ${marketId} is already active`);
    }
    console.log(`‚úÖ Market ${marketId} is settled and ready for reopen`);
    console.log(`üìà Current settlement tick: ${market.settlementTick}`);
    console.log(`üìà Current settlement value: ${market.settlementValue}`);
    console.log(
      `‚è∞ Start time: ${new Date(
        Number(market.startTimestamp) * 1000
      ).toISOString()}`
    );
    console.log(
      `‚è∞ End time: ${new Date(
        Number(market.endTimestamp) * 1000
      ).toISOString()}`
    );
  } catch (error) {
    throw new Error(`Market validation failed: ${(error as Error).message}`);
  }

  // ÎßàÏºì Ïû¨Ïò§Ìîà
  const tx = await coreContract.reopenMarket(marketId);

  const receipt = await tx.wait();
  console.log("‚úÖ Market reopened successfully!");
  console.log(`üìä Transaction hash: ${receipt?.hash}`);
  console.log(`‚õΩ Gas used: ${receipt?.gasUsed?.toString()}`);

  // Ïû¨Ïò§Ìîà ÌõÑ ÏÉÅÌÉú ÌôïÏù∏
  try {
    const market = await coreContract.getMarket(marketId);
    console.log(
      `üìà Market ${marketId} active after reopen: ${market.isActive}`
    );
    console.log(
      `üìà Market ${marketId} settled after reopen: ${market.settled}`
    );
    console.log(
      `üìà Settlement values reset: tick=${market.settlementTick}, value=${market.settlementValue}`
    );
  } catch (error) {
    console.log("‚ö†Ô∏è  Could not verify market status after reopen");
  }
}

// CLIÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÌï† Îïå ÏÇ¨Ïö©
export async function reopenMarketCLI(environment: Environment): Promise<void> {
  await reopenMarketAction(environment);
}

```


## scripts/actions/set-fee-policy.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

function normalizeAddress(input?: string | null): string | null {
  if (!input) return null;
  const value = input.trim();
  if (value.length === 0) return null;
  if (value === "0" || /^0x0+$/i.test(value)) return ethers.ZeroAddress;
  return ethers.getAddress(value);
}

export async function setFeePolicyAction(
  environment: Environment
): Promise<void> {
  const label = process.env.FEE_POLICY_LABEL?.trim();
  const explicitAddress = normalizeAddress(process.env.FEE_POLICY_ADDRESS);
  const feeRecipientInput = normalizeAddress(process.env.FEE_RECIPIENT);
  const shouldClearRecipient =
    process.env.FEE_RECIPIENT !== undefined &&
    process.env.FEE_RECIPIENT?.trim() === "";

  const coreProxy = envManager.getCoreProxyAddress(environment);
  if (!coreProxy) {
    throw new Error(
      `Core proxy not recorded for ${environment}. Deploy or register it first.`
    );
  }

  let resolvedPolicy = explicitAddress;
  if (!resolvedPolicy && label) {
    resolvedPolicy = envManager.getFeePolicyAddress(environment, label);
    if (!resolvedPolicy) {
      throw new Error(
        `No stored address for fee policy label "${label}" in ${environment}`
      );
    }
  }

  if (!resolvedPolicy && !feeRecipientInput && !shouldClearRecipient) {
    throw new Error(
      "Provide either FEE_POLICY_ADDRESS, FEE_POLICY_LABEL, or FEE_RECIPIENT to update."
    );
  }

  const [signer] = await ethers.getSigners();
  console.log("üë§ Caller:", signer.address);
  console.log("üìã Environment:", environment);
  console.log("üìç Core proxy:", coreProxy);

  const core = await ethers.getContractAt("CLMSRMarketCore", coreProxy);

  if (resolvedPolicy !== null) {
    const policyLabel = label ?? "unknown";
    console.log(
      `üîó Setting fee policy to ${resolvedPolicy} (label: ${policyLabel})`
    );
    const tx = await core.setFeePolicy(resolvedPolicy);
    console.log("   ‚Ä¢ tx:", tx.hash);
    await tx.wait();
    envManager.setActiveFeePolicy(environment, resolvedPolicy, label ?? null);
    console.log("   ‚úÖ Fee policy updated");
  }

  if (feeRecipientInput) {
    console.log(`üîó Setting fee recipient to ${feeRecipientInput}`);
    const tx = await core.setFeeRecipient(feeRecipientInput);
    console.log("   ‚Ä¢ tx:", tx.hash);
    await tx.wait();
    envManager.setFeeRecipient(environment, feeRecipientInput);
    console.log("   ‚úÖ Fee recipient updated");
  } else if (shouldClearRecipient) {
    console.log("üîó Clearing fee recipient (setting to zero address)");
    const tx = await core.setFeeRecipient(ethers.ZeroAddress);
    console.log("   ‚Ä¢ tx:", tx.hash);
    await tx.wait();
    envManager.setFeeRecipient(environment, null);
    console.log("   ‚úÖ Fee recipient cleared");
  }

  console.log("\nüéâ Fee configuration complete!");
  if (resolvedPolicy !== null) {
    console.log("   ‚Ä¢ Active policy:", resolvedPolicy);
  }
  if (label) {
    console.log("   ‚Ä¢ Label:", label);
  }
  if (feeRecipientInput) {
    console.log("   ‚Ä¢ Fee recipient:", feeRecipientInput);
  } else if (shouldClearRecipient) {
    console.log("   ‚Ä¢ Fee recipient cleared");
  }
}

```


## scripts/actions/set-market-active.ts

```typescript
import { ethers as hardhatEthers, network } from "hardhat";
import { ethers, Contract, Wallet, JsonRpcProvider } from "ethers";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";
import * as dotenv from "dotenv";

dotenv.config();

function parseBoolean(value: string | undefined, fallback: boolean): boolean {
  if (value === undefined) return fallback;
  const normalized = value.trim().toLowerCase();
  if (["true", "1", "yes", "y"].includes(normalized)) return true;
  if (["false", "0", "no", "n"].includes(normalized)) return false;
  return fallback;
}

export async function setMarketActiveAction(
  environment: Environment
): Promise<void> {
  // RPC URL (ÌôòÍ≤ΩÎ≥ÄÏàò ÎòêÎäî Í∏∞Î≥∏ Citrea public RPC)
  const pinnedRpcUrl =
    process.env.CITREA_RPC_URL || "https://rpc.testnet.citrea.xyz";

  const privateKey =
    process.env.DEPLOYER_PRIVATE_KEY ?? process.env.PRIVATE_KEY;
  if (!privateKey) {
    throw new Error(
      "DEPLOYER_PRIVATE_KEY (or PRIVATE_KEY) environment variable is required"
    );
  }

  // ÏßÅÏ†ë ethers ProviderÏôÄ Wallet ÏÇ¨Ïö© (ÌïòÎìúÌñá Ïö∞Ìöå)
  const provider = new JsonRpcProvider(pinnedRpcUrl);
  const deployer = new Wallet(privateKey, provider);

  const marketIdInput = process.env.MARKET_ID;
  if (!marketIdInput) {
    throw new Error("MARKET_ID environment variable is required");
  }

  let marketId: bigint;
  try {
    marketId = BigInt(marketIdInput);
    if (marketId < 0n) throw new Error();
  } catch {
    throw new Error(`Invalid MARKET_ID: ${marketIdInput}`);
  }

  const desiredActive = parseBoolean(process.env.ACTIVE, true);
  console.log(
    `üîÅ setMarketActive(marketId=${marketId.toString()}, active=${desiredActive}) on ${environment}`
  );

  console.log("üë§ Caller:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);
  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }
  console.log("üìã Core Proxy:", addresses.CLMSRMarketCoreProxy);

  // ABI Í∞ÄÏ†∏Ïò§Í∏∞ (ÌïòÎìúÌñáÏóêÏÑúÎßå Í∞ÄÎä•) - ÎùºÏù¥Î∏åÎü¨Î¶¨ ÎßÅÌÇπ Ìè¨Ìï®
  const coreArtifact = await hardhatEthers.getContractFactory(
    "CLMSRMarketCore",
    {
      libraries: {
        FixedPointMathU: addresses.FixedPointMathU!,
        LazyMulSegmentTree: addresses.LazyMulSegmentTree!,
      },
    }
  );

  // Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞ (ÏßÅÏ†ë ethers ÏÇ¨Ïö©)
  const core = new Contract(
    addresses.CLMSRMarketCoreProxy,
    coreArtifact.interface,
    deployer
  );

  const market = await core.getMarket(marketId);
  console.log("\nüìä Current Market State:");
  console.log(`  ‚Ä¢ isActive: ${market.isActive}`);
  console.log(`  ‚Ä¢ settled: ${market.settled}`);
  console.log(
    `  ‚Ä¢ trading window: ${new Date(
      Number(market.startTimestamp) * 1000
    ).toISOString()} ‚Üí ${new Date(
      Number(market.endTimestamp) * 1000
    ).toISOString()}`
  );

  if (market.isActive === desiredActive) {
    console.log(
      "\n‚ÑπÔ∏è  Market already in desired activation state. No action taken."
    );
    return;
  }

  if (market.settled && desiredActive) {
    throw new Error(
      `Market ${marketId.toString()} is settled. Use reopenMarket before activating.`
    );
  }

  console.log("\nüöÄ Sending setMarketActive transaction...");
  const tx = await core.setMarketActive(marketId, desiredActive);
  console.log("   ‚Ä¢ tx:", tx.hash);
  const receipt = await tx.wait();
  console.log(
    "   ‚úÖ completed (gas=",
    receipt?.gasUsed?.toString() ?? "N/A",
    ")"
  );

  const updated = await core.getMarket(marketId);
  console.log("\n‚úÖ Updated Market State:");
  console.log(`  ‚Ä¢ isActive: ${updated.isActive}`);
  console.log(`  ‚Ä¢ settled: ${updated.settled}`);
}

```


## scripts/actions/settle-market.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

export async function settleMarketAction(
  environment: Environment
): Promise<void> {
  // üéØ Í∏∞Î≥∏ ÏÑ§Ï†ïÍ∞í (ÌïÑÏöîÏãú ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ïò§Î≤ÑÎùºÏù¥Îìú Í∞ÄÎä•)
  const marketId = parseInt(process.env.MARKET_ID || "24");
  // settlementValueÎäî 6 decimal ÌòïÌÉú (Ïòà: 117.491000 = 117491000)
  const settlementValue = parseInt(
    process.env.SETTLEMENT_VALUE || "121802660000"
  );
  const settlementTick = Math.floor(settlementValue / 1_000_000); // ÌëúÏãúÏö©

  console.log(`‚öñÔ∏è Settling market ${marketId} on ${environment}`);

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  console.log("üìã Core Proxy:", addresses.CLMSRMarketCoreProxy);

  // Core Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
  const coreContract = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy
  );

  console.log("üìä Settlement parameters:");
  console.log(`  Market ID: ${marketId}`);
  console.log(`  Settlement Value: ${settlementValue} (6 decimals)`);
  console.log(`  Settlement Tick: ${settlementTick} (calculated)`);

  // ÎßàÏºì ÏÉÅÌÉú ÌôïÏù∏
  try {
    const market = await coreContract.getMarket(marketId);
    if (!market.isActive) {
      throw new Error(`Market ${marketId} is not active or does not exist`);
    }
    console.log(`‚úÖ Market ${marketId} is active`);
  } catch (error) {
    throw new Error(`Market validation failed: ${(error as Error).message}`);
  }

  // ÎßàÏºì ÏÑ∏ÌãÄ (6 decimal settlementValue ÏÇ¨Ïö©)
  const tx = await coreContract.settleMarket(marketId, settlementValue);

  const receipt = await tx.wait();
  console.log("‚úÖ Market settled successfully!");
  console.log(`üìä Transaction hash: ${receipt?.hash}`);
  console.log(`‚õΩ Gas used: ${receipt?.gasUsed?.toString()}`);

  // ÏÑ∏ÌãÄ ÌõÑ ÏÉÅÌÉú ÌôïÏù∏
  try {
    const market = await coreContract.getMarket(marketId);
    console.log(
      `üìà Market ${marketId} active after settlement: ${market.isActive}`
    );
  } catch (error) {
    console.log("‚ö†Ô∏è  Could not verify market status after settlement");
  }
}

// CLIÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÌï† Îïå ÏÇ¨Ïö©
export async function settleMarketCLI(environment: Environment): Promise<void> {
  await settleMarketAction(environment);
}

```


## scripts/actions/status.ts

```typescript
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

export async function statusAction(environment: Environment): Promise<void> {
  console.log(`üìä Status for ${environment}`);
  envManager.printEnvironmentStatus(environment);
}

```


## scripts/actions/unpause-market.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";

export async function unpauseMarketAction(
  environment: Environment
): Promise<void> {
  console.log(`‚ñ∂Ô∏è Unpausing market contract on ${environment}`);

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  console.log("üìã Core Proxy:", addresses.CLMSRMarketCoreProxy);

  // Core Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
  const coreContract = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy
  );

  // ÌòÑÏû¨ pause ÏÉÅÌÉú ÌôïÏù∏
  const isPaused = await coreContract.isPaused();
  if (!isPaused) {
    console.log("‚úÖ Contract is already active (not paused)");
    return;
  }

  console.log("‚è∏Ô∏è Contract is currently paused");

  // ÎßàÏºì unpause
  console.log("‚ñ∂Ô∏è Unpausing contract...");
  const tx = await coreContract.unpause();

  const receipt = await tx.wait();
  console.log("‚úÖ Contract unpaused successfully!");
  console.log(`üìä Transaction hash: ${receipt?.hash}`);
  console.log(`‚õΩ Gas used: ${receipt?.gasUsed?.toString()}`);

  // Unpause ÌõÑ ÏÉÅÌÉú ÌôïÏù∏
  const isPausedAfter = await coreContract.isPaused();
  console.log(`üîì Contract paused status: ${isPausedAfter}`);
}

// CLIÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÌï† Îïå ÏÇ¨Ïö©
export async function unpauseMarketCLI(environment: Environment): Promise<void> {
  await unpauseMarketAction(environment);
}

```


## scripts/actions/update-market-timing.ts

```typescript
import { ethers } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";
import { safeTxOpts, safeExecuteTx } from "../utils/txOpts";

export async function updateMarketTimingAction(
  environment: Environment
): Promise<void> {
  // ÌïòÎìúÏΩîÎî©Îêú Í∞íÎì§
  const marketId = 24; // Îëê Î≤àÏß∏ ÎßàÏºì
  const newStartTime = "2025-09-06T00:00:00Z"; // 2025ÎÖÑ 8Ïõî 7Ïùº UTC 00:00
  const newEndTime = "2025-09-07T00:00:00Z"; // 2025ÎÖÑ 8Ïõî 8Ïùº UTC 00:00

  console.log(`‚è∞ ÎßàÏºì ${marketId} ÏãúÍ∞Ñ Î≥ÄÍ≤Ω ÏãúÏûë on ${environment}`);

  const [deployer] = await ethers.getSigners();
  console.log("Ìò∏Ï∂úÏûê Ï£ºÏÜå:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  // Ïª®Ìä∏ÎûôÌä∏ Ïó∞Í≤∞
  const core = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy
  );

  // ÏãúÍ∞Ñ ÌååÏã± (ISO 8601 ÌòïÏãù ÏßÄÏõê)
  const newStartTimestamp = Math.floor(new Date(newStartTime).getTime() / 1000);
  const newEndTimestamp = Math.floor(new Date(newEndTime).getTime() / 1000);

  // ÏãúÍ∞Ñ Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
  if (newStartTimestamp >= newEndTimestamp) {
    throw new Error("ÏãúÏûë ÏãúÍ∞ÑÏù¥ Ï¢ÖÎ£å ÏãúÍ∞ÑÎ≥¥Îã§ Îä¶Í±∞ÎÇò Í∞ôÏäµÎãàÎã§");
  }

  const currentTime = Math.floor(Date.now() / 1000);
  if (newEndTimestamp <= currentTime) {
    console.warn("‚ö†Ô∏è Í≤ΩÍ≥†: Ï¢ÖÎ£å ÏãúÍ∞ÑÏù¥ ÌòÑÏû¨ ÏãúÍ∞ÑÎ≥¥Îã§ Ïù¥Î¶ÖÎãàÎã§");
  }

  console.log("\nüìä ÎßàÏºì ÏãúÍ∞Ñ Î≥ÄÍ≤Ω Ï†ïÎ≥¥:");
  console.log("  - ÎßàÏºì ID:", marketId);
  console.log(
    "  - ÏÉàÎ°úÏö¥ ÏãúÏûë ÏãúÍ∞Ñ:",
    new Date(newStartTimestamp * 1000).toISOString()
  );
  console.log(
    "  - ÏÉàÎ°úÏö¥ Ï¢ÖÎ£å ÏãúÍ∞Ñ:",
    new Date(newEndTimestamp * 1000).toISOString()
  );
  console.log("  - ÏãúÏûë ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", newStartTimestamp);
  console.log("  - Ï¢ÖÎ£å ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ:", newEndTimestamp);

  try {
    // Í∏∞Ï°¥ ÎßàÏºì Ï†ïÎ≥¥ ÌôïÏù∏
    const market = await core.getMarket(marketId);
    console.log("\nüìã Í∏∞Ï°¥ ÎßàÏºì Ï†ïÎ≥¥:");
    console.log("  - ÌôúÏÑ± ÏÉÅÌÉú:", market.isActive);
    console.log("  - Ï†ïÏÇ∞ Ïó¨Î∂Ä:", market.settled);
    console.log(
      "  - Í∏∞Ï°¥ ÏãúÏûë ÏãúÍ∞Ñ:",
      new Date(Number(market.startTimestamp) * 1000).toISOString()
    );
    console.log(
      "  - Í∏∞Ï°¥ Ï¢ÖÎ£å ÏãúÍ∞Ñ:",
      new Date(Number(market.endTimestamp) * 1000).toISOString()
    );

    if (market.settled) {
      throw new Error("Ïù¥ÎØ∏ Ï†ïÏÇ∞Îêú ÎßàÏºìÏùò ÏãúÍ∞ÑÏùÄ Î≥ÄÍ≤ΩÌï† Ïàò ÏóÜÏäµÎãàÎã§");
    }

    // ÎßàÏºì ÏãúÍ∞Ñ Î≥ÄÍ≤Ω Ïã§Ìñâ
    console.log("\n‚è∞ ÎßàÏºì ÏãúÍ∞Ñ Î≥ÄÍ≤Ω Ïã§Ìñâ Ï§ë...");

    const tx = await core.updateMarketTiming(
      marketId,
      newStartTimestamp,
      newEndTimestamp
    );

    console.log("‚úÖ ÎßàÏºì ÏãúÍ∞Ñ Î≥ÄÍ≤Ω ÏôÑÎ£å!");
    console.log("Ìä∏ÎûúÏû≠ÏÖò Ìï¥Ïãú:", tx.hash);

    // Î≥ÄÍ≤ΩÎêú ÎßàÏºì Ï†ïÎ≥¥ ÌôïÏù∏
    const updatedMarket = await core.getMarket(marketId);
    console.log("\nüìã Î≥ÄÍ≤ΩÎêú ÎßàÏºì Ï†ïÎ≥¥:");
    console.log(
      "  - ÏÉàÎ°úÏö¥ ÏãúÏûë ÏãúÍ∞Ñ:",
      new Date(Number(updatedMarket.startTimestamp) * 1000).toISOString()
    );
    console.log(
      "  - ÏÉàÎ°úÏö¥ Ï¢ÖÎ£å ÏãúÍ∞Ñ:",
      new Date(Number(updatedMarket.endTimestamp) * 1000).toISOString()
    );
  } catch (error: any) {
    console.error("‚ùå ÎßàÏºì ÏãúÍ∞Ñ Î≥ÄÍ≤Ω Ïã§Ìå®:", error.message);
    throw error;
  }
}

```


## scripts/actions/upgrade.ts

```typescript
import { ethers, upgrades, network } from "hardhat";
import { envManager } from "../utils/environment";
import type { Environment } from "../types/environment";
import { safeTxOptsPinned, delay } from "../utils/txOpts";
import { UpgradeSafetyChecker } from "../safety-checks";
import { OpenZeppelinManifestManager } from "../manage-manifest";

const TX_DELAY_MS = Number(process.env.TX_DELAY_MS ?? "10000");

// RPC URL (ÌôòÍ≤ΩÎ≥ÄÏàò ÎòêÎäî Í∏∞Î≥∏ Citrea public RPC)
const PINNED_RPC_URL = process.env.CITREA_RPC_URL || "https://rpc.testnet.citrea.xyz";

const pinnedProvider = new ethers.JsonRpcProvider(PINNED_RPC_URL);

const DEPLOYER_PRIVATE_KEY =
  process.env.DEPLOYER_PRIVATE_KEY ?? process.env.PRIVATE_KEY;

if (!DEPLOYER_PRIVATE_KEY) {
  throw new Error(
    "DEPLOYER_PRIVATE_KEY (or PRIVATE_KEY) is required to run the upgrade action with a pinned signer."
  );
}

const pinnedDeployer = new ethers.Wallet(DEPLOYER_PRIVATE_KEY, pinnedProvider);

const EXPECTED_CHAIN_ID = BigInt(process.env.EXPECTED_CHAIN_ID ?? "5115");

const EIP1967_IMPLEMENTATION_SLOT =
  "0x360894A13BA1A3210667C828492DB98DCA3E2076CC3735A920A3CA505D382BBC";

/**
 * Citrea ÏãúÌÄÄÏÑú RPC Ïò§Î•ò ÌåêÎ≥Ñ Ìï®Ïàò
 */
function isIgnorableSequencerError(e: any): boolean {
  const msg = String(e?.data || e?.message || e || "");
  return (
    e?.code === -32001 ||
    /SEQUENCER_CLIENT_ERROR/i.test(msg) ||
    /missing field `result\/error`/i.test(msg) ||
    /Parse error/i.test(msg) ||
    /invalid json response|unexpected token|econnreset|etimedout|socket hang up|fetch failed/i.test(
      msg
    )
  );
}

/**
 * Ïû¨ÏãúÎèÑ Î°úÏßÅÏù¥ Ìè¨Ìï®Îêú ÏïàÏ†ÑÌïú Ìï®Ïàò Ïã§Ìñâ
 */
async function withRetry<T>(fn: () => Promise<T>, retries = 3): Promise<T> {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (e) {
      if (!isIgnorableSequencerError(e) || i === retries - 1) throw e;
      console.log(`‚ö†Ô∏è RPC Ïò§Î•ò (${i + 1}/${retries}), Ïû¨ÏãúÎèÑ Ï§ë...`);
      await new Promise((r) => setTimeout(r, 500 * 2 ** i));
    }
  }
  throw new Error("unreachable");
}

/**
 * EIP-1967 Íµ¨ÌòÑÏ≤¥ Ïä¨Î°ØÏùÑ ÏßÅÏ†ë Ï°∞ÌöåÌïòÏó¨ Ï£ºÏÜå Î∞òÌôò
 */
async function getImplementationAddress(proxy: string): Promise<string> {
  const storageReader =
    typeof (pinnedProvider as any).getStorageAt === "function"
      ? (address: string, slot: string) =>
          (pinnedProvider as any).getStorageAt(address, slot)
      : typeof (pinnedProvider as any).getStorage === "function"
      ? (address: string, slot: string) =>
          (pinnedProvider as any).getStorage(address, slot)
      : null;

  if (!storageReader) {
    throw new Error("Pinned provider does not support storage slot reads");
  }

  const rawSlot = await withRetry(() =>
    storageReader(proxy, EIP1967_IMPLEMENTATION_SLOT)
  );

  if (!rawSlot || rawSlot === "0x" || /^0x0+$/.test(rawSlot.toLowerCase())) {
    throw new Error(`Empty implementation slot for proxy ${proxy}`);
  }

  const addressHex = rawSlot.slice(-40);
  try {
    return ethers.getAddress(`0x${addressHex}`);
  } catch (error) {
    throw new Error(
      `Failed to parse implementation slot for proxy ${proxy}: ${rawSlot}`
    );
  }
}

/**
 * ÏóÖÍ∑∏Î†àÏù¥Îìú ÌõÑ Íµ¨ÌòÑÏ≤¥ Ï£ºÏÜåÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÍπåÏßÄ Ìè¥ÎßÅÌïòÏó¨ ÎåÄÍ∏∞
 */
async function waitForImplChange(
  proxy: string,
  prev?: string,
  attempts = 20,
  ms = 1500
): Promise<string> {
  for (let i = 0; i < attempts; i++) {
    try {
      const cur = (await getImplementationAddress(proxy)).toLowerCase();
      if (!prev || cur !== prev.toLowerCase()) {
        console.log(`‚úÖ Implementation changed to: ${cur}`);
        return cur;
      }
      console.log(
        `‚è≥ Waiting for implementation change... (${i + 1}/${attempts})`
      );
      await delay(ms);
    } catch (error: any) {
      const errorMsg = error?.message || String(error);
      if (
        errorMsg.includes("SEQUENCER_CLIENT_ERROR") ||
        errorMsg.includes("nonce too low") ||
        errorMsg.includes("Parse error")
      ) {
        console.log(
          `‚ö†Ô∏è Network error on attempt ${i + 1}/${attempts}, retrying in ${
            ms * 2
          }ms...`
        );
        await delay(ms * 2); // Wait longer for network issues
        continue;
      }

      // For other errors, try a few more times before giving up
      if (i < attempts - 3) {
        console.log(
          `‚ö†Ô∏è Error on attempt ${i + 1}/${attempts}: ${errorMsg}, retrying...`
        );
        await delay(ms);
        continue;
      }

      // If we're near the end and still getting errors, throw
      throw error;
    }
  }

  // ÎßàÏßÄÎßâÏúºÎ°ú Ìïú Î≤à Îçî ÏãúÎèÑ
  try {
    const finalResult = await getImplementationAddress(proxy);
    console.log(`üìã Final implementation address: ${finalResult}`);
    return finalResult;
  } catch (error) {
    console.warn(
      `‚ö†Ô∏è Final attempt failed, but upgrade may have succeeded: ${error}`
    );
    // Í∏∞Î≥∏Í∞í Î∞òÌôò (Ïã§Ï†úÎ°úÎäî ÏóÖÍ∑∏Î†àÏù¥ÎìúÍ∞Ä ÏÑ±Í≥µÌñàÏùÑ Í∞ÄÎä•ÏÑ±)
    return prev || "0x0000000000000000000000000000000000000000";
  }
}

/**
 * ÌîÑÎ°ùÏãúÍ∞Ä Ïã§Ï†úÎ°ú Í∞ÄÎ¶¨ÌÇ§Îäî Íµ¨ÌòÑÏ≤¥ Ï£ºÏÜåÏôÄ env ÌååÏùºÏóê Í∏∞Î°ùÎêú Ï£ºÏÜåÍ∞Ä ÏùºÏπòÌïòÎäîÏßÄ Í≤ÄÏ¶ù
 */
async function verifyImplementationConsistency(
  environment: Environment
): Promise<void> {
  console.log("üîç Verifying implementation consistency...");

  const addresses = envManager.getDeployedAddresses(environment);
  let allMatch = true;

  // Position ÌîÑÎ°ùÏãú Í≤ÄÏ¶ù
  if (addresses.CLMSRPositionProxy && addresses.CLMSRPositionImplementation) {
    const actualPosition = await getImplementationAddress(
      addresses.CLMSRPositionProxy!
    );
    if (
      actualPosition.toLowerCase() !==
      addresses.CLMSRPositionImplementation.toLowerCase()
    ) {
      console.warn("‚ö†Ô∏è Position Implementation mismatch detected.");
      if (process.env.FIX_ENV === "1") {
        envManager.updateContract(
          environment,
          "core",
          "CLMSRPositionImplementation",
          actualPosition
        );
        console.log(
          "üîß Fixed env: core.CLMSRPositionImplementation ->",
          actualPosition
        );
      } else {
        console.error(`‚ùå Position Implementation mismatch:`);
        console.error(`   Proxy points to: ${actualPosition}`);
        console.error(
          `   Env file has:    ${addresses.CLMSRPositionImplementation}`
        );
        console.error(`   üí° Run with FIX_ENV=1 to auto-fix`);
        allMatch = false;
      }
    } else {
      console.log(`‚úÖ Position Implementation consistent: ${actualPosition}`);
    }
  }

  // Core ÌîÑÎ°ùÏãú Í≤ÄÏ¶ù
  if (
    addresses.CLMSRMarketCoreProxy &&
    addresses.CLMSRMarketCoreImplementation
  ) {
    const actualCore = await getImplementationAddress(
      addresses.CLMSRMarketCoreProxy!
    );
    if (
      actualCore.toLowerCase() !==
      addresses.CLMSRMarketCoreImplementation.toLowerCase()
    ) {
      console.warn("‚ö†Ô∏è Core Implementation mismatch detected.");
      if (process.env.FIX_ENV === "1") {
        envManager.updateContract(
          environment,
          "core",
          "CLMSRMarketCoreImplementation",
          actualCore
        );
        console.log(
          "üîß Fixed env: core.CLMSRMarketCoreImplementation ->",
          actualCore
        );
      } else {
        console.error(`‚ùå Core Implementation mismatch:`);
        console.error(`   Proxy points to: ${actualCore}`);
        console.error(
          `   Env file has:    ${addresses.CLMSRMarketCoreImplementation}`
        );
        console.error(`   üí° Run with FIX_ENV=1 to auto-fix`);
        allMatch = false;
      }
    } else {
      console.log(`‚úÖ Core Implementation consistent: ${actualCore}`);
    }
  }

  // Points ÌîÑÎ°ùÏãú Í≤ÄÏ¶ù
  if (addresses.PointsGranterProxy && addresses.PointsGranterImplementation) {
    const actualPoints = await getImplementationAddress(
      addresses.PointsGranterProxy!
    );
    if (
      actualPoints.toLowerCase() !==
      addresses.PointsGranterImplementation.toLowerCase()
    ) {
      console.warn("‚ö†Ô∏è Points Implementation mismatch detected.");
      if (process.env.FIX_ENV === "1") {
        envManager.updateContract(
          environment,
          "points",
          "PointsGranterImplementation",
          actualPoints
        );
        console.log(
          "üîß Fixed env: points.PointsGranterImplementation ->",
          actualPoints
        );
      } else {
        console.error(`‚ùå Points Implementation mismatch:`);
        console.error(`   Proxy points to: ${actualPoints}`);
        console.error(
          `   Env file has:    ${addresses.PointsGranterImplementation}`
        );
        console.error(`   üí° Run with FIX_ENV=1 to auto-fix`);
        allMatch = false;
      }
    } else {
      console.log(`‚úÖ Points Implementation consistent: ${actualPoints}`);
    }
  }

  if (!allMatch) {
    throw new Error(
      "‚ùå Implementation consistency check failed! Proxy addresses do not match env file."
    );
  }

  console.log(
    "‚úÖ All implementation addresses are consistent between proxies and env file."
  );
}

export async function upgradeAction(environment: Environment): Promise<void> {
  console.log(`‚¨ÜÔ∏è Upgrading ${environment} to latest contract`);

  const networkInfo = await pinnedProvider.getNetwork();
  if (networkInfo.chainId !== EXPECTED_CHAIN_ID) {
    throw new Error(
      `Unexpected chainId ${networkInfo.chainId}; expected ${EXPECTED_CHAIN_ID}`
    );
  }

  const deployer = pinnedDeployer;
  console.log("üë§ Deployer:", deployer.address);

  const addresses = envManager.getDeployedAddresses(environment);

  const txOpts = await safeTxOptsPinned(pinnedProvider);

  console.log("üìö Deploying new FixedPointMathU library...");
  const FixedPointMathUFactory = await ethers.getContractFactory(
    "FixedPointMathU",
    { signer: deployer }
  );
  const newFixedPointMathU = await withRetry(
    () => FixedPointMathUFactory.deploy(txOpts),
    5
  );
  await withRetry(() => newFixedPointMathU.waitForDeployment(), 5);
  const newFixedPointMathUAddress = await withRetry(
    () => newFixedPointMathU.getAddress(),
    5
  );
  envManager.updateContract(
    environment,
    "libraries",
    "FixedPointMathU",
    newFixedPointMathUAddress
  );
  addresses.FixedPointMathU = newFixedPointMathUAddress;
  console.log(
    "‚úÖ New FixedPointMathU deployed:",
    newFixedPointMathUAddress
  );

  if (!addresses.CLMSRMarketCoreProxy) {
    throw new Error(`Core proxy not deployed in ${environment} environment`);
  }

  console.log("üìã Core Proxy:", addresses.CLMSRMarketCoreProxy);

  // üõ°Ô∏è ÏïàÏ†ÑÏû•Ïπò Î∞è Îß§ÎãàÌéòÏä§Ìä∏ Í¥ÄÎ¶¨ Ï¥àÍ∏∞Ìôî
  const safetyChecker = new UpgradeSafetyChecker(environment);
  const manifestManager = new OpenZeppelinManifestManager();

  // Îß§ÎãàÌéòÏä§Ìä∏ Î∞±ÏóÖ
  console.log("üíæ Backing up OpenZeppelin manifest...");
  await manifestManager.backup(environment);

  console.log("üîÑ Pre-synchronizing OpenZeppelin manifest...");

  const CLMSRMarketCoreImport = await ethers.getContractFactory(
    "CLMSRMarketCore",
    {
      signer: deployer,
      libraries: {
        FixedPointMathU: addresses.FixedPointMathU!,
        LazyMulSegmentTree: addresses.LazyMulSegmentTree!,
      },
    }
  );

  try {
    await upgrades.forceImport(
      addresses.CLMSRMarketCoreProxy!,
      CLMSRMarketCoreImport,
      { kind: "uups" }
    );
    console.log("‚úÖ Core proxy pre-imported");
  } catch (error) {
    const msg = (error as any)?.message ?? String(error);
    console.warn("‚ö†Ô∏è Core proxy import failed, continuing:", msg);
  }

  // PositionÍ≥º Points forceImport ÏãúÎèÑ
  console.log("üîÑ Attempting Position and Points forceImport...");

  // Position forceImport
  if (addresses.CLMSRPositionProxy) {
    try {
      const CLMSRPosition = await ethers.getContractFactory("CLMSRPosition", {
        signer: deployer,
      });
      await upgrades.forceImport(addresses.CLMSRPositionProxy, CLMSRPosition, {
        kind: "uups",
      });
      console.log("‚úÖ Position proxy force-imported successfully");
    } catch (error) {
      const msg = (error as any)?.message ?? String(error);
      console.warn("‚ö†Ô∏è Position proxy import failed, continuing:", msg);
    }
  }

  // Points forceImport
  if (addresses.PointsGranterProxy) {
    try {
      const PointsGranter = await ethers.getContractFactory("PointsGranter", {
        signer: deployer,
      });
      await upgrades.forceImport(addresses.PointsGranterProxy, PointsGranter, {
        kind: "uups",
      });
      console.log("‚úÖ Points proxy force-imported successfully");
    } catch (error) {
      const msg = (error as any)?.message ?? String(error);
      console.warn("‚ö†Ô∏è Points proxy import failed, continuing:", msg);
    }
  }

  await delay(TX_DELAY_MS);

  console.log("üìù Manifest synchronized with on-chain state");

  // ÏÉà ÎùºÏù¥Î∏åÎü¨Î¶¨ Î∞∞Ìè¨ (FLUSH_THRESHOLD Îì± Ïã†Í∏∞Îä• Ìè¨Ìï®)
  console.log("üìö Deploying new LazyMulSegmentTree library...");
  const LazyMulSegmentTree = await ethers.getContractFactory(
    "LazyMulSegmentTree",
    {
      signer: deployer,
      libraries: { FixedPointMathU: addresses.FixedPointMathU },
    }
  );
  const newSegmentTree = await withRetry(
    () => LazyMulSegmentTree.deploy(txOpts),
    5
  );
  await withRetry(() => newSegmentTree.waitForDeployment(), 5);
  const newSegmentTreeAddress = await withRetry(
    () => newSegmentTree.getAddress(),
    5
  );

  // ÌôòÍ≤Ω ÌååÏùºÏóê ÏÉà ÎùºÏù¥Î∏åÎü¨Î¶¨ Ï£ºÏÜå Ï†ÄÏû•
  envManager.updateContract(
    environment,
    "libraries",
    "LazyMulSegmentTree",
    newSegmentTreeAddress
  );
  console.log("‚úÖ New LazyMulSegmentTree deployed:", newSegmentTreeAddress);
  await delay(TX_DELAY_MS);

  console.log("üè¢ Deploying CLMSRMarketManager implementation...");
  const CLMSRMarketManager = await ethers.getContractFactory(
    "CLMSRMarketManager",
    {
      signer: deployer,
      libraries: {
        LazyMulSegmentTree: newSegmentTreeAddress,
      },
    }
  );
  const managerContract = await withRetry(
    () => CLMSRMarketManager.deploy(txOpts),
    5
  );
  await delay(TX_DELAY_MS);
  await withRetry(() => managerContract.waitForDeployment(), 5);
  const managerAddress = await withRetry(() => managerContract.getAddress(), 5);
  envManager.updateContract(
    environment,
    "core",
    "CLMSRMarketManager",
    managerAddress
  );
  console.log("‚úÖ CLMSRMarketManager deployed:", managerAddress);

  // Position contract ÏóÖÍ∑∏Î†àÏù¥Îìú (ÏïàÏ†ÑÌïú Î∞©Î≤ï)
  console.log("üé≠ Upgrading Position contract...");
  await delay(TX_DELAY_MS);

  let newPositionImplAddress = addresses.CLMSRPositionImplementation;

  if (addresses.CLMSRPositionProxy) {
    try {
      // ÏóÖÍ∑∏Î†àÏù¥Îìú Ïù¥Ï†Ñ Íµ¨ÌòÑÏ≤¥ Ï£ºÏÜåÎ•º Ï†ÄÏû• (RPC Ïû¨ÏãúÎèÑ Ìè¨Ìï®)
      const beforePosImpl = await getImplementationAddress(
        addresses.CLMSRPositionProxy
      );
      console.log("üìã Position impl before upgrade:", beforePosImpl);

      const CLMSRPosition = await ethers.getContractFactory("CLMSRPosition", {
        signer: deployer,
      });

      // upgradeProxy Ìò∏Ï∂ú Ïãú RPC Ïò§Î•ò Ï≤òÎ¶¨ + Ïû¨ÏãúÎèÑ Î≥¥Í∞ï
      await withRetry(async () => {
        try {
          await upgrades.upgradeProxy(
            addresses.CLMSRPositionProxy!,
            CLMSRPosition,
            {
              kind: "uups",
              redeployImplementation: "always",
              txOverrides: await safeTxOptsPinned(pinnedProvider),
            }
          );
          console.log("‚úÖ Position upgradeProxy completed successfully");
        } catch (upgradeError) {
          if (isIgnorableSequencerError(upgradeError)) {
            console.warn(
              "‚ö†Ô∏è RPC ÌååÏã± Ïò§Î•ò Î∞úÏÉùÌñàÏßÄÎßå ÏóÖÍ∑∏Î†àÏù¥ÎìúÎäî ÏÑ±Í≥µÌñàÏùÑ Í∞ÄÎä•ÏÑ± ÎÜíÏùå. Ïò®Ï≤¥Ïù∏ ÏÉÅÌÉúÎ°ú Í≤ÄÏ¶ù ÏßÑÌñâ..."
            );
          } else {
            throw upgradeError;
          }
        }
      }, 5);

      // ÏÉà Íµ¨ÌòÑÏ≤¥ Ï£ºÏÜåÍ∞Ä Î∞òÏòÅÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞(Ìè¥ÎßÅ) - Ïù¥ÎØ∏ withRetry ÎÇ¥Ïû•Îê®
      newPositionImplAddress = await waitForImplChange(
        addresses.CLMSRPositionProxy,
        beforePosImpl
      );
      console.log("üìã Position impl after upgrade:", newPositionImplAddress);

      envManager.updateContract(
        environment,
        "core",
        "CLMSRPositionImplementation",
        newPositionImplAddress
      );
      console.log("‚úÖ Position contract upgraded:", newPositionImplAddress);
    } catch (error) {
      const msg = (error as any)?.message ?? String(error);
      console.warn(
        "‚ö†Ô∏è Position contract upgrade via upgrades.upgradeProxy failed:",
        msg
      );
      console.log(
        "üîÅ Falling back to manual UUPS upgrade flow for Position..."
      );

      // 0) Ïò§ÎÑàÏã≠ ÌôïÏù∏ (UUPS onlyOwner)
      const positionReadonly = await ethers.getContractAt(
        "CLMSRPosition",
        addresses.CLMSRPositionProxy,
        deployer
      );
      const currentOwner = await positionReadonly.owner();
      console.log("üßë‚Äç‚öñÔ∏è Position owner:", currentOwner);
      if (currentOwner.toLowerCase() !== deployer.address.toLowerCase()) {
        throw new Error(
          `‚ùå Position owner is ${currentOwner}, not deployer ${deployer.address}. Use the owner key to upgrade.`
        );
      }

      // 1) ÏÉà Íµ¨ÌòÑ Ïª®Ìä∏ÎûôÌä∏ ÏßÅÏ†ë Î∞∞Ìè¨ (Initializable, no constructor)
      const txOverrides = await safeTxOptsPinned(pinnedProvider);
      const PositionImplFactory = await ethers.getContractFactory(
        "CLMSRPosition",
        { signer: deployer }
      );
      const positionImpl = await PositionImplFactory.deploy(txOverrides);
      await positionImpl.waitForDeployment();
      const manualImplAddr = await positionImpl.getAddress();
      console.log("üì¶ Deployed new Position implementation:", manualImplAddr);

      // 2) proxy.upgradeTo(ÏÉà Íµ¨ÌòÑ) Ìò∏Ï∂ú (UUPS, onlyOwner)
      // ÏóÖÍ∑∏Î†àÏù¥Îìú Ïù¥Ï†Ñ Íµ¨ÌòÑÏ≤¥ Ï£ºÏÜåÎ•º Îã§Ïãú Ìïú Î≤à Ï†ÄÏû• (ÏàòÎèô ÏóÖÍ∑∏Î†àÏù¥Îìú Ï†Ñ)
      const beforeManualPosImpl = await getImplementationAddress(
        addresses.CLMSRPositionProxy!
      );
      // ethers v6ÏóêÏÑú ÏïàÏ†ÑÌïòÍ≤å ÏßÅÏ†ë Ïù∏ÏΩîÎî©ÌïòÏó¨ Ìä∏ÎûúÏû≠ÏÖò Ï†ÑÏÜ°
      try {
        const iface = new ethers.Interface([
          "function upgradeTo(address newImplementation)",
        ]);
        const data = iface.encodeFunctionData("upgradeTo", [manualImplAddr]);
        const upgradeTx = await deployer.sendTransaction({
          to: addresses.CLMSRPositionProxy,
          data,
          ...txOverrides,
        });
        await upgradeTx.wait();
      } catch (e) {
        const msg2 = (e as any)?.message ?? String(e);
        console.warn(
          "‚ö†Ô∏è upgradeTo failed, trying upgradeToAndCall (0x):",
          msg2
        );
        const iface2 = new ethers.Interface([
          "function upgradeToAndCall(address newImplementation, bytes data)",
        ]);
        const data2 = iface2.encodeFunctionData("upgradeToAndCall", [
          manualImplAddr,
          "0x",
        ]);
        const upgradeTx2 = await deployer.sendTransaction({
          to: addresses.CLMSRPositionProxy,
          data: data2,
          ...txOverrides,
        });
        await upgradeTx2.wait();
      }

      // 3) ÏÉà Íµ¨ÌòÑÏ≤¥ Ï£ºÏÜå Î∞òÏòÅ ÌôïÏù∏
      newPositionImplAddress = await waitForImplChange(
        addresses.CLMSRPositionProxy,
        beforeManualPosImpl
      );
      console.log(
        "üìã Position impl after manual upgrade:",
        newPositionImplAddress
      );

      // 4) ÌôòÍ≤Ω ÌååÏùº ÏóÖÎç∞Ïù¥Ìä∏
      envManager.updateContract(
        environment,
        "core",
        "CLMSRPositionImplementation",
        newPositionImplAddress
      );
      console.log(
        "‚úÖ Position contract manually upgraded:",
        newPositionImplAddress
      );
    }
  } else {
    throw new Error(
      `Position proxy not deployed in ${environment} environment`
    );
  }

  // Core contract ÏóÖÍ∑∏Î†àÏù¥Îìú
  console.log("üîß Upgrading Core contract with new library...");
  await delay(TX_DELAY_MS);

  let coreImplAddress = addresses.CLMSRMarketCoreImplementation;

  // ÏóÖÍ∑∏Î†àÏù¥Îìú Ïù¥Ï†Ñ Íµ¨ÌòÑÏ≤¥ Ï£ºÏÜåÎ•º Ï†ÄÏû•
  const beforeCoreImpl = await getImplementationAddress(
    addresses.CLMSRMarketCoreProxy!
  );
  console.log("üìã Core impl before upgrade:", beforeCoreImpl);

  const CLMSRMarketCore = await ethers.getContractFactory("CLMSRMarketCore", {
    signer: deployer,
    libraries: {
      FixedPointMathU: addresses.FixedPointMathU,
      LazyMulSegmentTree: newSegmentTreeAddress,
    },
  });

  try {
    await withRetry(async () => {
      try {
        await upgrades.upgradeProxy(
          addresses.CLMSRMarketCoreProxy!,
          CLMSRMarketCore,
          {
            kind: "uups",
            redeployImplementation: "always",
            unsafeAllow: ["external-library-linking", "delegatecall"],
            txOverrides: await safeTxOptsPinned(pinnedProvider),
          }
        );
        console.log("‚úÖ Core upgradeProxy completed successfully");
      } catch (upgradeError) {
        if (isIgnorableSequencerError(upgradeError)) {
          console.warn(
            "‚ö†Ô∏è RPC ÌååÏã± Ïò§Î•ò Î∞úÏÉùÌñàÏßÄÎßå ÏóÖÍ∑∏Î†àÏù¥ÎìúÎäî ÏÑ±Í≥µÌñàÏùÑ Í∞ÄÎä•ÏÑ± ÎÜíÏùå. Ïò®Ï≤¥Ïù∏ ÏÉÅÌÉúÎ°ú Í≤ÄÏ¶ù ÏßÑÌñâ..."
          );
        } else {
          throw upgradeError;
        }
      }
    }, 5);

    coreImplAddress = await waitForImplChange(
      addresses.CLMSRMarketCoreProxy!,
      beforeCoreImpl
    );
    console.log("üìã Core impl after upgrade:", coreImplAddress);

    envManager.updateContract(
      environment,
      "core",
      "CLMSRMarketCoreImplementation",
      coreImplAddress
    );
    console.log("‚úÖ Core contract upgraded:", coreImplAddress);
  } catch (error) {
    const msg = (error as any)?.message ?? String(error);
    console.warn(
      "‚ö†Ô∏è Core contract upgrade via upgrades.upgradeProxy failed:",
      msg
    );
    console.log("üîÅ Falling back to manual UUPS upgrade flow for Core...");

    const coreReadonly = await ethers.getContractAt(
      "CLMSRMarketCore",
      addresses.CLMSRMarketCoreProxy!,
      deployer
    );
    const currentOwner = await coreReadonly.owner();
    console.log("üßë‚Äç‚öñÔ∏è Core owner:", currentOwner);
    if (currentOwner.toLowerCase() !== deployer.address.toLowerCase()) {
      throw new Error(
        `‚ùå Core owner is ${currentOwner}, not deployer ${deployer.address}. Use the owner key to upgrade.`
      );
    }

    const deployOverrides = await safeTxOptsPinned(pinnedProvider);
    const coreImpl = await CLMSRMarketCore.deploy(deployOverrides);
    await coreImpl.waitForDeployment();
    const manualImplAddr = await coreImpl.getAddress();
    console.log("üì¶ Deployed new Core implementation:", manualImplAddr);

    const beforeManualCoreImpl = await getImplementationAddress(
      addresses.CLMSRMarketCoreProxy!
    );

    const upgradeOverrides = await safeTxOptsPinned(pinnedProvider);
    try {
      const iface = new ethers.Interface([
        "function upgradeTo(address newImplementation)",
      ]);
      const data = iface.encodeFunctionData("upgradeTo", [manualImplAddr]);
      const tx = await deployer.sendTransaction({
        to: addresses.CLMSRMarketCoreProxy!,
        data,
        ...upgradeOverrides,
      });
      await tx.wait();
    } catch (e) {
      const msg2 = (e as any)?.message ?? String(e);
      console.warn("‚ö†Ô∏è upgradeTo failed, trying upgradeToAndCall (0x):", msg2);
      const iface2 = new ethers.Interface([
        "function upgradeToAndCall(address newImplementation, bytes data)",
      ]);
      const data2 = iface2.encodeFunctionData("upgradeToAndCall", [
        manualImplAddr,
        "0x",
      ]);
      const tx2 = await deployer.sendTransaction({
        to: addresses.CLMSRMarketCoreProxy!,
        data: data2,
        ...upgradeOverrides,
      });
      await tx2.wait();
    }

    coreImplAddress = await waitForImplChange(
      addresses.CLMSRMarketCoreProxy!,
      beforeManualCoreImpl
    );
    console.log("üìã Core impl after manual upgrade:", coreImplAddress);

    envManager.updateContract(
      environment,
      "core",
      "CLMSRMarketCoreImplementation",
      coreImplAddress
    );
    console.log("‚úÖ Core contract manually upgraded:", coreImplAddress);
  }

  console.log("‚öôÔ∏è Setting manager pointer on upgraded core...");
  const coreProxy = await ethers.getContractAt(
    "CLMSRMarketCore",
    addresses.CLMSRMarketCoreProxy!,
    deployer
  );
  await withRetry(
    async () =>
      coreProxy.setManager(
        managerAddress,
        await safeTxOptsPinned(pinnedProvider)
      ),
    5
  );
  console.log("‚úÖ Manager pointer updated to:", managerAddress);

  // PointsGranter ÏóÖÍ∑∏Î†àÏù¥Îìú (ÏïàÏ†ÑÌïú Î∞©Î≤ï)
  console.log("üéØ Upgrading PointsGranter...");
  await delay(TX_DELAY_MS);

  let pointsImplAddress = addresses.PointsGranterImplementation;
  const pointsProxyAddress = addresses.PointsGranterProxy;

  if (addresses.PointsGranterProxy) {
    const PointsGranterFactory = await ethers.getContractFactory(
      "PointsGranter",
      { signer: deployer }
    );
    try {
      const beforePointsImpl = await getImplementationAddress(
        addresses.PointsGranterProxy!
      );
      console.log("üìã Points impl before upgrade:", beforePointsImpl);

      await withRetry(async () => {
        try {
          await upgrades.upgradeProxy(
            addresses.PointsGranterProxy!,
            PointsGranterFactory,
            {
              kind: "uups",
              redeployImplementation: "always",
              txOverrides: await safeTxOptsPinned(pinnedProvider),
            }
          );
          console.log("‚úÖ Points upgradeProxy completed successfully");
        } catch (upgradeError) {
          if (isIgnorableSequencerError(upgradeError)) {
            console.warn(
              "‚ö†Ô∏è RPC ÌååÏã± Ïò§Î•ò Î∞úÏÉùÌñàÏßÄÎßå ÏóÖÍ∑∏Î†àÏù¥ÎìúÎäî ÏÑ±Í≥µÌñàÏùÑ Í∞ÄÎä•ÏÑ± ÎÜíÏùå. Ïò®Ï≤¥Ïù∏ ÏÉÅÌÉúÎ°ú Í≤ÄÏ¶ù ÏßÑÌñâ..."
            );
          } else {
            throw upgradeError;
          }
        }
      }, 5);

      pointsImplAddress = await waitForImplChange(
        pointsProxyAddress!,
        beforePointsImpl
      );
      console.log("üìã Points impl after upgrade:", pointsImplAddress);

      envManager.updateContract(
        environment,
        "points",
        "PointsGranterImplementation",
        pointsImplAddress
      );
      console.log("‚úÖ PointsGranter upgraded:", pointsImplAddress);
    } catch (error) {
      const msg = (error as any)?.message ?? String(error);
      console.warn(
        "‚ö†Ô∏è PointsGranter upgrade via upgrades.upgradeProxy failed:",
        msg
      );
      console.log("üîÅ Falling back to manual UUPS upgrade flow for Points...");

      const pointsReadonly = await ethers.getContractAt(
        "PointsGranter",
        addresses.PointsGranterProxy!,
        deployer
      );
      const currentOwner = await pointsReadonly.owner();
      console.log("üßë‚Äç‚öñÔ∏è Points owner:", currentOwner);
      if (currentOwner.toLowerCase() !== deployer.address.toLowerCase()) {
        throw new Error(
          `‚ùå Points owner is ${currentOwner}, not deployer ${deployer.address}. Use the owner key to upgrade.`
        );
      }

      const deployOverrides = await safeTxOptsPinned(pinnedProvider);
      const pointsImpl = await PointsGranterFactory.deploy(deployOverrides);
      await pointsImpl.waitForDeployment();
      const manualImplAddr = await pointsImpl.getAddress();
      console.log("üì¶ Deployed new Points implementation:", manualImplAddr);

      const beforeManualPointsImpl = await getImplementationAddress(
        addresses.PointsGranterProxy!
      );

      const upgradeOverrides = await safeTxOptsPinned(pinnedProvider);
      try {
        const iface = new ethers.Interface([
          "function upgradeTo(address newImplementation)",
        ]);
        const data = iface.encodeFunctionData("upgradeTo", [manualImplAddr]);
        const tx = await deployer.sendTransaction({
          to: addresses.PointsGranterProxy!,
          data,
          ...upgradeOverrides,
        });
        await tx.wait();
      } catch (e) {
        const msg2 = (e as any)?.message ?? String(e);
        console.warn(
          "‚ö†Ô∏è upgradeTo failed, trying upgradeToAndCall (0x):",
          msg2
        );
        const iface2 = new ethers.Interface([
          "function upgradeToAndCall(address newImplementation, bytes data)",
        ]);
        const data2 = iface2.encodeFunctionData("upgradeToAndCall", [
          manualImplAddr,
          "0x",
        ]);
        const tx2 = await deployer.sendTransaction({
          to: addresses.PointsGranterProxy!,
          data: data2,
          ...upgradeOverrides,
        });
        await tx2.wait();
      }

      pointsImplAddress = await waitForImplChange(
        pointsProxyAddress!,
        beforeManualPointsImpl
      );
      console.log("üìã Points impl after manual upgrade:", pointsImplAddress);

      envManager.updateContract(
        environment,
        "points",
        "PointsGranterImplementation",
        pointsImplAddress
      );
      console.log("‚úÖ PointsGranter manually upgraded:", pointsImplAddress);
    }
  } else {
    throw new Error(
      `PointsGranter proxy not deployed in ${environment} environment`
    );
  }

  // ÏóÖÍ∑∏Î†àÏù¥Îìú Í∏∞Î°ù Ï†ÄÏû•
  const nextVersion = envManager.getNextVersion(environment);
  envManager.addDeploymentRecord(environment, {
    version: nextVersion, // ÏûêÎèô Î≤ÑÏ†Ñ Ï¶ùÍ∞Ä
    action: "upgrade",
    contracts: {
      LazyMulSegmentTree: newSegmentTreeAddress,
      CLMSRPositionImplementation: newPositionImplAddress,
      CLMSRMarketCoreImplementation: coreImplAddress,
      CLMSRMarketManager: managerAddress,
      PointsGranterProxy: pointsProxyAddress,
      PointsGranterImplementation: pointsImplAddress,
    },
    deployer: deployer.address,
  });

  // ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù: ÌîÑÎ°ùÏãúÍ∞Ä Ïã§Ï†úÎ°ú Í∞ÄÎ¶¨ÌÇ§Îäî Íµ¨ÌòÑÏ≤¥ Ï£ºÏÜå ÌôïÏù∏
  await verifyImplementationConsistency(environment);

  console.log("üéâ Upgrade completed successfully!");
  envManager.printEnvironmentStatus(environment);
}

```


## scripts/seeding/create-and-seed.ts

```typescript
import { ethers } from "hardhat";
import {
  AbiCoder,
  formatUnits,
  keccak256,
  parseEther,
} from "ethers";
import { generatePrior } from "../../engine/prior";
import type { PriorResult } from "../../engine/prior";
import { verifyDistribution } from "./verify";
import { getCoreProxy } from "../utils/environment";
import type { Environment } from "../types/environment";

const VALID_ENVIRONMENTS: readonly Environment[] = [
  "localhost",
  "citrea-dev",
  "citrea-prod",
];

function resolveEnvironment(defaultEnv: Environment): Environment {
  const env =
    process.env.TARGET_ENV ?? process.env.ENVIRONMENT ?? process.env.ENV;
  if (env && VALID_ENVIRONMENTS.includes(env as Environment)) {
    return env as Environment;
  }
  return defaultEnv;
}

function resolveChunkSize(defaultSize: number): number {
  const raw = process.env.BATCH_CHUNK_SIZE;
  if (!raw) return defaultSize;
  const parsed = Number(raw);
  return Number.isFinite(parsed) && parsed > 0
    ? Math.floor(parsed)
    : defaultSize;
}

const NOW = Math.floor(Date.now() / 1000);
const START_BUFFER_SECONDS = 6 * 60 * 60; // start ~6 hours from now
const MARKET_DURATION_SECONDS = 36 * 60 * 60; // keep market open for ~36 hours
const SETTLEMENT_DELAY_SECONDS = 6 * 60 * 60; // settle 6 hours after close

const CONFIG = {
  environment: resolveEnvironment("localhost"),
  market: {
    minTick: 100_000,
    maxTick: 140_000,
    tickSpacing: 100,
    startTimestamp: NOW + START_BUFFER_SECONDS,
    endTimestamp: NOW + START_BUFFER_SECONDS + MARKET_DURATION_SECONDS,
    settlementTimestamp:
      NOW +
      START_BUFFER_SECONDS +
      MARKET_DURATION_SECONDS +
      SETTLEMENT_DELAY_SECONDS,
    alpha: "10000",
  },
  prior: {
    anchor: 114_640,
    atr: 3768.37 * 0.5,
    nu: 9,
    epsilon: 0.02,
    kappa: 400,
    mode: "logReturn" as const,
  },
  verification: {
    enabled: true,
    tolerance: 1e-6,
  },
  batching: {
    chunkSize: resolveChunkSize(70),
  },
};

function printPrior(prior: PriorResult) {
  const abi = AbiCoder.defaultAbiCoder();
  console.log("\nüßÆ Prior Factors (index | tick | weight | factorWad)");
  prior.weights.forEach((weight, idx) => {
    const tick = CONFIG.market.minTick + idx * CONFIG.market.tickSpacing;
    const factor = prior.factorWad[idx];
    console.log(
      `${idx.toString().padStart(3, "0")} | ${tick
        .toString()
        .padStart(6, "0")} | ${weight.toFixed(12)} | ${factor.toString()}`
    );
  });
  const seedHash = keccak256(abi.encode(["uint256[]"], [prior.factorWad]));
  console.log("\nüßæ Expected seed hash:", seedHash);
}

async function main() {
  const { environment, market, prior: priorCfg, verification } = CONFIG;

  console.log("üéØ Environment:", environment);

  const prior = generatePrior({
    minTick: market.minTick,
    maxTick: market.maxTick,
    tickSpacing: market.tickSpacing,
    anchorPrice: priorCfg.anchor,
    atr: priorCfg.atr,
    nu: priorCfg.nu,
    epsilon: priorCfg.epsilon,
    kappa: priorCfg.kappa,
    mode: priorCfg.mode,
  });

  console.log("üìä Prior metrics:");
  console.log("  - Num bins:", prior.numBins);
  console.log(
    "  - Factor range:",
    prior.metrics.minFactor.toFixed(6),
    "‚Üí",
    prior.metrics.maxFactor.toFixed(6)
  );
  console.log("  - Entropy:", prior.metrics.entropy.toFixed(6));
  console.log("  - Effective bins:", prior.metrics.effectiveBins.toFixed(2));
  console.log(
    "  - Max loss coeff:",
    prior.metrics.maxLossCoefficient.toFixed(4)
  );

  printPrior(prior);

  const coreAddress = getCoreProxy(environment);
  const core = await ethers.getContractAt("CLMSRMarketCore", coreAddress);
  const owner = await core.owner();
  const signers = await ethers.getSigners();
  const ownerSigner =
    signers.find((s) => s.address.toLowerCase() === owner.toLowerCase()) ??
    signers[0];
  const coreWithOwner = core.connect(ownerSigner);

  const params = {
    minTick: market.minTick,
    maxTick: market.maxTick,
    tickSpacing: market.tickSpacing,
    startTimestamp: market.startTimestamp,
    endTimestamp: market.endTimestamp,
    settlementTimestamp: market.settlementTimestamp,
    liquidityParameter: parseEther(market.alpha),
    feePolicy: market.feePolicy ?? ethers.ZeroAddress,
  };

  const seedHash = keccak256(
    AbiCoder.defaultAbiCoder().encode(["uint256[]"], [prior.factorWad])
  );

  console.log("\nüßæ Seed hash:", seedHash);

  const expectedMarketId = await coreWithOwner.createMarket.staticCall(
    params.minTick,
    params.maxTick,
    params.tickSpacing,
    params.startTimestamp,
    params.endTimestamp,
    params.settlementTimestamp,
    params.liquidityParameter,
    params.feePolicy
  );

  const createTx = await coreWithOwner.createMarket(
    params.minTick,
    params.maxTick,
    params.tickSpacing,
    params.startTimestamp,
    params.endTimestamp,
    params.settlementTimestamp,
    params.liquidityParameter,
    params.feePolicy
  );
  console.log("‚è≥ Creating market...", createTx.hash);
  const createReceipt = await createTx.wait();
  console.log(
    "‚úÖ Market created (gas=",
    createReceipt?.gasUsed?.toString() ?? "N/A",
    ")"
  );

  const marketId = Number(expectedMarketId);
  console.log("üÜî Market ID:", marketId);

  const totalBins = prior.factorWad.length;
  const chunkSize = CONFIG.batching.chunkSize;
  const minTickBig = BigInt(market.minTick);
  const spacingBig = BigInt(market.tickSpacing);

  for (let offset = 0; offset < totalBins; offset += chunkSize) {
    const end = Math.min(offset + chunkSize, totalBins);
    const lowers: bigint[] = [];
    const uppers: bigint[] = [];
    const factors: bigint[] = [];

    for (let i = offset; i < end; i++) {
      const lower = minTickBig + spacingBig * BigInt(i);
      lowers.push(lower);
      uppers.push(lower + spacingBig);
      factors.push(prior.factorWad[i]);
    }

    const tx = await coreWithOwner.applyRangeFactorBatch(
      marketId,
      lowers,
      uppers,
      factors,
      seedHash
    );
    console.log(
      `‚è≥ Applying factors [${offset}, ${end - 1}]...`,
      tx.hash
    );
    const receipt = await tx.wait();
    console.log(
      "‚úÖ Batch applied (gas=",
      receipt?.gasUsed?.toString() ?? "N/A",
      ")"
    );

    const batchLog = receipt?.logs
      ?.map((log) => {
        try {
          return core.interface.parseLog({ topics: log.topics, data: log.data });
        } catch (err) {
          return null;
        }
      })
      .find((parsed) => parsed && parsed.name === "RangeFactorBatchApplied");

    if (batchLog) {
      console.log(
        "   Batch context:",
        `count=${batchLog.args[1]} context=${batchLog.args[2]}`
      );
    }
  }

  if (verification.enabled) {
    console.log("\nüîç Verifying on-chain distribution...");
    const verificationResult = await verifyDistribution(
      core,
      marketId,
      prior,
      verification.tolerance
    );

    console.log(
      `  RMSE: ${verificationResult.rmse.toExponential(
        6
      )}, MAE: ${verificationResult.mae.toExponential(6)}, max error: ${verificationResult.maxError.toExponential(
        6
      )}`
    );
    console.log(
      "  Total weight:",
      verificationResult.report.totalWeight.toFixed(6)
    );
  } else {
    console.log("‚ö†Ô∏è Verification skipped (disabled in CONFIG).");
  }

  const autoActivate = process.env.ACTIVATE_AFTER_SEED === "true";

  if (autoActivate) {
    console.log("\nüîì ACTIVATE_AFTER_SEED=true -> ÎßàÏºì ÌôúÏÑ±Ìôî ÏßÑÌñâ...");
    const activateTx = await coreWithOwner.setMarketActive(
      BigInt(marketId),
      true
    );
    console.log("   ‚Ä¢ tx:", activateTx.hash);
    const activateReceipt = await activateTx.wait();
    console.log(
      "   ‚úÖ ÌôúÏÑ±Ìôî ÏôÑÎ£å (gas=",
      activateReceipt?.gasUsed?.toString() ?? "N/A",
      ")"
    );
  } else {
    console.log(
      "\n‚ö†Ô∏è ÏÉà ÎßàÏºìÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎπÑÌôúÏÑ± ÏÉÅÌÉúÏûÖÎãàÎã§. Í≤ÄÏ¶ù ÌõÑ ÏïÑÎûò Î™ÖÎ†πÏñ¥Î°ú Í∞úÏû•ÌïòÏÑ∏Ïöî:"
    );
    console.log(
      `   COMMAND=set-market-active:${environment} MARKET_ID=${marketId} ACTIVE=true npx hardhat run scripts/dispatcher.ts --network ${environment}`
    );
  }

  console.log("\nüéâ Market creation + seeding complete!");
  console.log(
    "  Liquidity parameter (Œ±):",
    formatUnits(params.liquidityParameter, 18)
  );
}

main().catch((error) => {
  console.error("‚ùå create-and-seed failed:", error);
  process.exitCode = 1;
});

```


## scripts/seeding/verify.ts

```typescript
import { ethers } from "hardhat";
import { formatUnits } from "ethers";
import { generatePrior } from "../../engine/prior";
import type { PriorResult } from "../../engine/prior";
import { getCoreProxy } from "../utils/environment";
import type { Environment } from "../types/environment";
import type { CLMSRMarketCore } from "../../typechain-types";

export interface DistributionReport {
  probabilities: number[];
  weights: number[];
  totalWeight: number;
}

export interface VerificationResult {
  rmse: number;
  mae: number;
  maxError: number;
  report: DistributionReport;
}

async function readDistribution(
  core: CLMSRMarketCore,
  marketId: bigint
): Promise<DistributionReport> {
  const market = await core.getMarket(marketId);
  const numBins = Number(market.numBins);
  if (numBins <= 0) {
    throw new Error(`Market ${marketId} has no bins`);
  }

  const minTick = Number(market.minTick);
  const tickSpacing = Number(market.tickSpacing);
  const maxTick = Number(market.maxTick);

  const totalRaw = await core.getRangeSum(marketId, minTick, maxTick);
  const totalWeight = parseFloat(formatUnits(totalRaw, 18));

  const weights: number[] = [];
  const probabilities: number[] = [];

  for (let i = 0; i < numBins; i++) {
    const lowerTick = minTick + i * tickSpacing;
    const upperTick = lowerTick + tickSpacing;
    const binRaw = await core.getRangeSum(marketId, lowerTick, upperTick);
    const binWeight = parseFloat(formatUnits(binRaw, 18));
    weights.push(binWeight);
    probabilities.push(binWeight / totalWeight);
  }

  return { probabilities, weights, totalWeight };
}

export async function verifyDistribution(
  core: CLMSRMarketCore,
  marketId: number,
  prior: PriorResult,
  tolerance = 1e-6
): Promise<VerificationResult> {
  const distribution = await readDistribution(core, BigInt(marketId));

  if (distribution.probabilities.length !== prior.blendedPrior.length) {
    throw new Error(
      `Bin length mismatch: on-chain=${distribution.probabilities.length}, prior=${prior.blendedPrior.length}`
    );
  }

  let mae = 0;
  let mse = 0;
  let maxError = 0;

  for (let i = 0; i < distribution.probabilities.length; i++) {
    const diff = distribution.probabilities[i] - prior.blendedPrior[i];
    const absDiff = Math.abs(diff);
    mae += absDiff;
    mse += diff * diff;
    if (absDiff > maxError) {
      maxError = absDiff;
    }
  }

  mae /= distribution.probabilities.length;
  mse /= distribution.probabilities.length;

  if (maxError > tolerance) {
    throw new Error(
      `Verification failed: max error ${maxError.toExponential(
        6
      )} exceeds tolerance ${tolerance}`
    );
  }

  return {
    rmse: Math.sqrt(mse),
    mae,
    maxError,
    report: distribution,
  };
}

// CLI execution
const VALID_ENVIRONMENTS: readonly Environment[] = [
  "localhost",
  "citrea-dev",
  "citrea-prod",
];

function resolveEnvironment(defaultEnv: Environment): Environment {
  const env =
    process.env.TARGET_ENV ?? process.env.ENVIRONMENT ?? process.env.ENV;
  if (env && VALID_ENVIRONMENTS.includes(env as Environment)) {
    return env as Environment;
  }
  return defaultEnv;
}

function resolveMarketId(defaultMarketId: number): number {
  const raw = process.env.MARKET_ID;
  if (!raw) return defaultMarketId;
  const parsed = Number(raw);
  return Number.isFinite(parsed) && parsed >= 0
    ? Math.floor(parsed)
    : defaultMarketId;
}

function resolveTolerance(defaultTolerance: number): number {
  const raw = process.env.VERIFY_TOLERANCE;
  if (!raw) return defaultTolerance;
  const parsed = Number(raw);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : defaultTolerance;
}

const CONFIG = {
  environment: resolveEnvironment("localhost"),
  marketId: resolveMarketId(1),
  market: {
    minTick: 100_000,
    maxTick: 140_000,
    tickSpacing: 100,
  },
  prior: {
    anchor: 114_640,
    atr: 3768.37 * 0.5,
    nu: 9,
    epsilon: 0.02,
    kappa: 400,
    mode: "logReturn" as const,
  },
  tolerance: resolveTolerance(1e-6),
};

async function main() {
  const { environment, marketId, market, prior: priorCfg, tolerance } = CONFIG;

  const prior = generatePrior({
    minTick: market.minTick,
    maxTick: market.maxTick,
    tickSpacing: market.tickSpacing,
    anchorPrice: priorCfg.anchor,
    atr: priorCfg.atr,
    nu: priorCfg.nu,
    epsilon: priorCfg.epsilon,
    kappa: priorCfg.kappa,
    mode: priorCfg.mode,
  });

  console.log("üîé Verifying market", marketId, "on", environment);
  console.log("  Config bins:", prior.numBins);

  const core = await ethers.getContractAt(
    "CLMSRMarketCore",
    getCoreProxy(environment)
  );

  const verification = await verifyDistribution(
    core,
    marketId,
    prior,
    tolerance
  );

  console.log(
    `‚úÖ Verification succeeded. RMSE=${verification.rmse.toExponential(
      6
    )}, MAE=${verification.mae.toExponential(
      6
    )}, max error=${verification.maxError.toExponential(6)}`
  );
  console.log("   Total weight:", verification.report.totalWeight.toFixed(6));
}

if (require.main === module) {
  main().catch((error) => {
    console.error("‚ùå verify-seeding failed:", error);
    process.exitCode = 1;
  });
}

```


## scripts/dispatcher.ts

```typescript
/**
 * üéØ Command Dispatcher
 * Î™®Îì† Ïä§ÌÅ¨Î¶ΩÌä∏ Î™ÖÎ†πÏñ¥Î•º Ï§ëÏïôÏóêÏÑú Í¥ÄÎ¶¨ÌïòÎäî ÎîîÏä§Ìå®Ï≤ò
 */

import { Environment } from "./types/environment";

const COMMAND = process.env.COMMAND;

if (!COMMAND) {
  console.error("‚ùå COMMAND environment variable is required");
  console.log(`
üéØ Available Commands:
  
üì¶ Deploy Commands:
  deploy:localhost          - Deploy to localhost
  deploy:citrea:dev         - Deploy to citrea dev
  deploy:citrea:prod        - Deploy to citrea prod
  deploy-fee-policy:ENV     - Deploy a fee policy contract (Null/Custom)

‚¨ÜÔ∏è Upgrade Commands:
  upgrade:localhost         - Upgrade localhost contracts
  upgrade:citrea:dev        - Upgrade citrea dev contracts
  upgrade:citrea:prod       - Upgrade citrea prod contracts

üí∏ Fee Policy Commands:
  set-fee-policy:ENV        - Configure core fee policy / recipient

üè™ Market Commands:
  create-market:localhost   - Create market on localhost
  create-market:citrea:dev  - Create market on citrea dev
  create-market:citrea:prod - Create market on citrea prod
  set-market-active:ENV     - Toggle activation (MARKET_ID, ACTIVE env vars)
  activate-market:ENV       - Alias for set-market-active with ACTIVE=true
  deactivate-market:ENV     - Alias for set-market-active with ACTIVE=false
  
üèÅ Settlement Commands:
  settle-market:localhost   - Settle market on localhost
  settle-market:citrea:dev  - Settle market on citrea dev
  settle-market:citrea:prod - Settle market on citrea prod
  
üö´ Market Close Commands:
  close-market:localhost    - Close market on localhost (stops trading)
  close-market:citrea:dev   - Close market on citrea dev (stops trading)
  close-market:citrea:prod  - Close market on citrea prod (stops trading)
  
üîÑ Market Reopen Commands:
  reopen-market:localhost   - Reopen settled market on localhost
  reopen-market:citrea:dev  - Reopen settled market on citrea dev
  reopen-market:citrea:prod - Reopen settled market on citrea prod
  
‚è∏Ô∏è Market Pause Commands:
  pause-market:localhost    - Pause market contract on localhost
  pause-market:citrea:dev   - Pause market contract on citrea dev
  pause-market:citrea:prod  - Pause market contract on citrea prod
  
‚ñ∂Ô∏è Market Unpause Commands:
  unpause-market:localhost  - Unpause market contract on localhost
  unpause-market:citrea:dev - Unpause market contract on citrea dev
  unpause-market:citrea:prod- Unpause market contract on citrea prod
  
üì¢ Position Events Commands:
  emit-position-settled:localhost   - Emit position settled events on localhost
  emit-position-settled:citrea:dev  - Emit position settled events on citrea dev
  emit-position-settled:citrea:prod - Emit position settled events on citrea prod
  
üîç Position Status Commands:
  check-position-status:localhost   - Check position emission status on localhost
  check-position-status:citrea:dev  - Check position emission status on citrea dev
  check-position-status:citrea:prod - Check position emission status on citrea prod
  
‚è∞ Market Timing Commands:
  update-market-timing:localhost   - Update market timing on localhost (hardcoded values)
  update-market-timing:citrea:dev  - Update market timing on citrea dev (hardcoded values)
  update-market-timing:citrea:prod - Update market timing on citrea prod (hardcoded values)
  
üìä Status Commands:
  status:localhost          - Show localhost status
  status:citrea:dev         - Show citrea dev status
  status:citrea:prod        - Show citrea prod status

  
üí∞ SUSD Commands:
  deploy-susd:citrea:dev    - Deploy SUSD to citrea dev
  
üõ°Ô∏è Safety Commands:
  safety-check:localhost    - Run safety checks for localhost
  safety-check:citrea:dev   - Run safety checks for citrea dev
  safety-check:citrea:prod  - Run safety checks for citrea prod


üìã Manifest Commands:
  manifest-backup:ENV       - Backup OpenZeppelin manifest for environment
  manifest-commit:ENV       - Commit manifest changes for environment
  manifest-sync:all         - Sync all environment manifests
  manifest-validate:ENV     - Validate manifest for environment
  repair-manifest:ENV       - Clean ghost implementations from manifest

üí∏ Compensation Commands:
  compensate-susd:ENV       - Send 2x total cost SUSD to investors from CSV

üîç Query Commands:
  range-sum:localhost       - Get range sum for market on localhost
  range-sum:citrea:dev      - Get range sum for market on citrea dev
  range-sum:citrea:prod     - Get range sum for market on citrea prod

Usage:
  COMMAND=deploy:localhost npx hardhat run scripts/dispatcher.ts --network localhost
  COMMAND=deploy:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev
  COMMAND=upgrade:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod
`);
  process.exit(1);
}

async function dispatch() {
  try {
    const [action, ...envParts] = COMMAND!.split(":");
    const env = envParts.join(":"); // safety-check:base:prod ‚Üí base:prod

    // ÌôòÍ≤ΩÎ™Ö Ï†ïÍ∑úÌôî: citrea:dev ‚Üí citrea-dev, citrea:prod ‚Üí citrea-prod
    let environment = env || "localhost";
    if (environment.includes(":")) {
      const parts = environment.split(":");
      if (parts[0] === "citrea") {
        environment = `${parts[0]}-${parts[1]}`; // citrea:dev ‚Üí citrea-dev
      } else {
        environment = parts[1]; // fallback
      }
    }

    console.log(`üéØ Executing: ${COMMAND}`);

    switch (action) {
      case "deploy":
        const { deployAction } = await import("./actions/deploy");
        await deployAction(environment as Environment);
        break;

      case "deploy-fee-policy":
        const { deployFeePolicyAction } = await import(
          "./actions/deploy-fee-policy"
        );
        await deployFeePolicyAction(environment as Environment);
        break;

      case "upgrade":
        const { upgradeAction } = await import("./actions/upgrade");
        await upgradeAction(environment as Environment);
        break;

      case "create-market":
        const { createMarketAction } = await import("./actions/create-market");
        await createMarketAction(environment as Environment);
        break;

      case "settle-market":
        const { settleMarketAction } = await import("./actions/settle-market");
        await settleMarketAction(environment as Environment);
        break;

      case "close-market":
        const { closeMarketAction } = await import("./actions/close-market");
        await closeMarketAction(environment as Environment);
        break;

      case "reopen-market":
        const { reopenMarketAction } = await import("./actions/reopen-market");
        await reopenMarketAction(environment as Environment);
        break;

      case "pause-market":
        const { pauseMarketAction } = await import("./actions/pause-market");
        await pauseMarketAction(environment as Environment);
        break;

      case "set-fee-policy":
        const { setFeePolicyAction } = await import(
          "./actions/set-fee-policy"
        );
        await setFeePolicyAction(environment as Environment);
        break;

      case "unpause-market":
        const { unpauseMarketAction } = await import(
          "./actions/unpause-market"
        );
        await unpauseMarketAction(environment as Environment);
        break;

      case "emit-position-settled":
        const { emitPositionSettledAction } = await import(
          "./actions/emit-position-settled"
        );
        await emitPositionSettledAction(environment as Environment);
        break;

      case "check-position-status":
        const { checkMarketPositionStatusCLI } = await import(
          "./actions/check-market-position-status"
        );
        await checkMarketPositionStatusCLI(environment as Environment);
        break;

      case "update-market-timing":
        const { updateMarketTimingAction } = await import(
          "./actions/update-market-timing"
        );
        await updateMarketTimingAction(environment as Environment);
        break;

      case "set-market-active":
      case "activate-market":
      case "deactivate-market": {
        if (action === "activate-market") {
          process.env.ACTIVE = "true";
        } else if (action === "deactivate-market") {
          process.env.ACTIVE = "false";
        }
        const { setMarketActiveAction } = await import(
          "./actions/set-market-active"
        );
        await setMarketActiveAction(environment as Environment);
        break;
      }

      case "deploy-susd":
        const { deploySUSDAction } = await import("./actions/deploy-susd");
        await deploySUSDAction();
        break;

      case "status":
        const { statusAction } = await import("./actions/status");
        await statusAction(environment as Environment);
        break;

      case "safety-check":
        const { UpgradeSafetyChecker } = await import("./safety-checks");
        const { envManager } = await import("./utils/environment");
        const checker = new UpgradeSafetyChecker(environment as Environment);

        // ÎùºÏù¥Î∏åÎü¨Î¶¨ Ï£ºÏÜå Í∞ÄÏ†∏Ïò§Í∏∞
        const addresses = envManager.getDeployedAddresses(
          environment as Environment
        );
        const libraries = {
          FixedPointMathU: addresses.FixedPointMathU!,
          LazyMulSegmentTree: addresses.LazyMulSegmentTree!,
        };

        await checker.runAllSafetyChecks("CLMSRMarketCore", libraries);
        break;

      case "manifest-backup":
        const { OpenZeppelinManifestManager: ManifestManagerBackup } =
          await import("./manage-manifest");
        const managerBackup = new ManifestManagerBackup();
        await managerBackup.backup(environment);
        break;

      case "manifest-commit":
        const { OpenZeppelinManifestManager: ManifestManagerCommit } =
          await import("./manage-manifest");
        const managerCommit = new ManifestManagerCommit();
        const message = `${environment} environment changes`;
        await managerCommit.commit(environment, message);
        break;

      case "manifest-sync":
        const { OpenZeppelinManifestManager: ManifestManagerSync } =
          await import("./manage-manifest");
        const managerSync = new ManifestManagerSync();
        await managerSync.sync();
        break;

      case "manifest-validate":
        const { OpenZeppelinManifestManager: ManifestManagerValidate } =
          await import("./manage-manifest");
        const managerValidate = new ManifestManagerValidate();
        await managerValidate.validate(environment);
        break;

      case "repair-manifest":
        const { repairManifestAction } = await import("./repair-manifest");
        await repairManifestAction(environment as Environment);
        break;

      case "compensate-susd":
        const { compensateSUSDAction } = await import(
          "./actions/compensate-susd"
        );
        await compensateSUSDAction(environment as Environment);
        break;

      case "debug-emission":
        const { debugEmissionAction } = await import(
          "./actions/debug-emission"
        );
        await debugEmissionAction(environment as Environment);
        break;

      case "test-batch-sizes":
        const { testBatchSizesAction } = await import(
          "./actions/test-batch-sizes"
        );
        await testBatchSizesAction(environment as Environment);
        break;

      case "range-sum":
        const { rangeSumAction } = await import("./actions/range-sum");
        await rangeSumAction(environment as Environment);
        break;

      default:
        console.error(`‚ùå Unknown command: ${action}`);
        console.log("Use COMMAND without value to see available commands");
        process.exit(1);
    }

    console.log("‚úÖ Command completed successfully!");
  } catch (error) {
    console.error("‚ùå Command failed:", error);
    process.exit(1);
  }
}

dispatch();

```

## Tests


## test/unit/core/clmsrMath.internal.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  createActiveMarketFixture,
  setupCustomMarket,
  SMALL_QUANTITY,
  MEDIUM_QUANTITY,
  LARGE_QUANTITY,
  MEDIUM_COST,
  TICK_COUNT,
} from "../../helpers/fixtures/core";
import { UNIT_TAG } from "../../helpers/tags";

const SCALE_DIFF = 10n ** 12n;
const MICRO_USDC = 1n; // 1e-6 USDC in 6-decimal representation
const DEFAULT_LOWER_TICK = 100100;
const DEFAULT_UPPER_TICK = 100200;
const MAX_CHUNKS_PER_TX = 1000n;
const CHUNK_PARITY_SCENARIOS = [
  { alpha: "0.005", chunkMultiplier: 6n },
  { alpha: "0.01", chunkMultiplier: 8n },
  { alpha: "0.02", chunkMultiplier: 5n },
  { alpha: "0.1", chunkMultiplier: 3n },
  { alpha: "0.5", chunkMultiplier: 2n },
];

describe(`${UNIT_TAG} CLMSR Math Internal Functions`, function () {
  describe("Cost Calculation Functions", function () {
    it("Should calculate open cost correctly", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const cost = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY
      );

      expect(cost).to.be.gt(0);
      expect(cost).to.be.lt(ethers.parseUnits("100", 6)); // Reasonable upper bound
    });

    it("Should calculate increase cost correctly", async function () {
      const { core, alice, mockPosition, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      // Create initial position
      await core
        .connect(alice)
        .openPosition(
          marketId,
          100450,
          100550,
          MEDIUM_QUANTITY,
          MEDIUM_COST
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = positions[0];

      const cost = await core.calculateIncreaseCost(positionId, SMALL_QUANTITY);
      expect(cost).to.be.gt(0);
    });

    it("Should calculate decrease payout correctly", async function () {
      const { core, alice, mockPosition, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      // Create initial position
      await core
        .connect(alice)
        .openPosition(
          marketId,
          100450,
          100550,
          MEDIUM_QUANTITY,
          MEDIUM_COST
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = positions[0];

      const payout = await core.calculateDecreaseProceeds(
        positionId,
        SMALL_QUANTITY
      );
      expect(payout).to.be.gt(0);
    });

    it("Should calculate close payout correctly", async function () {
      const { core, alice, mockPosition, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      // Create initial position
      await core
        .connect(alice)
        .openPosition(
          marketId,
          100450,
          100550,
          MEDIUM_QUANTITY,
          MEDIUM_COST
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = positions[0];

      const payout = await core.calculateCloseProceeds(positionId);
      expect(payout).to.be.gt(0);
    });

    it("Should calculate quantity from cost correctly (inverse function)", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const targetCost = ethers.parseUnits("1", 6); // 1 USDC
      const lowerTick = 100450;
      const upperTick = 100550;

      const quantity = await core.calculateQuantityFromCost(
        marketId,
        lowerTick,
        upperTick,
        targetCost
      );

      expect(quantity).to.be.gt(0);
      expect(quantity).to.be.lt(ethers.parseUnits("1000", 6)); // Reasonable upper bound
    });

    it("Should maintain inverse function accuracy", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const lowerTick = 100450;
      const upperTick = 100550;
      const targetCost = ethers.parseUnits("0.5", 6); // 0.5 USDC

      // Calculate quantity from cost (inverse)
      const calculatedQuantity = await core.calculateQuantityFromCost(
        marketId,
        lowerTick,
        upperTick,
        targetCost
      );

      // Calculate cost from that quantity (forward)
      const recalculatedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        calculatedQuantity
      );

      // The costs should be close (within 10% due to CLMSR approximation)
      const difference =
        recalculatedCost > targetCost
          ? recalculatedCost - targetCost
          : targetCost - recalculatedCost;
      const percentError = (difference * 100n) / targetCost;

      expect(percentError).to.be.lte(10n); // Within 10% accuracy
    });

    it("Should handle zero cost edge case for inverse function", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const quantity = await core.calculateQuantityFromCost(
        marketId,
        100450,
        100550,
        0 // Zero cost
      );

      expect(quantity).to.equal(0);
    });

    it("Should maintain quantity proportionality in inverse function", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const smallCost = ethers.parseUnits("0.1", 6); // 0.1 USDC
      const largeCost = ethers.parseUnits("0.5", 6); // 0.5 USDC

      const smallQuantity = await core.calculateQuantityFromCost(
        marketId,
        100450,
        100550,
        smallCost
      );

      const largeQuantity = await core.calculateQuantityFromCost(
        marketId,
        100450,
        100550,
        largeCost
      );

      // Larger cost should yield larger quantity
      expect(largeQuantity).to.be.gt(smallQuantity);
    });

    it("Should align chunked open cost with sequential single-chunk quotes within 1 micro USDC", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      for (const { alpha, chunkMultiplier } of CHUNK_PARITY_SCENARIOS) {
        const alphaWad = ethers.parseEther(alpha);
        const { marketId } = await setupCustomMarket(contracts, {
          alpha: alphaWad,
        });

        const maxSafeQuantityPerChunkWad = alphaWad - 1n;
        const singleChunkQuantity6 = maxSafeQuantityPerChunkWad / SCALE_DIFF;
        expect(
          singleChunkQuantity6,
          `scenario alpha=${alpha} single chunk`
        ).to.be.gt(0n);

        const totalQuantity6 = singleChunkQuantity6 * chunkMultiplier;
        expect(
          totalQuantity6,
          `scenario alpha=${alpha} total quantity`
        ).to.be.gt(singleChunkQuantity6);

        const totalCost = await core.calculateOpenCost(
          marketId,
          DEFAULT_LOWER_TICK,
          DEFAULT_UPPER_TICK,
          totalQuantity6
        );

        let sequentialCost = 0n;
        let remaining = totalQuantity6;
        while (remaining > 0n) {
          const chunk =
            remaining > singleChunkQuantity6 ? singleChunkQuantity6 : remaining;
          const chunkCost = await core.calculateOpenCost(
            marketId,
            DEFAULT_LOWER_TICK,
            DEFAULT_UPPER_TICK,
            chunk
          );
          sequentialCost += chunkCost;

          await core
            .connect(alice)
            .openPosition(
              marketId,
              DEFAULT_LOWER_TICK,
              DEFAULT_UPPER_TICK,
              chunk
            );

          remaining -= chunk;
        }

        const diff =
          totalCost > sequentialCost
            ? totalCost - sequentialCost
            : sequentialCost - totalCost;
        const maxAllowed =
          chunkMultiplier > 0n ? (chunkMultiplier - 1n) * MICRO_USDC : 0n;

        expect(
          sequentialCost,
          `buy monotonicity alpha=${alpha}, chunks=${chunkMultiplier}`
        ).to.be.gte(totalCost);
        expect(
          diff,
          `chunk cost diff alpha=${alpha}, chunks=${chunkMultiplier}`
        ).to.be.lte(maxAllowed);
      }
    });

    it("Should align chunked decrease proceeds with sequential single-chunk exits within 1 micro USDC", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, mockPosition } = contracts as typeof contracts & {
        mockPosition: any;
      };

      for (const { alpha, chunkMultiplier } of CHUNK_PARITY_SCENARIOS) {
        const alphaWad = ethers.parseEther(alpha);
        const { marketId } = await setupCustomMarket(contracts, {
          alpha: alphaWad,
        });

        const maxSafeQuantityPerChunkWad = alphaWad - 1n;
        const singleChunkQuantity6 = maxSafeQuantityPerChunkWad / SCALE_DIFF;
        expect(
          singleChunkQuantity6,
          `scenario alpha=${alpha} single chunk`
        ).to.be.gt(0n);

        const totalQuantity6 = singleChunkQuantity6 * chunkMultiplier;

        await core
          .connect(alice)
          .openPosition(
            marketId,
            DEFAULT_LOWER_TICK,
            DEFAULT_UPPER_TICK,
            totalQuantity6
          );

        const positions = await mockPosition.getPositionsByOwner(alice.address);
        const positionId = positions[positions.length - 1];

        const totalProceeds = await core.calculateDecreaseProceeds(
          positionId,
          totalQuantity6
        );

        let sequentialProceeds = 0n;
        let remaining = totalQuantity6;
        while (remaining > 0n) {
          const chunk =
            remaining > singleChunkQuantity6 ? singleChunkQuantity6 : remaining;
          const chunkProceeds = await core.calculateDecreaseProceeds(
            positionId,
            chunk
          );
          sequentialProceeds += chunkProceeds;

          await core
            .connect(alice)
            .decreasePosition(positionId, chunk, 0n);

          remaining -= chunk;
        }

        const diff =
          totalProceeds > sequentialProceeds
            ? totalProceeds - sequentialProceeds
            : sequentialProceeds - totalProceeds;
        const maxAllowed =
          chunkMultiplier > 0n ? (chunkMultiplier - 1n) * MICRO_USDC : 0n;

        expect(
          sequentialProceeds,
          `sell monotonicity alpha=${alpha}, chunks=${chunkMultiplier}`
        ).to.be.lte(totalProceeds);
        expect(
          diff,
          `chunk proceeds diff alpha=${alpha}, chunks=${chunkMultiplier}`
        ).to.be.lte(maxAllowed);
      }
    });

    it("Should keep round-trip wedge within 1 micro USDC", async function () {
      const { core, alice, mockPosition, marketId } =
        await loadFixture(createActiveMarketFixture);

      const quantity = SMALL_QUANTITY;
      const lowerTick = DEFAULT_LOWER_TICK;
      const upperTick = DEFAULT_UPPER_TICK;

      const quotedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );

      await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          quantity,
          quotedCost
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = positions[0];

      const quotedProceeds = await core.calculateDecreaseProceeds(
        positionId,
        quantity
      );

      expect(
        quotedProceeds,
        "Sell proceeds should not exceed buy cost"
      ).to.be.lte(quotedCost);

      const wedge = quotedCost - quotedProceeds;

      expect(wedge, "Round-trip wedge should be non-negative").to.be.gte(0n);
      expect(wedge, "Round-trip wedge bounded by 1 micro").to.be.lte(MICRO_USDC);
    });

    it("Should revert with ChunkLimitExceeded when required chunks exceed limit", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;

      const customAlpha = ethers.parseEther("0.001");
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: customAlpha,
        numTicks: 10,
      });

      const alphaWad = customAlpha;
      const maxSafeQuantityPerChunkWad = alphaWad - 1n;
      const targetQuantityWad =
        maxSafeQuantityPerChunkWad * (MAX_CHUNKS_PER_TX + 1n);
      const exceedingQuantity =
        (targetQuantityWad + SCALE_DIFF - 1n) / SCALE_DIFF;

      const lowerTick = 100000;
      const upperTick = 100010;

      await expect(
        core.calculateOpenCost(
          marketId,
          lowerTick,
          upperTick,
          exceedingQuantity
        )
      ).to.be.revertedWithCustomError(core, "ChunkLimitExceeded");
    });
  });

  describe("Market Math Consistency", function () {
    it("Should maintain consistent pricing across tick ranges", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      // Test various tick ranges
      const ranges = [
        { lower: 100100, upper: 100200 },
        { lower: 100400, upper: 100600 },
        { lower: 100800, upper: 100900 },
      ];

      for (const range of ranges) {
        const cost = await core.calculateOpenCost(
          marketId,
          range.lower,
          range.upper,
          SMALL_QUANTITY
        );
        expect(cost).to.be.gt(0);
      }
    });

    it("Should handle single tick calculations", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const cost = await core.calculateOpenCost(
        marketId,
        100500,
        100510, // Single tick
        SMALL_QUANTITY
      );

      expect(cost).to.be.gt(0);
    });

    it("Should handle large quantity calculations", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const cost = await core.calculateOpenCost(
        marketId,
        100000,
        100990, // Full range
        LARGE_QUANTITY
      );

      expect(cost).to.be.gt(0);
      expect(cost).to.be.lt(ethers.parseUnits("10000", 6)); // Sanity check
    });

    it("Should maintain cost proportionality", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const smallCost = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        SMALL_QUANTITY
      );

      const largeCost = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        SMALL_QUANTITY * 10n
      );

      // Large cost should be greater than small cost
      expect(largeCost).to.be.gt(smallCost);
      // But not necessarily proportional due to CLMSR curvature
    });
  });

  describe("Edge Case Calculations", function () {
    it("Should handle zero quantity edge case", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      // Zero quantity should revert with InvalidQuantity
      await expect(
        core.calculateOpenCost(marketId, 100450, 100550, 0)
      ).to.be.revertedWithCustomError(core, "InvalidQuantity");
    });

    it("Should handle invalid tick ranges", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      // Lower > Upper should fail (let's see what error it actually throws)
      await expect(core.calculateOpenCost(marketId, 55, 45, SMALL_QUANTITY)).to
        .be.reverted;
    });

    it("Should handle out-of-bounds ticks", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      // Tick >= TICK_COUNT should fail (let's see what error it actually throws)
      await expect(
        core.calculateOpenCost(marketId, 0, TICK_COUNT, SMALL_QUANTITY)
      ).to.be.reverted;
    });

    it("Should handle extremely small quantities", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const cost = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        1 // 1 wei
      );

      expect(cost).to.be.gt(0);
    });
  });

  describe("Internal Calculation Precision", function () {
    it("Should maintain precision in small range calculations", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      // Test narrow range
      const cost1 = await core.calculateOpenCost(
        marketId,
        100490,
        100510,
        SMALL_QUANTITY
      );
      const cost2 = await core.calculateOpenCost(
        marketId,
        100500,
        100510,
        SMALL_QUANTITY
      );

      expect(cost1).to.be.gt(cost2); // Wider range should cost more
    });

    it("Should handle boundary precision correctly", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      // Test boundary ticks
      const costFirst = await core.calculateOpenCost(
        marketId,
        100000,
        100010,
        SMALL_QUANTITY
      );
      const costLast = await core.calculateOpenCost(
        marketId,
        100980,
        100990,
        SMALL_QUANTITY
      );

      expect(costFirst).to.be.gt(0);
      expect(costLast).to.be.gt(0);
    });

    it("Should handle rounding consistency", async function () {
      const { core, alice, mockPosition, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      // Create position
      await core
        .connect(alice)
        .openPosition(
          marketId,
          100450,
          100550,
          MEDIUM_QUANTITY,
          MEDIUM_COST
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = positions[0];

      // Check that increase + decrease should be approximately neutral
      const increaseCost = await core.calculateIncreaseCost(
        positionId,
        SMALL_QUANTITY
      );
      const decreasePayout = await core.calculateDecreaseProceeds(
        positionId,
        SMALL_QUANTITY
      );

      // In a stable market, these should be close but decrease payout might be slightly less
      expect(decreasePayout).to.be.lte(increaseCost);
    });
  });

  describe("Mathematical Invariants", function () {
    it("Should respect CLMSR cost function properties", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      // Use larger quantities to test convexity more clearly
      const baseQuantity = ethers.parseUnits("0.1", 6); // 0.1 USDC instead of micro amounts

      // Cost should increase with quantity (convexity)
      const cost1 = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        baseQuantity
      );
      const cost2 = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        baseQuantity * 2n
      );
      const cost3 = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        baseQuantity * 4n
      );

      // For convex functions, f(2x) > 2*f(x), but with sufficient tolerance for rounding
      expect(cost2).to.be.gt(cost1 * 2n); // Convex function

      // For the third test, use a more lenient check since very small quantities
      // may not show strong convexity due to precision limits
      expect(cost3).to.be.gte(cost2 * 2n); // Allow equal due to precision limits
    });

    it("Should maintain range additivity properties", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      // Compare single large range vs two smaller ranges
      const fullRangeCost = await core.calculateOpenCost(
        marketId,
        100400,
        100600,
        SMALL_QUANTITY
      );

      const leftRangeCost = await core.calculateOpenCost(
        marketId,
        100400,
        100500,
        SMALL_QUANTITY
      );

      const rightRangeCost = await core.calculateOpenCost(
        marketId,
        100510,
        100600,
        SMALL_QUANTITY
      );

      const sumOfParts = leftRangeCost + rightRangeCost;
      const tolerance = (sumOfParts * 15n) / 100n; // allow 15% overhead for new curve params
      expect(fullRangeCost).to.be.lte(sumOfParts + tolerance);
    });
  });
});

```


## test/unit/core/market-seeding.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { AbiCoder, parseEther } from "ethers";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import { positionFixture } from "../../helpers/fixtures/position";

const abi = AbiCoder.defaultAbiCoder();

function buildSeedHash(factors: bigint[]): string {
  return ethers.keccak256(abi.encode(["uint256[]"], [factors]));
}

type MarketParams = {
  minTick: number;
  maxTick: number;
  tickSpacing: number;
  startTimestamp: number;
  endTimestamp: number;
  settlementTimestamp: number;
  liquidityParameter: bigint;
};

describe("Market range factor batching", function () {
  async function setup() {
    const fixture = await loadFixture(positionFixture);
    const { core, keeper } = fixture;
    return { ...fixture, core, keeper };
  }

  async function createTestMarket(
    core: any,
    keeper: any,
    overrides: Partial<MarketParams> = {}
  ) {
    const now = await time.latest();
    const base: MarketParams = {
      minTick: 1000,
      maxTick: 1400,
      tickSpacing: 100,
      startTimestamp: now + 3600,
      endTimestamp: now + 7200,
      settlementTimestamp: now + 10800,
      liquidityParameter: parseEther("100"),
    };

    const params: MarketParams = { ...base, ...overrides };

    const marketId = await core
      .connect(keeper)
      .createMarket.staticCall(
        params.minTick,
        params.maxTick,
        params.tickSpacing,
        params.startTimestamp,
        params.endTimestamp,
        params.settlementTimestamp,
        params.liquidityParameter
      );

    await core.connect(keeper).createMarket(
      params.minTick,
      params.maxTick,
      params.tickSpacing,
      params.startTimestamp,
      params.endTimestamp,
      params.settlementTimestamp,
      params.liquidityParameter
    );

    await core.connect(keeper).setMarketActive(Number(marketId), true);

    return { marketId, params };
  }

  it("applies batch range factors and updates tree sums", async function () {
    const { core, keeper } = await setup();
    const { marketId, params } = await createTestMarket(core, keeper);

    const spacing = BigInt(params.tickSpacing);
    const lowers = [
      BigInt(params.minTick),
      BigInt(params.minTick + params.tickSpacing),
      BigInt(params.minTick + 2 * params.tickSpacing),
      BigInt(params.minTick + 3 * params.tickSpacing),
    ];
    const uppers = lowers.map((lower) => lower + spacing);

    const factors = [
      parseEther("0.8"),
      parseEther("1.15"),
      parseEther("1.5"),
      parseEther("0.95"),
    ];
    const context = buildSeedHash(factors);

    const tx = await core.connect(keeper).applyRangeFactorBatch(
      marketId,
      lowers,
      uppers,
      factors,
      context
    );

    await expect(tx)
      .to.emit(core, "RangeFactorBatchApplied")
      .withArgs(marketId, factors.length, context);

    const receipt = await tx.wait();

    const appliedEvents = receipt.logs
      .map((log: any) => {
        try {
          return core.interface.parseLog(log);
        } catch {
          return null;
        }
      })
      .filter((event: any) => event && event.name === "RangeFactorApplied");

    expect(appliedEvents.length).to.equal(factors.length);

    for (let i = 0; i < factors.length; i++) {
      const event = appliedEvents[i];
      expect(event.args.marketId).to.equal(marketId);
      expect(event.args.lo).to.equal(lowers[i]);
      expect(event.args.hi).to.equal(uppers[i]);
      expect(event.args.factor).to.equal(factors[i]);

      const binSum = await core.getRangeSum(marketId, lowers[i], uppers[i]);
      expect(binSum).to.equal(factors[i]);
    }

    const totalSum = await core.getRangeSum(
      marketId,
      lowers[0],
      uppers[uppers.length - 1]
    );
    const expectedTotal = factors.reduce((acc, factor) => acc + factor, 0n);
    expect(totalSum).to.equal(expectedTotal);

    const market = await core.getMarket(marketId);
    expect(market.isActive).to.equal(true);
  });

  it("reverts on length mismatch", async function () {
    const { core, keeper } = await setup();
    const { marketId } = await createTestMarket(core, keeper, {
      liquidityParameter: parseEther("50"),
    });

    const lowers = [1000n];
    const uppers = [1100n, 1200n];
    const factors = [parseEther("1"), parseEther("1")];

    await expect(
      core
        .connect(keeper)
        .applyRangeFactorBatch(marketId, lowers, uppers, factors, ethers.ZeroHash)
    ).to.be.revertedWithCustomError(core, "ArrayLengthMismatch");
  });

  it("reverts on zero-length batch", async function () {
    const { core, keeper } = await setup();
    const { marketId } = await createTestMarket(core, keeper);

    const empty: bigint[] = [];
    const emptyFactors: bigint[] = [];

    await expect(
      core
        .connect(keeper)
        .applyRangeFactorBatch(marketId, empty, empty, emptyFactors, ethers.ZeroHash)
    ).to.be.revertedWithCustomError(core, "ArrayLengthMismatch");
  });

  it("reverts when factor is out of allowed range", async function () {
    const { core, keeper } = await setup();
    const { marketId, params } = await createTestMarket(core, keeper, {
      liquidityParameter: parseEther("25"),
    });

    const spacing = BigInt(params.tickSpacing);
    const lowers = [
      BigInt(params.minTick),
      BigInt(params.minTick + params.tickSpacing),
      BigInt(params.minTick + 2 * params.tickSpacing),
      BigInt(params.minTick + 3 * params.tickSpacing),
    ];
    const uppers = lowers.map((lower) => lower + spacing);
    const factors = Array(4).fill(parseEther("0.005"));

    await expect(
      core
        .connect(keeper)
        .applyRangeFactorBatch(marketId, lowers, uppers, factors, ethers.ZeroHash)
    ).to.be.revertedWithCustomError(core, "InvalidFactor");
  });

  it("reverts when ticks fall outside market bounds", async function () {
    const { core, keeper } = await setup();
    const { marketId, params } = await createTestMarket(core, keeper);

    const belowMin = BigInt(params.minTick - params.tickSpacing);
    const atMin = BigInt(params.minTick);
    await expect(
      core
        .connect(keeper)
        .applyRangeFactorBatch(
          marketId,
          [belowMin],
          [atMin],
          [parseEther("1")],
          ethers.ZeroHash
        )
    )
      .to.be.revertedWithCustomError(core, "InvalidTick")
      .withArgs(belowMin, BigInt(params.minTick), BigInt(params.maxTick));

    const nearMax = BigInt(params.maxTick - params.tickSpacing);
    const aboveMax = BigInt(params.maxTick + params.tickSpacing);
    await expect(
      core
        .connect(keeper)
        .applyRangeFactorBatch(
          marketId,
          [nearMax],
          [aboveMax],
          [parseEther("1")],
          ethers.ZeroHash
        )
    )
      .to.be.revertedWithCustomError(core, "InvalidTick")
      .withArgs(aboveMax, BigInt(params.minTick), BigInt(params.maxTick));
  });

  it("reverts when paused", async function () {
    const { core, keeper } = await setup();
    const { marketId, params } = await createTestMarket(core, keeper);

    const spacing = BigInt(params.tickSpacing);
    const lower = BigInt(params.minTick);
    const upper = lower + spacing;

    await core.connect(keeper).pause("maintenance");

    await expect(
      core
        .connect(keeper)
        .applyRangeFactorBatch(
          marketId,
          [lower],
          [upper],
          [parseEther("1")],
          ethers.ZeroHash
        )
    ).to.be.revertedWithCustomError(core, "EnforcedPause");
  });

  it("reverts for non-owner callers", async function () {
    const { core, keeper, alice } = await setup();
    const { marketId, params } = await createTestMarket(core, keeper);

    const spacing = BigInt(params.tickSpacing);
    const lower = BigInt(params.minTick);
    const upper = lower + spacing;

    await expect(
      core
        .connect(alice)
        .applyRangeFactorBatch(
          marketId,
          [lower],
          [upper],
          [parseEther("1")],
          ethers.ZeroHash
        )
    )
      .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
      .withArgs(alice.address);
  });

  it("supports multiple batches and composes factors", async function () {
    const { core, keeper } = await setup();
    const { marketId, params } = await createTestMarket(core, keeper);

    const spacing = BigInt(params.tickSpacing);
    const lowers = [
      BigInt(params.minTick),
      BigInt(params.minTick + params.tickSpacing),
      BigInt(params.minTick + 2 * params.tickSpacing),
      BigInt(params.minTick + 3 * params.tickSpacing),
    ];
    const uppers = lowers.map((lower) => lower + spacing);

    const firstFactors = [
      parseEther("1.1"),
      parseEther("0.9"),
      parseEther("1.05"),
      parseEther("1.2"),
    ];
    await core.connect(keeper).applyRangeFactorBatch(
      marketId,
      lowers,
      uppers,
      firstFactors,
      buildSeedHash(firstFactors)
    );

    const secondLowers = [lowers[1], lowers[3]];
    const secondUppers = [uppers[1], uppers[3]];
    const secondFactors = [parseEther("1.4"), parseEther("0.5")];
    await core.connect(keeper).applyRangeFactorBatch(
      marketId,
      secondLowers,
      secondUppers,
      secondFactors,
      ethers.ZeroHash
    );

    const WAD = parseEther("1");
    const expected = [...firstFactors];
    expected[1] = (expected[1] * secondFactors[0]) / WAD;
    expected[3] = (expected[3] * secondFactors[1]) / WAD;

    for (let i = 0; i < expected.length; i++) {
      const binSum = await core.getRangeSum(marketId, lowers[i], uppers[i]);
      expect(binSum).to.equal(expected[i]);
    }

    const totalSum = await core.getRangeSum(
      marketId,
      lowers[0],
      uppers[uppers.length - 1]
    );
    const expectedTotal = expected.reduce((acc, factor) => acc + factor, 0n);
    expect(totalSum).to.equal(expectedTotal);
  });
});

```


## test/unit/libraries/fixedPointMath/basic.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";
import { createDeterministicRandom } from "../../../helpers/utils/random";

describe(`${UNIT_TAG} FixedPointMath - Basic Operations`, function () {
  const WAD = ethers.parseEther("1");
  const TWO = ethers.parseEther("2");
  const HALF = ethers.parseEther("0.5");

  async function deployFixture() {
    const { fixedPointMathU } = await unitFixture();

    const FixedPointMathTest = await ethers.getContractFactory(
      "FixedPointMathTest",
      {
        libraries: { FixedPointMathU: await fixedPointMathU.getAddress() },
      }
    );
    const test = await FixedPointMathTest.deploy();
    await test.waitForDeployment();

    return { test };
  }

  describe("Unsigned Math Operations", function () {
    it("Should multiply correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // 2 * 3 = 6
      const result = await test.wMul(TWO, ethers.parseEther("3"));
      expect(result).to.equal(ethers.parseEther("6"));

      // 0.5 * 0.5 = 0.25
      const result2 = await test.wMul(HALF, HALF);
      expect(result2).to.equal(ethers.parseEther("0.25"));

      // Test with zero
      const result3 = await test.wMul(TWO, 0);
      expect(result3).to.equal(0);
    });

    it("Should divide correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // 6 / 2 = 3
      const result = await test.wDiv(ethers.parseEther("6"), TWO);
      expect(result).to.equal(ethers.parseEther("3"));

      // 1 / 2 = 0.5
      const result2 = await test.wDiv(WAD, TWO);
      expect(result2).to.equal(HALF);
    });

    it("Should revert on division by zero", async function () {
      const { test } = await loadFixture(deployFixture);

      await expect(test.wDiv(WAD, 0)).to.be.revertedWithCustomError(
        test,
        "FP_DivisionByZero"
      );
    });

    it("Should handle WAD format operations", async function () {
      const { test } = await loadFixture(deployFixture);

      // All operations in signals-v0 use WAD format (1e18)
      const five = ethers.parseEther("5");
      const result = await test.wMul(five, WAD);
      expect(result).to.equal(five);
    });

    it("Should handle large values safely", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test with large but safe values
      const largeValue = ethers.parseEther("1000000");
      const result = await test.wMul(largeValue, WAD);
      expect(result).to.equal(largeValue);
    });

    it("Should calculate exponential correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // exp(0) = 1
      const result1 = await test.wExp(0);
      expect(result1).to.equal(WAD);

      // exp(1) ‚âà 2.718...
      const result2 = await test.wExp(WAD);
      expect(result2).to.be.closeTo(
        ethers.parseEther("2.718281828459045235"),
        ethers.parseEther("0.000000000000000001")
      );
    });

    it("Should calculate natural logarithm correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // ln(1) = 0
      const result1 = await test.wLn(WAD);
      expect(result1).to.equal(0);

      // ln(e) ‚âà 1 (with more generous tolerance for floating point precision)
      const e = ethers.parseEther("2.718281828459045235");
      const result2 = await test.wLn(e);
      expect(result2).to.be.closeTo(
        WAD,
        ethers.parseEther("0.000000000000001")
      ); // More generous tolerance
    });

    it("Should calculate square root correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // sqrt(1) = 1
      const result1 = await test.wSqrt(WAD);
      expect(result1).to.equal(WAD);

      // sqrt(4) = 2
      const result2 = await test.wSqrt(ethers.parseEther("4"));
      expect(result2).to.equal(TWO);
    });

    it("Should calculate CLMSR cost correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      const alpha = ethers.parseEther("1000");
      const sumBefore = ethers.parseEther("10");
      const sumAfter = ethers.parseEther("20");

      const cost = await test.clmsrCost(alpha, sumBefore, sumAfter);
      expect(cost).to.be.gt(0);
    });

    it("Should calculate CLMSR price correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      const expValue = ethers.parseEther("2");
      const totalSumExp = ethers.parseEther("10");

      const price = await test.clmsrPrice(expValue, totalSumExp);
      expect(price).to.equal(ethers.parseEther("0.2")); // 2/10 = 0.2
    });

    it("Should handle conversion functions correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // toWad: 1 USDC (6 decimals) -> 1e18 WAD
      const oneUSDC = ethers.parseUnits("1", 6);
      const wadResult = await test.testToWad(oneUSDC);
      expect(wadResult).to.equal(WAD);

      // fromWad: 1e18 WAD -> 1 USDC (6 decimals)
      const usdcResult = await test.testFromWad(WAD);
      expect(usdcResult).to.equal(oneUSDC);

      // fromWadRoundUp: should round up fractional amounts
      const wadWithFraction = WAD + 1n; // 1.000000000000000001 WAD
      const roundedResult = await test.testFromWadRoundUp(wadWithFraction);
      expect(roundedResult).to.equal(oneUSDC + 1n); // Should round up to next USDC unit
    });

    it("Should round up conversion for boundary and random samples", async function () {
      const { test } = await loadFixture(deployFixture);
      const rng = createDeterministicRandom(20241024);

      const SCALE_DIFF = 1_000_000_000_000n;
      const FRACTION_SCALE = 1_000_000n;
      const FRACTION_STEP = WAD / FRACTION_SCALE;

      const MAX_UINT256 = (1n << 256n) - 1n;

      const samples: bigint[] = [0n, 1n, SCALE_DIFF, SCALE_DIFF + 1n, MAX_UINT256];

      while (samples.length < 100) {
        const integerPart = BigInt(Math.floor(rng() * 1_000_000));
        const fractionalPart = BigInt(Math.floor(rng() * Number(FRACTION_SCALE)));
        const wadValue = integerPart * WAD + fractionalPart * FRACTION_STEP;
        samples.push(wadValue);
      }

      for (const wadValue of samples) {
        const floor = await test.testFromWad(wadValue);
        const ceil = await test.testFromWadRoundUp(wadValue);

        expect(ceil).to.be.gte(floor);

        const hasFraction = wadValue % SCALE_DIFF !== 0n;

        if (wadValue === 0n) {
          expect(floor).to.equal(0n);
          expect(ceil).to.equal(0n);
          continue;
        }

        if (hasFraction) {
          expect(ceil - floor).to.equal(1n);
          expect(ceil).to.be.gt(0n);
        } else {
          expect(ceil).to.equal(floor);
        }

        const lowerBound = (ceil - 1n) * SCALE_DIFF;
        const upperBound = ceil * SCALE_DIFF;

        expect(wadValue).to.be.gt(lowerBound);
        expect(wadValue).to.be.lte(upperBound);
      }
    });
  });

  describe("Signed Math Operations", function () {
    it("Should handle signed multiplication", async function () {
      const { test } = await loadFixture(deployFixture);

      const a = ethers.parseEther("2");
      const b = ethers.parseEther("-3");
      const result = await test.wMulSigned(a, b);

      expect(result).to.equal(ethers.parseEther("-6"));
    });

    it("Should handle signed division", async function () {
      const { test } = await loadFixture(deployFixture);

      const a = ethers.parseEther("-6");
      const b = ethers.parseEther("2");
      const result = await test.wDivSigned(a, b);

      expect(result).to.equal(ethers.parseEther("-3"));
    });

    it("Should revert on signed division by zero", async function () {
      const { test } = await loadFixture(deployFixture);

      await expect(test.wDivSigned(WAD, 0)).to.be.revertedWithCustomError(
        test,
        "FP_DivisionByZero"
      );
    });

    it("Should calculate negative CLMSR cost", async function () {
      const { test } = await loadFixture(deployFixture);

      // When sumAfter < sumBefore, cost should be negative
      const alpha = ethers.parseEther("1000");
      const sumBefore = ethers.parseEther("20");
      const sumAfter = ethers.parseEther("10");

      const cost = await test.clmsrCostSigned(alpha, sumBefore, sumAfter);

      // Cost should be negative since sumAfter < sumBefore
      expect(cost).to.be.lt(0);
    });

    it("Should calculate positive CLMSR cost", async function () {
      const { test } = await loadFixture(deployFixture);

      // When sumAfter > sumBefore, cost should be positive
      const alpha = ethers.parseEther("1000");
      const sumBefore = ethers.parseEther("10");
      const sumAfter = ethers.parseEther("20");

      const cost = await test.clmsrCostSigned(alpha, sumBefore, sumAfter);

      // Cost should be positive since sumAfter > sumBefore
      expect(cost).to.be.gt(0);
    });

    it("Should handle signed natural logarithm", async function () {
      const { test } = await loadFixture(deployFixture);

      // ln(1) = 0 (signed)
      const result1 = await test.wLnSigned(WAD);
      expect(result1).to.equal(0);

      // Test with negative alpha in CLMSR cost
      const negativeAlpha = ethers.parseEther("-1000");
      const sumBefore = ethers.parseEther("10");
      const sumAfter = ethers.parseEther("20");

      const cost = await test.clmsrCostSigned(
        negativeAlpha,
        sumBefore,
        sumAfter
      );

      // With negative alpha, cost should be negative when sumAfter > sumBefore
      expect(cost).to.be.lt(0);
    });
  });

  describe("Array Operations", function () {
    it("Should calculate sum of exponentials", async function () {
      const { test } = await loadFixture(deployFixture);

      const values = [WAD, TWO, ethers.parseEther("3")];
      const result = await test.sumExp(values);

      // Should be approximately exp(1) + exp(2) + exp(3)
      expect(result).to.be.gt(0);
    });

    it("Should calculate log-sum-exp", async function () {
      const { test } = await loadFixture(deployFixture);

      const values = [
        ethers.parseEther("50"),
        ethers.parseEther("51"),
        ethers.parseEther("30"),
      ];
      const result = await test.logSumExp(values);

      // logSumExp should handle large values without overflow
      expect(result).to.be.gt(0);
    });

    it("Should revert on empty arrays", async function () {
      const { test } = await loadFixture(deployFixture);

      await expect(test.sumExp([])).to.be.revertedWithCustomError(
        test,
        "FP_EmptyArray"
      );

      await expect(test.logSumExp([])).to.be.revertedWithCustomError(
        test,
        "FP_EmptyArray"
      );
    });
  });

  describe("Edge Cases and Error Handling", function () {
    it("Should handle extreme signed values", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test with large positive and negative values
      const largePos = ethers.parseEther("1000000");
      const largeNeg = ethers.parseEther("-1000000");

      const result1 = await test.wMulSigned(
        largePos,
        ethers.parseEther("0.001")
      );
      expect(result1).to.equal(ethers.parseEther("1000"));

      const result2 = await test.wMulSigned(
        largeNeg,
        ethers.parseEther("0.001")
      );
      expect(result2).to.equal(ethers.parseEther("-1000"));
    });

    it("Should revert on ln(0)", async function () {
      const { test } = await loadFixture(deployFixture);

      await expect(test.wLn(0)).to.be.revertedWithCustomError(
        test,
        "FP_InvalidInput"
      );
    });

    it("Should handle boundary values in exp", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test safe boundary values
      const result1 = await test.wExp(0);
      expect(result1).to.equal(WAD);

      const result2 = await test.wExp(WAD);
      expect(result2).to.be.gt(WAD);

      // Test near a safe limit (133e18 is safer than 135e18)
      const result3 = await test.wExp(ethers.parseEther("133"));
      expect(result3).to.be.gt(0);
    });

    it("Should access constants correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      const wadConstant = await test.WAD();
      expect(wadConstant).to.equal(WAD);

      // Legacy compatibility
      const unitConstant = await test.UNIT();
      expect(unitConstant).to.equal(WAD);
    });
  });
});

```


## test/unit/libraries/fixedPointMath/conversion.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";

describe(`${UNIT_TAG} FixedPointMath - Conversion & Utility Functions`, function () {
  const WAD = ethers.parseEther("1");
  const SCALE_DIFF = 1_000_000_000_000n;
  const HALF_SCALE = SCALE_DIFF / 2n;
  const HALF_WAD = WAD / 2n;

  async function deployFixture() {
    const { fixedPointMathU } = await unitFixture();

    const FixedPointMathTest = await ethers.getContractFactory(
      "FixedPointMathTest",
      {
        libraries: { FixedPointMathU: await fixedPointMathU.getAddress() },
      }
    );
    const test = await FixedPointMathTest.deploy();
    await test.waitForDeployment();

    return { test };
  }

  describe("Conversion Functions", function () {
    it("Should convert from 6-decimal to WAD format", async function () {
      const { test } = await loadFixture(deployFixture);

      // 1 USDC (6 decimals) -> 1 WAD (18 decimals)
      const oneUSDC = ethers.parseUnits("1", 6);
      const result = await test.testToWad(oneUSDC);
      expect(result).to.equal(WAD);

      // 1000 USDC -> 1000 WAD
      const thousandUSDC = ethers.parseUnits("1000", 6);
      const result2 = await test.testToWad(thousandUSDC);
      expect(result2).to.equal(ethers.parseEther("1000"));

      // 0.001 USDC -> 0.001 WAD
      const fractionalUSDC = ethers.parseUnits("0.001", 6);
      const result3 = await test.testToWad(fractionalUSDC);
      expect(result3).to.equal(ethers.parseEther("0.001"));
    });

    it("Should convert from WAD to 6-decimal format", async function () {
      const { test } = await loadFixture(deployFixture);

      // 1 WAD -> 1 USDC (6 decimals)
      const result = await test.testFromWad(WAD);
      expect(result).to.equal(ethers.parseUnits("1", 6));

      // 1000 WAD -> 1000 USDC
      const result2 = await test.testFromWad(ethers.parseEther("1000"));
      expect(result2).to.equal(ethers.parseUnits("1000", 6));

      // 0.001 WAD -> 0.001 USDC
      const result3 = await test.testFromWad(ethers.parseEther("0.001"));
      expect(result3).to.equal(ethers.parseUnits("0.001", 6));
    });

    it("Should round up in fromWadRoundUp conversion", async function () {
      const { test } = await loadFixture(deployFixture);

      // Exact conversion should work the same
      const exactResult = await test.testFromWadRoundUp(WAD);
      expect(exactResult).to.equal(ethers.parseUnits("1", 6));

      // Fractional amount should round up
      const fractionalWad = WAD + 1n; // 1.000000000000000001 WAD
      const roundedResult = await test.testFromWadRoundUp(fractionalWad);
      expect(roundedResult).to.equal(ethers.parseUnits("1", 6) + 1n); // Should round up

      // Another fractional test
      const smallFraction = ethers.parseEther("0.0000001"); // 0.0000001 WAD
      const roundedResult2 = await test.testFromWadRoundUp(smallFraction);
      expect(roundedResult2).to.equal(1n); // Should round up to 1 micro-unit
    });

    it("Should round to nearest micro unit in fromWadNearest conversion", async function () {
      const { test } = await loadFixture(deployFixture);

      const oneMicro = ethers.parseUnits("1", 6);

      // Remainder below half should round down
      const justBelowHalf = WAD + (HALF_SCALE - 1n);
      const roundedDown = await test.testFromWadNearest(justBelowHalf);
      expect(roundedDown).to.equal(oneMicro);

      // Remainder equal to half should round up
      const atHalf = WAD + HALF_SCALE;
      const roundedHalf = await test.testFromWadNearest(atHalf);
      expect(roundedHalf).to.equal(oneMicro + 1n);

      // Larger value sanity check
      const largeValue = WAD * 1234n + HALF_SCALE + 3n;
      const roundedLarge = await test.testFromWadNearest(largeValue);
      const expectedLarge =
        (largeValue / SCALE_DIFF) +
        (largeValue % SCALE_DIFF >= HALF_SCALE ? 1n : 0n);
      expect(roundedLarge).to.equal(expectedLarge);
    });

    it("Should enforce minimum 1 micro unit when using fromWadNearestMin1", async function () {
      const { test } = await loadFixture(deployFixture);

      const tinyValue = 1n; // 1e-18 WAD
      const resultTiny = await test.testFromWadNearestMin1(tinyValue);
      expect(resultTiny).to.equal(1n);

      const zeroValue = await test.testFromWadNearestMin1(0n);
      expect(zeroValue).to.equal(0n);

      const largerValue = await test.testFromWadNearestMin1(WAD + HALF_SCALE);
      expect(largerValue).to.equal(ethers.parseUnits("1", 6) + 1n);
    });

    it("Should maintain precision in round-trip conversions", async function () {
      const { test } = await loadFixture(deployFixture);

      const testValues = [
        ethers.parseUnits("1", 6),
        ethers.parseUnits("100", 6),
        ethers.parseUnits("0.5", 6),
        ethers.parseUnits("999999", 6), // Large value
      ];

      for (const value6 of testValues) {
        // 6-decimal -> WAD -> 6-decimal should preserve value
        const wad = await test.testToWad(value6);
        const backTo6 = await test.testFromWad(wad);
        expect(backTo6).to.equal(value6);
      }
    });
  });

  describe("Nearest rounding helpers", function () {
    it("Should round down when remainder is below half for wMulNearest", async function () {
      const { test } = await loadFixture(deployFixture);

      const a = WAD + HALF_WAD - 1n;
      const b = WAD + 1n;
      const product = a * b;
      const expected = product / WAD; // remainder < HALF_WAD
      const result = await test.wMulNearest(a, b);
      expect(result).to.equal(expected);
    });

    it("Should round up on half or greater remainder in wMulNearest", async function () {
      const { test } = await loadFixture(deployFixture);

      const tieA = WAD + HALF_WAD;
      const tieB = WAD + 1n;
      const tieProduct = tieA * tieB;
      const tieExpected =
        tieProduct / WAD + (tieProduct % WAD >= HALF_WAD ? 1n : 0n);
      const tieResult = await test.wMulNearest(tieA, tieB);
      expect(tieResult).to.equal(tieExpected);

      const aboveA = WAD + HALF_WAD + 1n;
      const aboveB = WAD + 1n;
      const aboveProduct = aboveA * aboveB;
      const aboveExpected =
        aboveProduct / WAD + (aboveProduct % WAD >= HALF_WAD ? 1n : 0n);
      const aboveResult = await test.wMulNearest(aboveA, aboveB);
      expect(aboveResult).to.equal(aboveExpected);
    });
  });

  describe("Utility Functions", function () {
    it("Should calculate square root correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // sqrt(4) = 2
      const result = await test.wSqrt(ethers.parseEther("4"));
      expect(result).to.equal(ethers.parseEther("2"));

      // sqrt(1) = 1
      const result2 = await test.wSqrt(WAD);
      expect(result2).to.equal(WAD);

      // sqrt(0.25) = 0.5
      const result3 = await test.wSqrt(ethers.parseEther("0.25"));
      expect(result3).to.equal(ethers.parseEther("0.5"));
    });

    it("Should calculate sum of exponentials", async function () {
      const { test } = await loadFixture(deployFixture);

      const values = [
        ethers.parseEther("1"),
        ethers.parseEther("2"),
        ethers.parseEther("0.5"),
      ];

      const result = await test.sumExp(values);

      // Calculate expected: exp(1) + exp(2) + exp(0.5)
      const exp1 = await test.wExp(values[0]);
      const exp2 = await test.wExp(values[1]);
      const exp3 = await test.wExp(values[2]);
      const expected = exp1 + exp2 + exp3;

      expect(result).to.equal(expected);
    });

    it("Should calculate log-sum-exp with numerical stability", async function () {
      const { test } = await loadFixture(deployFixture);

      // Use smaller values to avoid overflow in subtraction
      const values = [
        ethers.parseEther("0.5"),
        ethers.parseEther("1"),
        ethers.parseEther("0.8"),
      ];

      const result = await test.logSumExp(values);

      // Result should be reasonable (greater than max value)
      const maxValue = ethers.parseEther("1");
      expect(result).to.be.gt(maxValue);
    });

    it("Should handle empty array in logSumExp", async function () {
      const { test } = await loadFixture(deployFixture);

      const emptyArray: never[] = [];

      await expect(test.logSumExp(emptyArray)).to.be.revertedWithCustomError(
        test,
        "FP_EmptyArray"
      );
    });

    it("Should calculate sum of exponentials with empty check", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test empty array handling
      await expect(test.sumExp([])).to.be.revertedWithCustomError(
        test,
        "FP_EmptyArray"
      );

      // Test single value
      const singleValue = [ethers.parseEther("2")];
      const result = await test.sumExp(singleValue);
      const expected = await test.wExp(singleValue[0]);
      expect(result).to.equal(expected);
    });
  });

  describe("CLMSR Integration", function () {
    it("Should handle typical CLMSR calculations", async function () {
      const { test } = await loadFixture(deployFixture);

      // Simulate CLMSR price calculation
      const expValue = ethers.parseEther("2.718");
      const totalSumExp = ethers.parseEther("10");

      const price = await test.clmsrPrice(expValue, totalSumExp);

      // Price should be expValue / totalSumExp = 0.2718
      const expected = await test.wDiv(expValue, totalSumExp);
      expect(price).to.equal(expected);
    });

    it("Should handle cost calculation", async function () {
      const { test } = await loadFixture(deployFixture);

      // Simulate CLMSR cost calculation
      const alpha = ethers.parseEther("1000");
      const sumBefore = ethers.parseEther("10");
      const sumAfter = ethers.parseEther("20");

      const cost = await test.clmsrCost(alpha, sumBefore, sumAfter);

      // Cost should be alpha * ln(sumAfter / sumBefore)
      const ratio = await test.wDiv(sumAfter, sumBefore);
      const lnRatio = await test.wLn(ratio);
      const expected = await test.wMul(alpha, lnRatio);

      expect(cost).to.equal(expected);
    });

  });

  describe("Edge Cases", function () {
    it("Should handle very small numbers", async function () {
      const { test } = await loadFixture(deployFixture);

      const verySmall = 1; // 1 wei
      const result = await test.wMul(verySmall, WAD);
      expect(result).to.equal(verySmall);
    });

    it("Should handle maximum safe values", async function () {
      const { test } = await loadFixture(deployFixture);

      const largeValue = ethers.parseEther("1000000000"); // 1 billion
      const result = await test.wDiv(largeValue, WAD);
      expect(result).to.equal(largeValue);
    });

    it("Should maintain precision in chained operations", async function () {
      const { test } = await loadFixture(deployFixture);

      // (2 * 3) / 2 = 3
      const step1 = await test.wMul(
        ethers.parseEther("2"),
        ethers.parseEther("3")
      );
      const result = await test.wDiv(step1, ethers.parseEther("2"));
      expect(result).to.equal(ethers.parseEther("3"));
    });

    it("Should handle conversion edge cases", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test zero conversion
      const zeroWad = await test.testToWad(0);
      expect(zeroWad).to.equal(0);

      const zeroUsdc = await test.testFromWad(0);
      expect(zeroUsdc).to.equal(0);

      // Test maximum 6-decimal value (type(uint64).max for USDC-like tokens)
      const maxUsdc = ethers.parseUnits("18446744073709.551615", 6); // ~18.4 trillion USDC
      const maxWad = await test.testToWad(maxUsdc);
      const backToUsdc = await test.testFromWad(maxWad);
      expect(backToUsdc).to.equal(maxUsdc);
    });
  });

  describe("Precision and Round-Up Behavior", function () {
    it("Should demonstrate precision loss and recovery", async function () {
      const { test } = await loadFixture(deployFixture);

      // Small fractional amounts that lose precision in 6-decimal
      const tinyWad = ethers.parseEther("0.0000001"); // 0.1 micro-USDC equivalent

      // Regular conversion loses precision (rounds down to 0)
      const lostPrecision = await test.testFromWad(tinyWad);
      expect(lostPrecision).to.equal(0);

      // Round-up conversion preserves minimum unit
      const preserved = await test.testFromWadRoundUp(tinyWad);
      expect(preserved).to.equal(1); // 1 micro-USDC
    });

    it("Should handle round-up behavior consistently", async function () {
      const { test } = await loadFixture(deployFixture);

      const testCases = [
        { input: WAD + 1n, expectedRoundUp: ethers.parseUnits("1", 6) + 1n },
        {
          input: WAD / 2n + 1n,
          expectedRoundUp: ethers.parseUnits("0.5", 6) + 1n,
        },
        { input: ethers.parseEther("0.000001") + 1n, expectedRoundUp: 2n }, // Just over 1 micro-USDC
      ];

      for (const { input, expectedRoundUp } of testCases) {
        const result = await test.testFromWadRoundUp(input);
        expect(result).to.equal(expectedRoundUp);
      }
    });

    it("Should handle constants correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test WAD constant
      const wadConstant = await test.WAD();
      expect(wadConstant).to.equal(WAD);

      // Test legacy UNIT constant (should be same as WAD)
      const unitConstant = await test.UNIT();
      expect(unitConstant).to.equal(WAD);
    });
  });

  describe("Gas Optimization Validation", function () {
    it("Should validate unchecked arithmetic is safe", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test that conversion operations work within expected ranges
      const reasonableValues = [
        ethers.parseUnits("1", 6),
        ethers.parseUnits("1000000", 6), // 1M USDC
        ethers.parseUnits("0.000001", 6), // 1 micro-USDC
      ];

      for (const value of reasonableValues) {
        // toWad should never overflow for reasonable USDC amounts
        const wad = await test.testToWad(value);
        expect(wad).to.be.gt(0);

        // Round trip should work
        const backTo6 = await test.testFromWad(wad);
        expect(backTo6).to.equal(value);
      }
    });

    it("Should verify conversion scale factor consistency", async function () {
      const { test } = await loadFixture(deployFixture);

      // 1 USDC (10^6) * 10^12 = 1 WAD (10^18)
      const oneUsdc = ethers.parseUnits("1", 6);
      const oneWad = await test.testToWad(oneUsdc);

      // Verify the scale difference is exactly 10^12
      expect(oneWad / oneUsdc).to.equal(1000000000000n); // 10^12
    });
  });
});

```


## test/unit/libraries/fixedPointMath/exp-ln.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";
import { createDeterministicRandom } from "../../../helpers/utils/random";

describe(`${UNIT_TAG} FixedPointMath - Exponential & Logarithm`, function () {
  const UNIT = ethers.parseEther("1");
  const TWO = ethers.parseEther("2");
  const E_APPROX = ethers.parseEther("2.718281828459045235");
  const LN_2_APPROX = ethers.parseEther("0.693147180559945309");

  async function deployFixture() {
    const { fixedPointMathU } = await unitFixture();

    const FixedPointMathTest = await ethers.getContractFactory(
      "FixedPointMathTest",
      {
        libraries: { FixedPointMathU: await fixedPointMathU.getAddress() },
      }
    );
    const test = await FixedPointMathTest.deploy();
    await test.waitForDeployment();

    return { test };
  }

  describe("Exponential Function", function () {
    it("Should calculate exp(0) = 1", async function () {
      const { test } = await loadFixture(deployFixture);

      const result = await test.wExp(0);
      expect(result).to.equal(UNIT);
    });

    it("Should calculate exp(1) ‚âà e", async function () {
      const { test } = await loadFixture(deployFixture);

      const result = await test.wExp(UNIT);

      // Should be close to e (allowing 1% tolerance)
      const tolerance = E_APPROX / 100n;
      expect(result).to.be.closeTo(E_APPROX, tolerance);
    });

    it("Should calculate exp(ln(2)) ‚âà 2", async function () {
      const { test } = await loadFixture(deployFixture);

      const result = await test.wExp(LN_2_APPROX);

      // Should be close to 2 (allowing 1% tolerance)
      const tolerance = TWO / 100n;
      expect(result).to.be.closeTo(TWO, tolerance);
    });

    it("Should handle small values", async function () {
      const { test } = await loadFixture(deployFixture);

      const smallValue = ethers.parseEther("0.1");
      const result = await test.wExp(smallValue);

      // exp(0.1) ‚âà 1.1052
      const expected = ethers.parseEther("1.1052");
      const tolerance = expected / 100n;
      expect(result).to.be.closeTo(expected, tolerance);
    });

    it("Should handle boundary values", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test boundary values that should work (PRB-Math limit is around 133e18)
      await test.wExp(ethers.parseEther("130")); // Safe value

      // Test that very large values revert
      await expect(test.wExp(ethers.parseEther("200"))).to.be.reverted;
    });

    it("Should handle negative values", async function () {
      const { test } = await loadFixture(deployFixture);

      // exp(-1) ‚âà 0.368 - Skip this test due to ethers encoding limitation for negative values
      // Instead test small positive values that approach similar results
      const smallValue = ethers.parseEther("0.001");
      const result = await test.wExp(smallValue);

      // exp(0.001) ‚âà 1.001
      const expected = ethers.parseEther("1.001");
      const tolerance = expected / 100n;
      expect(result).to.be.closeTo(expected, tolerance);
    });
  });

  describe("Logarithm Function", function () {
    it("Should calculate ln(1) = 0", async function () {
      const { test } = await loadFixture(deployFixture);

      const result = await test.wLn(UNIT);
      expect(result).to.equal(0);
    });

    it("Should calculate ln(e) ‚âà 1", async function () {
      const { test } = await loadFixture(deployFixture);

      const result = await test.wLn(E_APPROX);

      // Should be close to 1 (allowing 5% tolerance for precision)
      const tolerance = UNIT / 20n;
      expect(result).to.be.closeTo(UNIT, tolerance);
    });

    it("Should calculate ln(2) ‚âà 0.693", async function () {
      const { test } = await loadFixture(deployFixture);

      const result = await test.wLn(TWO);

      // Should be close to ln(2)
      const tolerance = LN_2_APPROX / 20n;
      expect(result).to.be.closeTo(LN_2_APPROX, tolerance);
    });

    it("Should handle values less than 1", async function () {
      const { test } = await loadFixture(deployFixture);

      // PRB-Math has input restrictions for ln() - use a value > 1 to avoid issues
      // Test with 1.5 instead of values < 1 due to PRB-Math MIN_WHOLE_UD60x18 restrictions
      const value = ethers.parseEther("1.5");
      const result = await test.wLn(value);

      // ln(1.5) ‚âà 0.405
      const expected = ethers.parseEther("0.405");
      const tolerance = expected / 20n;
      expect(result).to.be.closeTo(expected, tolerance);
    });

    it("Should revert on ln(0)", async function () {
      const { test } = await loadFixture(deployFixture);

      await expect(test.wLn(0)).to.be.revertedWithCustomError(
        test,
        "FP_InvalidInput"
      );
    });

    it("Should handle large values", async function () {
      const { test } = await loadFixture(deployFixture);

      const largeValue = ethers.parseEther("1000");
      const result = await test.wLn(largeValue);

      // ln(1000) ‚âà 6.908
      const expected = ethers.parseEther("6.908");
      const tolerance = expected / 20n;
      expect(result).to.be.closeTo(expected, tolerance);
    });

    it("Should maintain exp/ln inverse relationship", async function () {
      const { test } = await loadFixture(deployFixture);

      const testValue = ethers.parseEther("2.5");

      // exp(ln(x)) should equal x
      const lnResult = await test.wLn(testValue);
      const expLnResult = await test.wExp(lnResult);

      const tolerance = testValue / 100n; // 1% tolerance
      expect(expLnResult).to.be.closeTo(testValue, tolerance);
    });

    it("Should match natural log within tolerance across boundary and random samples", async function () {
      const { test } = await loadFixture(deployFixture);
      const rng = createDeterministicRandom(1337);

      const samples: Array<{ value: number; literal: string }> = [
        { value: 1, literal: "1.000000" },
        { value: 1 + 1e-6, literal: "1.000001" },
      ];

      while (samples.length < 100) {
        const integerPart = 1 + Math.floor(rng() * 1_000_000);
        const fractionalPart = Math.floor(rng() * 1_000_000);
        const value = integerPart + fractionalPart / 1_000_000;
        samples.push({
          value,
          literal: `${integerPart}.${fractionalPart.toString().padStart(6, "0")}`,
        });
      }

      const tolerance = ethers.parseEther("0.0000001"); // 1e-7 WAD tolerance

      for (const sample of samples) {
        const wadInput = ethers.parseUnits(sample.literal, 18);
        const result = await test.wLn(wadInput);

        const expectedLn = Math.log(sample.value);
        const expectedWad = ethers.parseUnits(expectedLn.toFixed(18), 18);

        expect(expectedWad).to.be.gte(0);
        expect(result).to.be.closeTo(expectedWad, tolerance);
      }
    });
  });
});

```


## test/unit/libraries/fixedPointMath/invariants.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";
import { createDeterministicRandom } from "../../../helpers/utils/random";

describe(`${UNIT_TAG} FixedPointMath - Invariants & Precision`, function () {
  const UNIT = ethers.parseEther("1");
  const TWO = ethers.parseEther("2");

  async function deployFixture() {
    const { fixedPointMathU } = await unitFixture();

    const FixedPointMathTest = await ethers.getContractFactory(
      "FixedPointMathTest",
      {
        libraries: { FixedPointMathU: await fixedPointMathU.getAddress() },
      }
    );
    const test = await FixedPointMathTest.deploy();
    await test.waitForDeployment();

    return { test };
  }

  describe("Boundary Value Testing", function () {
    it("Should test exp boundary values precisely", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test maximum safe value (PRB-Math limit is around 133.08 WAD)
      // Use a value slightly under the actual limit
      const maxSafe = "133084258667509499440"; // Just under PRB-Math limit
      await test.wExp(maxSafe); // Should succeed

      // Test human-readable values around the limit
      const nearLimit = ethers.parseEther("133");
      await test.wExp(nearLimit); // Should succeed

      const justOverReadable = ethers.parseEther("133.1");
      await expect(test.wExp(justOverReadable)).to.be.reverted; // Should fail

      // Test value just over the limit
      const justOverLimit = "133084258667509499442";
      await expect(test.wExp(justOverLimit)).to.be.reverted;

      // Test clearly over the limit
      const overLimit = ethers.parseEther("134");
      await expect(test.wExp(overLimit)).to.be.reverted;

      // Test precise boundary around 133.084 e18 (PRB-Math limit)
      const preciseBoundary = "133084258667509499440"; // Just under limit
      await test.wExp(preciseBoundary); // Should succeed

      const justOverBoundary = "133084258667509499441"; // Just over limit
      await expect(test.wExp(justOverBoundary)).to.be.reverted; // Should fail

      // Use loose revert check to avoid PRB-Math version dependency
      await expect(test.wExp(ethers.parseEther("135"))).to.be.reverted;
    });

    it("Should test ln boundary values precisely", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test exactly 1 WAD - should equal 0
      const result = await test.wLn(UNIT);
      expect(result).to.equal(0);

      // Test value just under 1 WAD - PRB-Math error occurs first
      const justUnder = UNIT - 1n;
      await expect(test.wLn(justUnder)).to.be.reverted;

      // Test 0 - our custom guard catches this
      await expect(test.wLn(0)).to.be.revertedWithCustomError(
        test,
        "FP_InvalidInput"
      );

      // Test precise ¬±1 wei boundary around 1 WAD
      const exactWAD = ethers.parseEther("1");
      const lnOneResult = await test.wLn(exactWAD);
      expect(lnOneResult).to.equal(0); // ln(1) = 0 exactly

      // Test 1 WAD - 1 wei (should revert)
      const oneWeiUnder = exactWAD - 1n;
      await expect(test.wLn(oneWeiUnder)).to.be.reverted;

      // Test 1 WAD + 1 wei (should succeed and be positive)
      const oneWeiOver = exactWAD + 1n;
      const lnOverResult = await test.wLn(oneWeiOver);
      expect(lnOverResult).to.be.gte(0); // Very small positive value, might be 0 due to precision
    });

    it("Should test sqrt with extreme values", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test sqrt(0) = 0 (boundary case)
      const zeroResult = await test.wSqrt(0);
      expect(zeroResult).to.equal(0);

      // Test perfect squares for accuracy
      const fourWAD = ethers.parseEther("4");
      const sqrtFour = await test.wSqrt(fourWAD);
      expect(sqrtFour).to.equal(ethers.parseEther("2")); // sqrt(4) = 2

      // Test very large value with expected result
      const largeValue = ethers.parseEther("1000000000000"); // 1e12 WAD
      const result2 = await test.wSqrt(largeValue);
      const expectedSqrt = ethers.parseEther("1000000"); // sqrt(1e12) = 1e6 WAD

      // Should be very close to expected value (within 1e-14 precision)
      const tolerance = ethers.parseEther("0.00000000000001");
      expect(result2).to.be.closeTo(expectedSqrt, tolerance);

      // Test maximum uint256 value (boundary case)
      const maxUint256 =
        "115792089237316195423570985008687907853269984665640564039457584007913129639935";
      const maxInputBig = BigInt(maxUint256);
      await expect(test.wSqrt(maxUint256)).to.be.revertedWithCustomError(
        test,
        "PRBMath_UD60x18_Sqrt_Overflow"
      );

      // Just below the limit also overflows because PRB-Math rounding guards
      await expect(
        test.wSqrt((maxInputBig - 1n).toString())
      ).to.be.revertedWithCustomError(test, "PRBMath_UD60x18_Sqrt_Overflow");

      // Large but safe value should succeed
      const safeInputBig = 10n ** 24n; // 1e24 (represents 1e6 WAD)
      const safeResult = (await test.wSqrt(safeInputBig.toString())) as bigint;
      const WAD = 1_000_000_000_000_000_000n;
      const safeResultSquared = (safeResult * safeResult) / WAD;
      expect(safeResultSquared).to.equal(safeInputBig);
      const nextSquare = ((safeResult + 1n) * (safeResult + 1n)) / WAD;
      expect(nextSquare).to.be.gt(safeInputBig);
    });
  });

  describe("Precision and Invariants", function () {
    it("Should test logSumExp with large scale differences", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test with moderate scale differences (avoiding PRB-Math limits)
      const values = [
        ethers.parseEther("0"), // Small
        ethers.parseEther("5"), // Medium
        ethers.parseEther("10"), // Large
      ];

      const result = await test.logSumExp(values);

      // Test behavioral properties rather than exact values
      // logSumExp should be dominated by the largest value (10)
      // but slightly larger due to the other terms
      expect(result).to.be.gt(ethers.parseEther("10")); // Must be > max value
      expect(result).to.be.lt(ethers.parseEther("12")); // But not too much larger

      // Test numerical stability: result should be finite and positive
      expect(result).to.be.gt(0);
    });

    it("Should test logSumExp with very large scale differences", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test with extreme scale differences that might cause numerical issues
      const extremeValues = [
        ethers.parseEther("0.1"), // Very small
        ethers.parseEther("50"), // Very large
        ethers.parseEther("60"), // Even larger
      ];

      const result = await test.logSumExp(extremeValues);

      // Should be dominated by the largest value (60)
      expect(result).to.be.gt(ethers.parseEther("60"));
      expect(result).to.be.lt(ethers.parseEther("62"));
    });

    it("Should maintain exp/ln inverse relationship", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test values in safe range for both operations
      const testValues = [
        ethers.parseEther("1"),
        ethers.parseEther("2"),
        ethers.parseEther("5"),
        ethers.parseEther("10"),
        ethers.parseEther("50"),
      ];

      for (const value of testValues) {
        // exp(ln(x)) should equal x within tolerance for safe-domain values
        const lnResult = await test.wLn(value);
        const expLnResult = await test.wExp(lnResult);

        const tolerance = value / 100000n; // 0.001% tolerance
        expect(expLnResult).to.be.closeTo(value, tolerance);
      }
    });

    it("Should maintain multiplicative properties", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test: (a * b) / a = b
      const a = ethers.parseEther("3.14159");
      const b = ethers.parseEther("2.71828");

      const product = await test.wMul(a, b);
      const result = await test.wDiv(product, a);

      const tolerance = b / 10000n; // 0.01% tolerance
      expect(result).to.be.closeTo(b, tolerance);
    });

    it("Should handle signed math operations correctly", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test signed multiplication
      const a = ethers.parseEther("2");
      const b = ethers.parseEther("-3");
      const result = await test.wMulSigned(a, b);
      expect(result).to.equal(ethers.parseEther("-6"));

      // Test signed division
      const c = ethers.parseEther("-6");
      const d = ethers.parseEther("2");
      const result2 = await test.wDivSigned(c, d);
      expect(result2).to.equal(ethers.parseEther("-3"));
    });

    it("Should handle negative CLMSR cost calculations", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test negative cost (selling scenario)
      const alpha = ethers.parseEther("1000");
      const sumBefore = ethers.parseEther("20");
      const sumAfter = ethers.parseEther("10"); // Decrease

      const cost = await test.clmsrCostSigned(alpha, sumBefore, sumAfter);
      expect(cost).to.be.lt(0); // Should be negative
    });

    it("Should maintain numerical stability in edge cases", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test with very close but not equal values
      const base = ethers.parseEther("1000000");
      const tiny = 1n; // 1 wei difference

      const ratio1 = await test.wDiv(base + tiny, base);
      const ratio2 = await test.wDiv(base, base + tiny);

      // Both should be very close to 1 but not exactly 1
      expect(ratio1).to.be.gte(UNIT); // Changed from gt to gte to handle precision edge case
      expect(ratio2).to.be.lte(UNIT); // Changed from lt to lte

      // The product of ratios should be very close to 1
      const product = await test.wMul(ratio1, ratio2);
      const tolerance = UNIT / 100000n; // Relaxed tolerance for numerical precision
      expect(product).to.be.closeTo(UNIT, tolerance);
    });

    it("Should handle overflow protection in sumExp", async function () {
      const { test } = await loadFixture(deployFixture);

      // Sanity: values comfortably within safe range should succeed
      const safeValues = Array(10).fill(ethers.parseEther("100"));
      const safeResult = await test.sumExp(safeValues);
      expect(safeResult).to.be.gt(0);

      // Values close to the PRB-Math exp upper bound will overflow when summed
      const nearLimit = ethers.parseEther("133.08");
      const overflowValues = Array(20).fill(nearLimit);

      await expect(test.sumExp(overflowValues)).to.be.revertedWithCustomError(
        test,
        "FP_Overflow"
      );
    });

    it("Should handle very small numbers", async function () {
      const { test } = await loadFixture(deployFixture);

      const verySmall = 1; // 1 wei
      const result = await test.wMul(verySmall, UNIT);
      expect(result).to.equal(verySmall);
    });

    it("Should handle maximum safe values", async function () {
      const { test } = await loadFixture(deployFixture);

      const largeValue = ethers.parseEther("1000000000"); // 1 billion
      const result = await test.wDiv(largeValue, UNIT);
      expect(result).to.equal(largeValue);
    });

    it("Should maintain precision in chained operations", async function () {
      const { test } = await loadFixture(deployFixture);

      // (2 * 3) / 2 = 3
      const step1 = await test.wMul(TWO, ethers.parseEther("3"));
      const result = await test.wDiv(step1, TWO);
      expect(result).to.equal(ethers.parseEther("3"));
    });
  });

  describe("Property-Based and Fuzz Tests", function () {
    it("Should test exp(ln(x)) ‚âà x property with random values", async function () {
      const { test } = await loadFixture(deployFixture);
      const random = createDeterministicRandom(1);

      // Generate 20 random values in safe range for PRB-Math ln
      const randomValues = [];
      for (let i = 0; i < 20; i++) {
        // Generate values between 1 and 1000 WAD (safe for ln)
        const randomWad = ethers.parseEther(
          (random() * 999 + 1).toString()
        );
        randomValues.push(randomWad);
      }

      for (const value of randomValues) {
        const lnResult = await test.wLn(value);
        const expLnResult = await test.wExp(lnResult);

        // Should recover original value within reasonable tolerance
        const tolerance = value / 1000000n; // 0.0001% tolerance
        expect(expLnResult).to.be.closeTo(value, tolerance);
      }
    });

    it("Should test multiplication/division inverse property with random values", async function () {
      const { test } = await loadFixture(deployFixture);
      const random = createDeterministicRandom(2);

      // Generate 15 random pairs
      for (let i = 0; i < 15; i++) {
        const a = ethers.parseEther((random() * 1000 + 0.1).toString());
        const b = ethers.parseEther((random() * 1000 + 0.1).toString());

        // Test: div(mul(a, b), b) ‚âà a
        const mulResult = await test.wMul(a, b);
        const divResult = await test.wDiv(mulResult, b);

        const tolerance = a / 1000000n; // 0.0001% tolerance
        expect(divResult).to.be.closeTo(a, tolerance);
      }
    });

    it("Should test CLMSR price normalization with random arrays", async function () {
      const { test } = await loadFixture(deployFixture);
      const random = createDeterministicRandom(3);

      // Test 10 random arrays of different sizes
      for (let arrayTest = 0; arrayTest < 10; arrayTest++) {
        const arraySize = Math.floor(random() * 20) + 5; // 5-24 elements
        const expValues = [];

        for (let i = 0; i < arraySize; i++) {
          // Generate random exp values between 1 and 100 WAD
          const randomExp = ethers.parseEther(
            (random() * 99 + 1).toString()
          );
          expValues.push(randomExp);
        }

        const totalSum = expValues.reduce((sum, val) => sum + val, 0n);

        let priceSum = 0n;
        for (const expValue of expValues) {
          const price = await test.clmsrPrice(expValue, totalSum);
          priceSum += price;
        }

        // Sum should be very close to 1 WAD
        const tolerance = BigInt(arraySize * 5); // Allow more tolerance for larger arrays
        expect(priceSum).to.be.closeTo(ethers.parseEther("1"), tolerance);
      }
    });

    it("Should test continuous operation chains with random values", async function () {
      const { test } = await loadFixture(deployFixture);
      const random = createDeterministicRandom(4);

      // Test 5 chains of 10 operations each
      for (let chain = 0; chain < 5; chain++) {
        let value = ethers.parseEther("10"); // Start with 10 WAD

        for (let op = 0; op < 10; op++) {
          const randomMultiplier = ethers.parseEther(
            (random() * 2 + 0.5).toString()
          ); // 0.5-2.5

          // Multiply then divide by same value
          value = await test.wMul(value, randomMultiplier);
          value = await test.wDiv(value, randomMultiplier);
        }

        // After 10 mul/div pairs, should be close to original 10 WAD
        const tolerance = ethers.parseEther("0.001"); // 0.1% tolerance
        expect(value).to.be.closeTo(ethers.parseEther("10"), tolerance);
      }
    });

    it("Should test extreme boundary values near PRB-Math limits", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test values near exp() input limit (130 WAD)
      const nearExpLimit = ethers.parseEther("129.9");
      const expResult = await test.wExp(nearExpLimit);
      expect(expResult).to.be.gt(0);

      // Test very large values for multiplication
      const largeValue = ethers.parseEther("1000000");
      const smallValue = ethers.parseEther("0.000001");
      const mulResult = await test.wMul(largeValue, smallValue);
      expect(mulResult).to.equal(ethers.parseEther("1"));

      // Test values that should cause revert
      await expect(test.wExp(ethers.parseEther("140"))).to.be.reverted;
      await expect(test.wLn(ethers.parseEther("0.5"))).to.be.reverted;
    });

    it("Should test signed operations with extreme values", async function () {
      const { test } = await loadFixture(deployFixture);
      const random = createDeterministicRandom(5);

      // Test near signed limits with random operations
      for (let i = 0; i < 10; i++) {
        const randomPositive = ethers.parseEther((random() * 1000 + 1).toString());
        const randomNegative = ethers.parseEther(
          (-random() * 1000 - 1).toString()
        );

        // Test mixed sign multiplication
        const mixedResult = await test.wMulSigned(
          randomPositive,
          randomNegative
        );
        expect(mixedResult).to.be.lt(0);

        // Test division with mixed signs
        const divResult = await test.wDivSigned(randomNegative, randomPositive);
        expect(divResult).to.be.lt(0);
      }
    });

    it("Should test precision preservation in complex calculations", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test precision with very small and very large numbers
      const verySmall = ethers.parseEther("0.000000001"); // 1e-9
      const veryLarge = ethers.parseEther("1000000000"); // 1e9

      // Test that small * large / large ‚âà small
      const mulResult = await test.wMul(verySmall, veryLarge);
      const divResult = await test.wDiv(mulResult, veryLarge);

      const tolerance = verySmall / 1000n; // 0.1% tolerance
      expect(divResult).to.be.closeTo(verySmall, tolerance);
    });
  });
});

```


## test/unit/libraries/lazyMulSegmentTree/edge-cases.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";

describe(`${UNIT_TAG} LazyMulSegmentTree - Edge Cases & Stress Tests`, function () {
  const WAD = ethers.parseEther("1");
  const TWO_WAD = ethers.parseEther("2");
  const HALF_WAD = ethers.parseEther("0.5");
  const MIN_FACTOR = ethers.parseEther("0.01");
  const MAX_FACTOR = ethers.parseEther("100");

  async function deployFixture() {
    const libs = await unitFixture();

    const LazyMulSegmentTreeTest = await ethers.getContractFactory(
      "LazyMulSegmentTreeTest",
      {
        libraries: {
          FixedPointMathU: await libs.fixedPointMathU.getAddress(),
        },
      }
    );
    const test = await LazyMulSegmentTreeTest.deploy();
    await test.waitForDeployment();

    return { test };
  }

  async function deploySmallTreeFixture() {
    const { test } = await deployFixture();
    await test.init(10);
    return { test };
  }

  async function deployMediumTreeFixture() {
    const { test } = await deployFixture();
    await test.init(1000);
    return { test };
  }

  describe("Lazy Propagation Tests", function () {
    it("Should handle deferred propagation correctly", async function () {
      const { test } = await loadFixture(deployMediumTreeFixture);

      // Multiple range operations that should trigger lazy propagation
      await test.applyRangeFactor(100, 200, TWO_WAD);
      await test.applyRangeFactor(150, 250, ethers.parseEther("3"));
      await test.applyRangeFactor(50, 150, HALF_WAD);

      // Query specific values - getRangeSum now includes lazy calculation
      expect(await test.getRangeSum(75, 75)).to.equal(HALF_WAD);
      expect(await test.getRangeSum(125, 125)).to.equal(WAD); // 2 * 0.5 = 1 (125Îäî 150-250 Î≤îÏúÑÏóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÏùå)
      expect(await test.getRangeSum(175, 175)).to.equal(ethers.parseEther("6")); // 2 * 3 = 6
      expect(await test.getRangeSum(225, 225)).to.equal(ethers.parseEther("3"));
      expect(await test.getRangeSum(300, 300)).to.equal(WAD);
    });

    it("Should maintain consistency across lazy updates", async function () {
      const { test } = await loadFixture(deployMediumTreeFixture);

      // Complex pattern of lazy operations
      await test.applyRangeFactor(0, 999, TWO_WAD); // Global multiplication
      await test.applyRangeFactor(100, 200, HALF_WAD); // Partial reversion
      await test.applyRangeFactor(150, 160, ethers.parseEther("4")); // Small range boost

      // Verify different segments - getRangeSum includes lazy calculation
      expect(await test.getRangeSum(50, 50)).to.equal(TWO_WAD); // Only global
      expect(await test.getRangeSum(125, 125)).to.equal(WAD); // 2 * 0.5 = 1
      expect(await test.getRangeSum(155, 155)).to.equal(ethers.parseEther("4")); // 2 * 0.5 * 4 = 4
      expect(await test.getRangeSum(250, 250)).to.equal(TWO_WAD); // Only global
    });

    it("Should handle overlapping lazy ranges efficiently", async function () {
      const { test } = await loadFixture(deployMediumTreeFixture);

      // Create multiple overlapping lazy ranges
      const ranges = [
        [0, 500, ethers.parseEther("2")],
        [200, 700, ethers.parseEther("1.5")],
        [400, 900, ethers.parseEther("0.8")],
        [100, 600, ethers.parseEther("2.5")],
      ];

      for (const [start, end, factor] of ranges) {
        await test.applyRangeFactor(start, end, factor);
      }

      // Check specific points to verify correct lazy calculation - getRangeSum includes lazy calculation
      const checkPoints = [50, 150, 300, 450, 650, 800];
      for (const point of checkPoints) {
        const value = await test.getRangeSum(point, point);
        expect(value).to.be.gt(0); // Should be positive
      }
    });

    it("Should trigger propagation on range boundaries", async function () {
      const { test } = await loadFixture(deployMediumTreeFixture);

      // Set up lazy ranges with specific boundaries
      await test.applyRangeFactor(100, 199, TWO_WAD);
      await test.applyRangeFactor(200, 299, ethers.parseEther("3"));

      // Query at boundaries - getRangeSum includes lazy calculation
      expect(await test.getRangeSum(99, 99)).to.equal(WAD);
      expect(await test.getRangeSum(100, 100)).to.equal(TWO_WAD);
      expect(await test.getRangeSum(199, 199)).to.equal(TWO_WAD);
      expect(await test.getRangeSum(200, 200)).to.equal(ethers.parseEther("3"));
      expect(await test.getRangeSum(299, 299)).to.equal(ethers.parseEther("3"));
      expect(await test.getRangeSum(300, 300)).to.equal(WAD);

      // Cross-boundary range queries - getRangeSum includes lazy calculation
      expect(await test.getRangeSum(98, 101)).to.equal(ethers.parseEther("6")); // 1 + 1 + 2 + 2 = 6
      expect(await test.getRangeSum(198, 201)).to.equal(
        ethers.parseEther("10")
      ); // 2 + 2 + 3 + 3 = 10
    });
  });

  describe("Stress Tests", function () {
    it("Should handle many sequential operations", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Perform many operations in sequence
      for (let i = 0; i < 50; i++) {
        const index = i % 10;
        const factor = ethers.parseEther(((i % 5) + 1).toString());

        if (i % 3 === 0) {
          await test.update(index, factor);
        } else {
          const endIndex = Math.min(index + 2, 9);
          await test.applyRangeFactor(index, endIndex, factor);
        }
      }

      // Verify tree is still in valid state
      const totalSum = await test.getTotalSum();
      expect(totalSum).to.be.gt(0);

      // Check that all individual queries work - getRangeSum includes lazy calculation
      for (let i = 0; i < 10; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.be.gt(0);
      }
    });

    it("Should handle alternating update and applyRangeFactor operations", async function () {
      const { test } = await loadFixture(deployMediumTreeFixture);

      // Alternating pattern of operations
      for (let i = 0; i < 20; i++) {
        const start = i * 40;
        const end = Math.min(start + 30, 999);

        if (i % 2 === 0) {
          await test.applyRangeFactor(start, end, TWO_WAD);
        } else {
          const midPoint = Math.floor((start + end) / 2);
          await test.update(midPoint, ethers.parseEther("3"));
        }
      }

      // Verify some scattered points - getRangeSum includes lazy calculation
      const checkPoints = [15, 85, 155, 225, 395, 565, 735, 905];
      for (const point of checkPoints) {
        const value = await test.getRangeSum(point, point);
        expect(value).to.be.gt(0);
      }
    });

    it("Should maintain precision under stress", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Operations that could accumulate precision errors
      const operations = [
        { type: "applyRangeFactor", args: [0, 9, ethers.parseEther("1.1")] },
        { type: "applyRangeFactor", args: [2, 7, ethers.parseEther("0.9")] },
        { type: "update", args: [5, ethers.parseEther("1.5")] },
        { type: "applyRangeFactor", args: [3, 8, ethers.parseEther("1.01")] },
        { type: "applyRangeFactor", args: [1, 6, ethers.parseEther("0.99")] },
      ];

      for (const op of operations) {
        if (op.type === "applyRangeFactor") {
          await test.applyRangeFactor(op.args[0], op.args[1], op.args[2]);
        } else {
          await test.update(op.args[0], op.args[1]);
        }
      }

      // Check that values are reasonable and non-zero - getRangeSum includes lazy calculation
      for (let i = 0; i < 10; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.be.gt(ethers.parseEther("0.1"));
        expect(value).to.be.lt(ethers.parseEther("10"));
      }
    });

    it("Should handle maximum tree size efficiently", async function () {
      const { test } = await loadFixture(deployFixture);
      await test.init(10000); // Large tree

      // Perform operations on large tree
      await test.applyRangeFactor(1000, 5000, TWO_WAD);
      await test.update(2500, ethers.parseEther("5"));
      await test.applyRangeFactor(7000, 9000, HALF_WAD);

      // Test scattered queries - getRangeSum includes lazy calculation
      expect(await test.getRangeSum(500, 500)).to.equal(WAD);
      expect(await test.getRangeSum(2500, 2500)).to.equal(
        ethers.parseEther("5")
      );
      expect(await test.getRangeSum(8000, 8000)).to.equal(HALF_WAD);
      expect(await test.getRangeSum(9500, 9500)).to.equal(WAD);
    });
  });

  describe("Extreme Value Tests", function () {
    it("Should handle very small factors", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const verySmall = ethers.parseEther("0.005"); // Below MIN_FACTOR (0.01)

      // Should revert with InvalidFactor
      await expect(
        test.applyRangeFactor(2, 4, verySmall)
      ).to.be.revertedWithCustomError(test, "InvalidFactor");
    });

    it("Should handle very large factors", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const veryLarge = ethers.parseEther("150"); // Above MAX_FACTOR (100)

      // Should revert with InvalidFactor
      await expect(
        test.applyRangeFactor(2, 4, veryLarge)
      ).to.be.revertedWithCustomError(test, "InvalidFactor");
    });

    it("Should handle zero factors", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Should revert with InvalidFactor (not ZeroFactor)
      await expect(
        test.applyRangeFactor(3, 6, 0)
      ).to.be.revertedWithCustomError(test, "InvalidFactor");
    });

    it("Should handle factor of exactly 1", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Update some values first
      await test.update(2, TWO_WAD);
      await test.update(4, ethers.parseEther("3"));

      const initialSum = await test.getTotalSum();

      // Multiply by 1 (should be no-op)
      await test.applyRangeFactor(0, 9, WAD);

      // Values should be unchanged - getRangeSum includes lazy calculation
      expect(await test.getRangeSum(2, 2)).to.equal(TWO_WAD);
      expect(await test.getRangeSum(4, 4)).to.equal(ethers.parseEther("3"));
      expect(await test.getTotalSum()).to.equal(initialSum);
    });
  });

  describe("Complex Interaction Tests", function () {
    it("Should handle interleaved updates and range multiplications", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Complex sequence simulating real-world usage
      await test.update(1, ethers.parseEther("2"));
      await test.applyRangeFactor(0, 3, ethers.parseEther("1.5"));
      await test.update(5, ethers.parseEther("3"));
      await test.applyRangeFactor(2, 7, ethers.parseEther("0.8"));
      await test.update(6, ethers.parseEther("5"));
      await test.applyRangeFactor(4, 8, ethers.parseEther("1.2"));

      // Verify final state - getRangeSum includes lazy calculation
      for (let i = 0; i < 10; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.be.gt(0);
      }

      // Verify some range queries - getRangeSum includes lazy calculation
      const fullRange = await test.getRangeSum(0, 9);
      expect(fullRange).to.be.gt(0);
    });

    it("Should handle cascading multiplications", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Apply range factors
      await test.applyRangeFactor(0, 9, ethers.parseEther("2")); // Global
      await test.applyRangeFactor(2, 7, ethers.parseEther("3")); // Nested
      await test.applyRangeFactor(4, 5, ethers.parseEther("0.5")); // Deep nested

      // Check specific indices - getRangeSum includes lazy calculation
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(ethers.parseEther("2")); // Only global factor

      const result3 = await test.getRangeSum(3, 3);
      expect(result3).to.equal(ethers.parseEther("6")); // Global(2) * nested(3) = 6

      const result4 = await test.getRangeSum(4, 4);
      expect(result4).to.equal(ethers.parseEther("3")); // Global * nested * deep = 2 * 3 * 0.5 = 3

      const result8 = await test.getRangeSum(8, 8);
      expect(result8).to.equal(ethers.parseEther("2"));
    });

    it("Should maintain invariants under complex operations", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Set up some initial state
      await test.update(0, ethers.parseEther("100"));
      await test.update(5, ethers.parseEther("200"));

      const operations = [
        () => test.applyRangeFactor(0, 2, ethers.parseEther("1.1")),
        () => test.update(1, ethers.parseEther("150")),
        () => test.applyRangeFactor(3, 7, ethers.parseEther("0.9")),
        () => test.update(6, ethers.parseEther("300")),
        () => test.applyRangeFactor(1, 8, ethers.parseEther("1.05")),
      ];

      // Execute operations in sequence
      for (const op of operations) {
        await op();

        // Verify tree is still valid after each operation
        const totalSum = await test.getTotalSum();
        expect(totalSum).to.be.gt(0);

        // Check that no individual value is corrupted
        for (let i = 0; i < 10; i++) {
          const value = await test.getRangeSum(i, i);
          expect(value).to.be.gte(0);
        }
      }
    });
  });

  describe("Recovery and Consistency Tests", function () {
    it("Should recover from extreme operations", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Extreme down scaling followed by up scaling - but within valid range
      await test.applyRangeFactor(0, 9, MIN_FACTOR); // Use MIN_FACTOR instead of invalid value
      await test.applyRangeFactor(0, 9, MAX_FACTOR); // Use MAX_FACTOR instead of invalid value

      // Should be back to approximately original values
      for (let i = 0; i < 10; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.be.closeTo(WAD, ethers.parseEther("0.1"));
      }
    });

    it("Should handle alternating zero and non-zero operations", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Zero operations should revert, so test with valid small factor instead
      await expect(
        test.applyRangeFactor(0, 4, 0)
      ).to.be.revertedWithCustomError(test, "InvalidFactor");

      // Test with valid operations instead
      await test.applyRangeFactor(0, 4, MIN_FACTOR); // Use minimum valid factor
      await test.applyRangeFactor(5, 9, ethers.parseEther("5")); // Boost second half
      await test.update(2, ethers.parseEther("10")); // Restore one element

      // Check results - getRangeSum includes lazy calculation
      for (let i = 0; i < 10; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.be.gt(0);
      }

      // Range queries should work correctly
      const fullRange = await test.getRangeSum(0, 9);
      expect(fullRange).to.be.gt(0); // No zeros
    });

    it("Should maintain precision through repeated operations", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Use factors within valid range
      const factor = ethers.parseEther("1.01"); // Valid small increment
      const inverse = ethers.parseEther("0.99"); // Valid approximate inverse

      for (let i = 0; i < 10; i++) {
        // Reduce iterations to avoid overflow
        await test.applyRangeFactor(0, 9, factor);
        await test.applyRangeFactor(0, 9, inverse);
      }

      // Values should still be reasonable
      for (let i = 0; i < 10; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.be.gt(ethers.parseEther("0.1"));
        expect(value).to.be.lt(ethers.parseEther("10"));
      }
    });
  });
});

```


## test/unit/libraries/lazyMulSegmentTree/init.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";

describe(`${UNIT_TAG} LazyMulSegmentTree - Initialization`, function () {
  const WAD = ethers.parseEther("1");

  async function deployFixture() {
    const libs = await unitFixture();

    const LazyMulSegmentTreeTest = await ethers.getContractFactory(
      "LazyMulSegmentTreeTest",
      {
        libraries: {
          FixedPointMathU: await libs.fixedPointMathU.getAddress(),
        },
      }
    );
    const test = await LazyMulSegmentTreeTest.deploy();
    await test.waitForDeployment();

    return { test };
  }

  describe("Basic Initialization", function () {
    it("Should initialize with correct size", async function () {
      const { test } = await loadFixture(deployFixture);

      await test.init(10);
      // Verify initialization by checking default values
      expect(await test.getRangeSum(0, 0)).to.equal(WAD);
      expect(await test.getRangeSum(9, 9)).to.equal(WAD);
    });

    it("Should initialize with default values", async function () {
      const { test } = await loadFixture(deployFixture);

      await test.init(5);

      // All values should be 1 (WAD) by default
      for (let i = 0; i < 5; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.equal(WAD);
      }

      // Total sum should be size * WAD
      expect(await test.getTotalSum()).to.equal(ethers.parseEther("5"));
    });

    it("Should emit Initialized event", async function () {
      const { test } = await loadFixture(deployFixture);

      await expect(test.init(8)).to.emit(test, "Initialized").withArgs(8);
    });

    it("Should handle single element tree", async function () {
      const { test } = await loadFixture(deployFixture);

      await test.init(1);
      const value1 = await test.getRangeSum(0, 0);
      expect(value1).to.equal(WAD);
      expect(await test.getTotalSum()).to.equal(WAD);
    });

    it("Should handle power-of-two sizes", async function () {
      const { test } = await loadFixture(deployFixture);

      const sizes = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024];

      for (const size of sizes) {
        const { test: freshTest } = await deployFixture();
        await freshTest.init(size);

        // Check first and last elements
        const firstValue = await freshTest.getRangeSum(0, 0);
        const lastValue = await freshTest.getRangeSum(size - 1, size - 1);
        expect(firstValue).to.equal(WAD);
        expect(lastValue).to.equal(WAD);

        // Check total sum
        const expectedSum = ethers.parseEther(size.toString());
        expect(await freshTest.getTotalSum()).to.equal(expectedSum);
      }
    });

    it("Should handle non-power-of-two sizes", async function () {
      const { test } = await loadFixture(deployFixture);

      const sizes = [3, 5, 7, 9, 15, 31, 63, 100, 333, 999];

      for (const size of sizes) {
        const { test: freshTest } = await deployFixture();
        await freshTest.init(size);

        // Verify random elements
        const indices = [0, Math.floor(size / 2), size - 1];
        for (const idx of indices) {
          if (idx < size) {
            const value = await freshTest.getRangeSum(idx, idx);
            expect(value).to.equal(WAD);
          }
        }

        // Check total sum
        const expectedSum = ethers.parseEther(size.toString());
        expect(await freshTest.getTotalSum()).to.equal(expectedSum);
      }
    });
  });

  describe("Initialization Constraints", function () {
    it("Should revert on zero size", async function () {
      const { test } = await loadFixture(deployFixture);

      await expect(test.init(0)).to.be.revertedWithCustomError(
        test,
        "TreeSizeZero"
      );
    });

    it("Should revert on already initialized tree", async function () {
      const { test } = await loadFixture(deployFixture);

      await test.init(5);
      await expect(test.init(10)).to.be.revertedWithCustomError(
        test,
        "TreeAlreadyInitialized"
      );
    });

    it("Should revert on operations before initialization", async function () {
      const { test } = await loadFixture(deployFixture);

      await expect(test.getRangeSum(0, 0)).to.be.revertedWithCustomError(
        test,
        "TreeNotInitialized"
      );

      await expect(test.update(0, WAD)).to.be.revertedWithCustomError(
        test,
        "TreeNotInitialized"
      );

      await expect(
        test.applyRangeFactor(0, 0, WAD)
      ).to.be.revertedWithCustomError(test, "TreeNotInitialized");
    });

    it("Should handle maximum reasonable size", async function () {
      const { test } = await loadFixture(deployFixture);

      // Test with a large but reasonable size
      const largeSize = 10000;
      await test.init(largeSize);

      // Test boundary access should succeed
      await test.getRangeSum(0, 0);
      await test.getRangeSum(largeSize - 1, largeSize - 1);

      // Test out of bounds
      await expect(
        test.getRangeSum(largeSize, largeSize)
      ).to.be.revertedWithCustomError(test, "IndexOutOfBounds");
    });
  });

  describe("Post-Initialization State", function () {
    it("Should maintain state after initialization", async function () {
      const { test } = await loadFixture(deployFixture);

      const size = 7;
      await test.init(size);

      // Verify all elements are accessible and have default value
      for (let i = 0; i < size; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.equal(WAD);
      }

      // Test out of bounds access
      await expect(
        test.getRangeSum(size, size + 5)
      ).to.be.revertedWithCustomError(test, "IndexOutOfBounds");
    });

    it("Should allow operations after initialization", async function () {
      const { test } = await loadFixture(deployFixture);

      const size = 6;
      await test.init(size);

      // Test that basic operations don't revert after initialization
      await test.update(0, ethers.parseEther("2"));
      const updated = await test.getRangeSum(0, 0);
      expect(updated).to.equal(ethers.parseEther("2"));

      // Test that range factor operations don't revert
      await test.applyRangeFactor(1, 3, ethers.parseEther("2"));
      // Just verify no revert - the exact value depends on implementation details
      const afterFactor = await test.getRangeSum(1, 1);
      expect(afterFactor).to.be.gt(0); // Should be positive
    });

    it("Should maintain tree invariants after initialization", async function () {
      const { test } = await loadFixture(deployFixture);

      const size = 8;
      await test.init(size);

      // Test range queries work
      const fullRange = await test.getRangeSum(0, size - 1);
      expect(fullRange).to.equal(ethers.parseEther(size.toString()));

      // Test partial ranges work
      const partialRange = await test.getRangeSum(2, 5);
      expect(partialRange).to.equal(ethers.parseEther("4")); // 4 elements

      // Test individual elements sum to range
      let individualSum = 0n;
      for (let i = 2; i <= 5; i++) {
        const value = await test.getRangeSum(i, i);
        individualSum += value;
      }
      expect(individualSum).to.equal(partialRange);
    });

    it("Should handle concurrent operations after initialization", async function () {
      const { test } = await loadFixture(deployFixture);

      const size = 10;
      await test.init(size);

      // Test that operations don't revert and maintain basic invariants
      await test.update(0, ethers.parseEther("5"));
      await test.update(7, ethers.parseEther("10"));

      // Verify specific updates
      expect(await test.getRangeSum(0, 0)).to.equal(ethers.parseEther("5"));
      expect(await test.getRangeSum(7, 7)).to.equal(ethers.parseEther("10"));

      // Verify unchanged elements remain at default
      expect(await test.getRangeSum(1, 1)).to.equal(WAD);
      expect(await test.getRangeSum(6, 6)).to.equal(WAD);
    });

    it("Should prevent operations on uninitialized fresh instances", async function () {
      const { test } = await loadFixture(deployFixture);
      const { test: freshTest } = await deployFixture();

      // Initialize one but not the other
      await test.init(5);

      // Operations on initialized tree should work
      await test.update(0, ethers.parseEther("2"));

      // Operations on uninitialized tree should fail
      const idx = 0;
      await expect(
        freshTest.getRangeSum(idx, idx)
      ).to.be.revertedWithCustomError(freshTest, "TreeNotInitialized");
    });
  });

  describe("State Verification", function () {
    it("Should report correct state information", async function () {
      const { test } = await loadFixture(deployFixture);

      const size = 15;
      await test.init(size);

      // Total sum should be size * WAD (all default values)
      const expectedSum = ethers.parseEther(size.toString());
      expect(await test.getTotalSum()).to.equal(expectedSum);

      // Tree should be marked as initialized
      // This is implicit since operations work
    });

    it("Should handle size edge cases", async function () {
      const { test: test1 } = await deployFixture();
      const { test: test2 } = await deployFixture();

      // Minimum size
      await test1.init(1);
      expect(await test1.getTotalSum()).to.equal(WAD);

      // Moderately large size
      await test2.init(1337);
      expect(await test2.getTotalSum()).to.equal(ethers.parseEther("1337"));
    });

    it("Should maintain consistency across operations", async function () {
      const { test } = await loadFixture(deployFixture);

      await test.init(10);

      // Initial state
      expect(await test.getTotalSum()).to.equal(ethers.parseEther("10"));

      // After single update
      await test.update(5, ethers.parseEther("2"));
      expect(await test.getTotalSum()).to.equal(ethers.parseEther("11")); // 9*1 + 1*2

      // After range multiplication
      await test.applyRangeFactor(0, 4, ethers.parseEther("2"));
      // Elements 0-4 become 2, element 5 stays 2, elements 6-9 stay 1
      // Total: 5*2 + 1*2 + 4*1 = 16
      expect(await test.getTotalSum()).to.equal(ethers.parseEther("16"));
    });
  });
});

```


## test/unit/libraries/lazyMulSegmentTree/mulRange.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";

describe(`${UNIT_TAG} LazyMulSegmentTree - ApplyRangeFactor Operations`, function () {
  const WAD = ethers.parseEther("1");
  const TWO_WAD = ethers.parseEther("2");
  const HALF_WAD = ethers.parseEther("0.5");
  const MIN_FACTOR = ethers.parseEther("0.01");
  const MAX_FACTOR = ethers.parseEther("100");

  async function deployFixture() {
    const libs = await unitFixture();

    const LazyMulSegmentTreeTest = await ethers.getContractFactory(
      "LazyMulSegmentTreeTest",
      {
        libraries: {
          FixedPointMathU: await libs.fixedPointMathU.getAddress(),
        },
      }
    );
    const test = await LazyMulSegmentTreeTest.deploy();
    await test.waitForDeployment();

    return { test };
  }

  async function deploySmallTreeFixture() {
    const { test } = await deployFixture();
    await test.init(10);
    return { test };
  }

  async function deployMediumTreeFixture() {
    const { test } = await deployFixture();
    await test.init(1000);
    return { test };
  }

  describe("Basic ApplyRangeFactor Operations", function () {
    it("Should multiply range correctly", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Apply range factor: indices [2, 5] * 2
      await test.applyRangeFactor(2, 5, TWO_WAD);

      // Should affect indices 2, 3, 4, 5 only
      expect(await test.getRangeSum(1, 1)).to.equal(WAD); // Unchanged
      expect(await test.getRangeSum(2, 2)).to.equal(TWO_WAD); // Changed
      expect(await test.getRangeSum(3, 3)).to.equal(TWO_WAD); // Changed
      expect(await test.getRangeSum(4, 4)).to.equal(TWO_WAD); // Changed
      expect(await test.getRangeSum(5, 5)).to.equal(TWO_WAD); // Changed
      expect(await test.getRangeSum(6, 6)).to.equal(WAD); // Unchanged

      // Range sums
      expect(await test.getRangeSum(2, 5)).to.equal(ethers.parseEther("8")); // 2 + 2 + 2 + 2 = 8
      expect(await test.getRangeSum(0, 1)).to.equal(ethers.parseEther("2")); // 1 + 1 = 2 (unchanged)
    });

    it("Should handle single element range", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.applyRangeFactor(3, 3, ethers.parseEther("5"));

      const value = await test.getRangeSum(3, 3);
      expect(value).to.equal(ethers.parseEther("5"));
    });

    it("Should handle full range multiplication", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.applyRangeFactor(0, 9, ethers.parseEther("3"));

      // Total sum should be 10 * 3 = 30
      const totalSum = await test.getTotalSum();
      expect(totalSum).to.equal(ethers.parseEther("30"));
    });

    it("Should emit RangeFactorApplied event", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const lo = 1;
      const hi = 4;
      const factor = ethers.parseEther("2.5");

      await test.applyRangeFactor(lo, hi, factor);
    });
  });

  describe("Multiple ApplyRangeFactor Operations", function () {
    it("Should handle overlapping range multiplications", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // First range [1, 5] * 2
      await test.applyRangeFactor(1, 5, TWO_WAD);

      // Second range [3, 7] * 3
      await test.applyRangeFactor(3, 7, ethers.parseEther("3"));

      // Check results - actual values based on observed behavior
      expect(await test.getRangeSum(0, 0)).to.equal(WAD); // Unchanged
      expect(await test.getRangeSum(1, 1)).to.equal(TWO_WAD); // Only first op
      expect(await test.getRangeSum(2, 2)).to.equal(TWO_WAD); // Only first op
      expect(await test.getRangeSum(3, 3)).to.equal(ethers.parseEther("6")); // 2 * 3 = 6
      expect(await test.getRangeSum(4, 4)).to.equal(ethers.parseEther("6")); // 2 * 3 = 6
      expect(await test.getRangeSum(5, 5)).to.equal(ethers.parseEther("6")); // 2 * 3 = 6
      expect(await test.getRangeSum(6, 6)).to.equal(ethers.parseEther("3")); // Only second op
      expect(await test.getRangeSum(7, 7)).to.equal(ethers.parseEther("3")); // Only second op
      expect(await test.getRangeSum(8, 8)).to.equal(WAD); // Unchanged
      expect(await test.getRangeSum(9, 9)).to.equal(WAD); // Unchanged
    });

    it("Should handle non-overlapping range multiplications", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Range [0, 2] * 2
      await test.applyRangeFactor(0, 2, TWO_WAD);

      // Range [5, 7] * 0.5
      await test.applyRangeFactor(5, 7, HALF_WAD);

      // Range [9, 9] * 10
      await test.applyRangeFactor(9, 9, ethers.parseEther("10"));

      // Check results
      expect(await test.getRangeSum(0, 0)).to.equal(TWO_WAD);
      expect(await test.getRangeSum(1, 1)).to.equal(TWO_WAD);
      expect(await test.getRangeSum(2, 2)).to.equal(TWO_WAD);
      expect(await test.getRangeSum(3, 3)).to.equal(WAD); // Unchanged
      expect(await test.getRangeSum(4, 4)).to.equal(WAD); // Unchanged
      expect(await test.getRangeSum(5, 5)).to.equal(HALF_WAD);
      expect(await test.getRangeSum(6, 6)).to.equal(HALF_WAD);
      expect(await test.getRangeSum(7, 7)).to.equal(HALF_WAD);
      expect(await test.getRangeSum(8, 8)).to.equal(WAD); // Unchanged
      expect(await test.getRangeSum(9, 9)).to.equal(ethers.parseEther("10"));
    });

    it("Should handle consecutive operations on same range", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const range = [3, 6];

      // Multiple operations on same range
      await test.applyRangeFactor(range[0], range[1], TWO_WAD); // * 2
      await test.applyRangeFactor(range[0], range[1], ethers.parseEther("3")); // * 3
      await test.applyRangeFactor(range[0], range[1], HALF_WAD); // * 0.5

      // Final result should be 1 * 2 * 3 * 0.5 = 3
      for (let i = range[0]; i <= range[1]; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.equal(ethers.parseEther("3"));
      }
    });
  });

  describe("ApplyRangeFactor with Range Queries", function () {
    it("Should maintain range query consistency after applyRangeFactor", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Multiply range [2, 5] by 2
      await test.applyRangeFactor(2, 5, TWO_WAD);

      // Range queries should reflect the multiplication - sum not product
      // [2,5] has 4 elements, each multiplied by 2: 2+2+2+2 = 8
      const rangeSum = await test.getRangeSum(2, 5);
      expect(rangeSum).to.equal(ethers.parseEther("8"));

      expect(await test.getRangeSum(0, 1)).to.equal(ethers.parseEther("2")); // 1+1 = 2 (unchanged)
      expect(await test.getRangeSum(6, 9)).to.equal(ethers.parseEther("4")); // 1+1+1+1 = 4 (unchanged)

      // Full range should be 2 + 8 + 4 = 14
      expect(await test.getRangeSum(0, 9)).to.equal(ethers.parseEther("14"));
    });

    it("Should handle range queries spanning applyRangeFactor boundaries", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Multiply range [3, 6] by 2
      await test.applyRangeFactor(3, 6, TWO_WAD);

      // Range queries spanning boundaries - calculate as sums
      expect(await test.getRangeSum(1, 4)).to.equal(ethers.parseEther("6")); // 1 + 1 + 2 + 2 = 6
      expect(await test.getRangeSum(5, 8)).to.equal(ethers.parseEther("6")); // 2 + 2 + 1 + 1 = 6
      expect(await test.getRangeSum(2, 7)).to.equal(ethers.parseEther("10")); // 1 + 2 + 2 + 2 + 2 + 1 = 10
    });

    it("Should handle nested range queries", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Multiply large range
      await test.applyRangeFactor(1, 8, TWO_WAD);

      // Nested queries within the range - calculate as sums
      expect(await test.getRangeSum(2, 4)).to.equal(ethers.parseEther("6")); // 2+2+2 = 6
      expect(await test.getRangeSum(3, 6)).to.equal(ethers.parseEther("8")); // 2+2+2+2 = 8
      expect(await test.getRangeSum(5, 7)).to.equal(ethers.parseEther("6")); // 2+2+2 = 6

      // Queries extending beyond the range
      expect(await test.getRangeSum(0, 2)).to.equal(ethers.parseEther("5")); // 1 + 2 + 2 = 5
      expect(await test.getRangeSum(7, 9)).to.equal(ethers.parseEther("5")); // 2 + 2 + 1 = 5
    });
  });

  describe("ApplyRangeFactor Edge Cases", function () {
    it("Should handle multiplication by 1 (identity)", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Multiply by 1 should not change anything
      await test.applyRangeFactor(0, 9, WAD);

      // All values should remain 1
      for (let i = 0; i < 10; i++) {
        const value = await test.getRangeSum(i, i);
        expect(value).to.equal(WAD);
      }

      const totalSum = await test.getTotalSum();
      expect(totalSum).to.equal(ethers.parseEther("10"));
    });

    it("Should handle multiplication by 0", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Multiply range by 0 should revert with InvalidFactor
      await expect(
        test.applyRangeFactor(3, 6, 0)
      ).to.be.revertedWithCustomError(test, "InvalidFactor");
    });

    it("Should handle very small multipliers", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const verySmall = ethers.parseEther("0.005"); // Below MIN_FACTOR (0.01)

      // Should revert with InvalidFactor
      await expect(
        test.applyRangeFactor(2, 4, verySmall)
      ).to.be.revertedWithCustomError(test, "InvalidFactor");
    });

    it("Should handle large multipliers", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const veryLarge = ethers.parseEther("150"); // Above MAX_FACTOR (100)

      // Should revert with InvalidFactor
      await expect(
        test.applyRangeFactor(2, 4, veryLarge)
      ).to.be.revertedWithCustomError(test, "InvalidFactor");
    });

    it("Should revert on invalid range", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // left > right
      await expect(
        test.applyRangeFactor(5, 3, TWO_WAD)
      ).to.be.revertedWithCustomError(test, "InvalidRange");
    });

    it("Should revert on out-of-bounds range", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Out of bounds
      await expect(
        test.applyRangeFactor(0, 10, TWO_WAD)
      ).to.be.revertedWithCustomError(test, "IndexOutOfBounds");

      await expect(
        test.applyRangeFactor(5, 15, TWO_WAD)
      ).to.be.revertedWithCustomError(test, "IndexOutOfBounds");
    });
  });

  describe("ApplyRangeFactor Integration with Updates", function () {
    it("Should combine applyRangeFactor and update operations", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Set up initial values
      await test.update(0, 100);
      await test.update(1, 200);
      await test.update(2, 300);

      // Apply lazy multiplication to range [0, 2]
      await test.applyRangeFactor(0, 2, TWO_WAD);

      // Check results
      const result0 = await test.getRangeSum(0, 0);
      expect(result0).to.equal(200); // 100 * 2
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(400); // 200 * 2
      const result2 = await test.getRangeSum(2, 2);
      expect(result2).to.equal(600); // 300 * 2

      // Range sum should be 200 + 400 + 600 = 1200
      const rangeSum = await test.getRangeSum(0, 2);
      expect(rangeSum).to.equal(1200);
    });

    it("Should handle update followed by applyRangeFactor", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Update first
      await test.update(3, 500);

      // Then multiply range including updated element
      await test.applyRangeFactor(2, 4, ethers.parseEther("1.5"));

      // Check results
      const result2 = await test.getRangeSum(2, 2);
      expect(result2).to.equal(ethers.parseEther("1.5")); // WAD * 1.5
      const result3 = await test.getRangeSum(3, 3);
      expect(result3).to.equal(750); // 500 * 1.5
      const result4 = await test.getRangeSum(4, 4);
      expect(result4).to.equal(ethers.parseEther("1.5")); // WAD * 1.5

      // Range sum should be 1.5 + 750 + 1.5 = 753
      const rangeSum = await test.getRangeSum(2, 4);
      expect(rangeSum).to.equal("3000000000000000750");
    });

    it("Should handle mixed operations sequence", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Complex sequence
      await test.update(0, 100);
      await test.applyRangeFactor(0, 2, TWO_WAD);
      await test.update(1, 500);
      await test.applyRangeFactor(1, 3, ethers.parseEther("1.5"));

      // Check final results
      const result0 = await test.getRangeSum(0, 0);
      expect(result0).to.equal(200); // 100 * 2
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(750); // 500 * 1.5 (update overrides previous multiplication)
      const result2 = await test.getRangeSum(2, 2);
      expect(result2).to.equal(ethers.parseEther("3")); // WAD * 2 * 1.5
      const result3 = await test.getRangeSum(3, 3);
      expect(result3).to.equal(ethers.parseEther("1.5")); // WAD * 1.5

      // Range sum should be 200 + 750 + 3 + 1.5 = 954.5
      const rangeSum = await test.getRangeSum(0, 3);
      expect(rangeSum).to.equal("4500000000000000950");
    });
  });

  describe("ApplyRangeFactor Performance", function () {
    it("Should handle large range multiplications efficiently", async function () {
      const { test } = await loadFixture(deployMediumTreeFixture);

      // Multiply large range
      await test.applyRangeFactor(100, 800, TWO_WAD);

      // Verify boundary elements - use getRangeSum
      const rangeResult = await test.getRangeSum(100, 800);
      expect(rangeResult).to.be.gt(0); // Should be positive
    });

    it("Should handle multiple non-overlapping ranges", async function () {
      const { test } = await loadFixture(deployMediumTreeFixture);

      // Multiple ranges
      await test.applyRangeFactor(0, 9, ethers.parseEther("2"));
      await test.applyRangeFactor(20, 29, ethers.parseEther("3"));
      await test.applyRangeFactor(40, 49, ethers.parseEther("0.5"));
      await test.applyRangeFactor(80, 89, ethers.parseEther("4"));

      // Verify some elements from each range - use getRangeSum
      const rangeResult = await test.getRangeSum(5, 5);
      expect(rangeResult).to.equal(ethers.parseEther("2"));
      const rangeResult2 = await test.getRangeSum(25, 25);
      expect(rangeResult2).to.equal(ethers.parseEther("3"));
      const rangeResult3 = await test.getRangeSum(45, 45);
      expect(rangeResult3).to.equal(ethers.parseEther("0.5"));
      const rangeResult4 = await test.getRangeSum(85, 85);
      expect(rangeResult4).to.equal(ethers.parseEther("4"));

      // Verify unchanged elements
      const rangeResult5 = await test.getRangeSum(15, 15);
      expect(rangeResult5).to.equal(WAD);
      const rangeResult6 = await test.getRangeSum(35, 35);
      expect(rangeResult6).to.equal(WAD);
      const rangeResult7 = await test.getRangeSum(75, 75);
      expect(rangeResult7).to.equal(WAD);
    });
  });

  describe("Advanced Lazy Multiplication", function () {
    it("Should handle no-op factor (WAD) correctly", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.update(0, 100);
      await test.update(1, 200);

      const initialSum = await test.getTotalSum();

      // Multiply by WAD (1.0) - should be no-op
      await test.applyRangeFactor(0, 1, WAD);

      // Values and sum should be unchanged - use getRangeSum
      const result0 = await test.getRangeSum(0, 0);
      expect(result0).to.equal(100);
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(200);
      expect(await test.getTotalSum()).to.equal(initialSum);
    });

    it("Should handle downward factors (price decline scenarios)", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.update(0, 1000);
      await test.update(1, 2000);

      // Test minimum factor (0.01) - force propagation first
      await test.applyRangeFactor(0, 0, MIN_FACTOR);
      const result0 = await test.getRangeSum(0, 0);
      expect(result0).to.equal(10); // 1000 * 0.01

      // Test moderate downward factor (0.5)
      await test.applyRangeFactor(1, 1, ethers.parseEther("0.5"));
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(1000); // 2000 * 0.5

      // Verify total sum reflects all changes
      // 10 + 1000 + 8 * WAD (remaining default values)
      const expectedSum = 10n + 1000n + 8n * 10n ** 18n;
      expect(await test.getTotalSum()).to.equal(expectedSum);
    });

    it("Should handle empty tree multiplication", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Multiply entire default tree (all values are 1 WAD) - should not revert
      await test.applyRangeFactor(0, 9, ethers.parseEther("1.2"));

      // Total sum should be 10 * 1 WAD * 1.2 = 12 WAD
      expect(await test.getTotalSum()).to.equal(ethers.parseEther("12"));
    });

    it("Should maintain total sum consistency after multiplication", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.update(0, 100);
      await test.update(1, 200);
      await test.update(2, 300);

      const initialSum = await test.getTotalSum();
      // Initial sum = 100 + 200 + 300 + 7 * WAD = 600 + 7 * 10^18
      const expectedInitialSum = 600n + 7n * 10n ** 18n;
      expect(initialSum).to.equal(expectedInitialSum);

      // Multiply entire tree by 1.2
      const factor = ethers.parseEther("1.2");
      await test.applyRangeFactor(0, 9, factor);

      const newSum = await test.getTotalSum();
      const expectedSum = (initialSum * factor) / WAD;
      expect(newSum).to.equal(expectedSum);
    });

    it("Should handle default tree multiplication", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Multiply entire tree with default values by 1.2
      await test.applyRangeFactor(0, 9, ethers.parseEther("1.2"));

      // Total sum should be 10 * 1 WAD * 1.2 = 12 WAD
      expect(await test.getTotalSum()).to.equal(ethers.parseEther("12"));
    });

    it("Should handle complex multiplication scenarios", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Set up complex initial values
      await test.update(0, ethers.parseEther("100"));
      await test.update(2, ethers.parseEther("200"));
      await test.update(4, ethers.parseEther("300"));
      await test.update(6, ethers.parseEther("400"));
      await test.update(8, ethers.parseEther("500"));

      // Multiply different ranges with different factors
      await test.applyRangeFactor(0, 2, ethers.parseEther("1.5")); // [0,2] * 1.5
      await test.applyRangeFactor(4, 6, ethers.parseEther("0.8")); // [4,6] * 0.8
      await test.applyRangeFactor(8, 9, ethers.parseEther("2.0")); // [8,9] * 2.0

      // Verify individual results using getRangeSum
      const result0 = await test.getRangeSum(0, 0);
      expect(result0).to.equal(ethers.parseEther("150")); // 100 * 1.5
      const result2 = await test.getRangeSum(2, 2);
      expect(result2).to.equal(ethers.parseEther("300")); // 200 * 1.5
      const result4 = await test.getRangeSum(4, 4);
      expect(result4).to.equal(ethers.parseEther("240")); // 300 * 0.8
      const result6 = await test.getRangeSum(6, 6);
      expect(result6).to.equal(ethers.parseEther("320")); // 400 * 0.8
      const result8 = await test.getRangeSum(8, 8);
      expect(result8).to.equal(ethers.parseEther("1000")); // 500 * 2.0
      const result9 = await test.getRangeSum(9, 9);
      expect(result9).to.equal(ethers.parseEther("2")); // WAD * 2.0

      // Verify untouched indices maintain original values
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(ethers.parseEther("1.5")); // WAD * 1.5
      const result3 = await test.getRangeSum(3, 3);
      expect(result3).to.equal(WAD); // Unchanged
      const result5 = await test.getRangeSum(5, 5);
      expect(result5).to.equal(ethers.parseEther("0.8")); // WAD * 0.8
      const result7 = await test.getRangeSum(7, 7);
      expect(result7).to.equal(WAD); // Unchanged
    });
  });

  describe("ApplyRangeFactor ‚Üí Update Integration", function () {
    it("Should handle update after applyRangeFactor in same segment", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Set up initial values
      await test.update(0, 100);
      await test.update(1, 200);
      await test.update(2, 300);
      await test.update(3, 400);
      await test.update(4, 500);

      // Apply lazy multiplication to range [0, 4]
      await test.applyRangeFactor(0, 4, ethers.parseEther("1.2"));

      // Now update within the lazy range - this triggers push and auto-allocation
      await test.update(2, 999);

      // The updated value should be the new value (999), not affected by lazy factor
      const result2 = await test.getRangeSum(2, 2);
      expect(result2).to.equal(999);

      // Other values in the range should still reflect the multiplication
      const result0 = await test.getRangeSum(0, 0);
      expect(result0).to.equal(120); // 100 * 1.2
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(240); // 200 * 1.2
      const result3 = await test.getRangeSum(3, 3);
      expect(result3).to.equal(480); // 400 * 1.2
      const result4 = await test.getRangeSum(4, 4);
      expect(result4).to.equal(600); // 500 * 1.2

      // Total sum should be: 120 + 240 + 999 + 480 + 600 + 5*WAD (default values)
      const expectedSum = 120n + 240n + 999n + 480n + 600n + 5n * 10n ** 18n;
      expect(await test.getTotalSum()).to.equal(expectedSum);
    });

    it("Should handle multiple updates after applyRangeFactor", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Set initial values
      await test.update(0, 100);
      await test.update(1, 200);
      await test.update(2, 300);

      // Apply lazy multiplication
      await test.applyRangeFactor(0, 2, ethers.parseEther("2.0"));

      // Update multiple values within the lazy range
      await test.update(0, 1000);
      await test.update(1, 2000);

      // Check results
      const result0 = await test.getRangeSum(0, 0);
      expect(result0).to.equal(1000); // New value, not affected by lazy factor
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(2000); // New value, not affected by lazy factor
      const result2 = await test.getRangeSum(2, 2);
      expect(result2).to.equal(600); // 300 * 2.0, lazy propagation should apply

      // Total sum should reflect the updates
      const expectedSum = 1000n + 2000n + 600n + 7n * 10n ** 18n;
      expect(await test.getTotalSum()).to.equal(expectedSum);
    });

    it("Should handle overlapping applyRangeFactor operations", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Set initial values
      await test.update(0, 100);
      await test.update(1, 200);
      await test.update(2, 300);
      await test.update(3, 400);

      // Apply overlapping multiplications
      await test.applyRangeFactor(0, 2, ethers.parseEther("1.5"));
      await test.applyRangeFactor(1, 3, ethers.parseEther("2.0"));

      // Check that the second operation overwrites/combines correctly
      const result0 = await test.getRangeSum(0, 0);
      expect(result0).to.equal(150); // 100 * 1.5
      const result1 = await test.getRangeSum(1, 1);
      expect(result1).to.equal(600); // 200 * 1.5 * 2.0 = 600
      const result2 = await test.getRangeSum(2, 2);
      expect(result2).to.equal(900); // 300 * 1.5 * 2.0 = 900
      const result3 = await test.getRangeSum(3, 3);
      expect(result3).to.equal(800); // 400 * 2.0
    });
  });
});

```


## test/unit/libraries/lazyMulSegmentTree/range-consistency.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";

const TREE_SIZE = 128;
const SAMPLE_COUNT = process.env.COVERAGE ? 64 : 150;
const OPS_PER_SAMPLE = 1;
const VIEW_TOLERANCE = 1_000_000_000_000n; // 1 micro WAD tolerance

const MIN_FACTOR = ethers.parseEther("0.75");
const MAX_FACTOR = ethers.parseEther("1.5");
const SCALE = 1_000_000n;

type HarnessFixture = Awaited<ReturnType<typeof deployHarnessFixture>>;

function createPrng(seed: bigint = 0x6eed0e9dafbb99b5n) {
  let state = seed & ((1n << 64n) - 1n);
  const modulus = 1n << 64n;
  const multiplier = 6364136223846793005n;
  const increment = 1442695040888963407n;

  return {
    next(): bigint {
      state = (state * multiplier + increment) % modulus;
      return state;
    },
    nextInt(maxExclusive: number): number {
      if (maxExclusive <= 0) {
        throw new Error("maxExclusive must be positive");
      }
      return Number(this.next() % BigInt(maxExclusive));
    },
    nextBigInt(maxExclusive: bigint): bigint {
      if (maxExclusive <= 0n) {
        throw new Error("maxExclusive must be positive");
      }
      return this.next() % maxExclusive;
    },
  };
}

async function deployHarnessFixture() {
  const libs = await unitFixture();
  const HarnessFactory = await ethers.getContractFactory(
    "LazyMulSegmentTreeHarness",
    {
      libraries: {
        LazyMulSegmentTree: await libs.lazyMulSegmentTree.getAddress(),
      },
    }
  );

  const harness = await HarnessFactory.deploy();
  await harness.waitForDeployment();
  await harness.init(TREE_SIZE);

  return { harness };
}

function randomFactor(rng: ReturnType<typeof createPrng>): bigint {
  const span = MAX_FACTOR - MIN_FACTOR;
  if (span === 0n) {
    return MIN_FACTOR;
  }
  const offset = (span * rng.nextBigInt(SCALE)) / SCALE;
  const candidate = MIN_FACTOR + offset;
  if (candidate < MIN_FACTOR) {
    return MIN_FACTOR;
  }
  if (candidate > MAX_FACTOR) {
    return MAX_FACTOR;
  }
  return candidate;
}

describe(`${UNIT_TAG} LazyMulSegmentTree - View vs Propagate consistency`, function () {
  it("should use nearest rounding for sell-side factors (no upward bias)", async function () {
    const { harness }: HarnessFixture = await loadFixture(
      deployHarnessFixture
    );

    const increaseFactor = ethers.parseEther("1.75");
    await harness.applyFactor(0, 0, increaseFactor);

    const beforeDecrease = await harness.rangeSum(0, 0);
    const decreaseFactor = ethers.parseEther("1") - 1n; // 0.999...999

    await harness.applyFactor(0, 0, decreaseFactor);

    const afterDecrease = await harness.rangeSum(0, 0);

    const WAD = 1_000_000_000_000_000_000n;
    const HALF_WAD = WAD / 2n;
    const expected = (beforeDecrease * decreaseFactor + HALF_WAD) / WAD;

    expect(
      afterDecrease,
      "sell-side rounding should match nearest rounding expectation"
    ).to.equal(expected);
    expect(afterDecrease, "sell should not increase the position value").to.be.lte(
      beforeDecrease
    );
  });

  it("should keep getRangeSum and propagateLazy in sync across random samples", async function () {
    this.timeout(process.env.COVERAGE ? 120_000 : 60_000);
    const { harness }: HarnessFixture = await loadFixture(
      deployHarnessFixture
    );
    const rng = createPrng();

    for (let iteration = 0; iteration < SAMPLE_COUNT; iteration++) {
      const opCount = 1 + rng.nextInt(OPS_PER_SAMPLE);
      for (let j = 0; j < opCount; j++) {
        const lo = rng.nextInt(TREE_SIZE);
        const hi = lo + rng.nextInt(TREE_SIZE - lo);
        const factor = randomFactor(rng);
        await harness.applyFactor(lo, hi, factor);
      }

      const queryLo = rng.nextInt(TREE_SIZE);
      const queryHi = queryLo + rng.nextInt(TREE_SIZE - queryLo);

      const viewSum = await harness.rangeSum(queryLo, queryHi);
      const staticPropagate = await harness.propagate.staticCall(
        queryLo,
        queryHi
      );

      const diff =
        staticPropagate >= viewSum
          ? staticPropagate - viewSum
          : viewSum - staticPropagate;

      expect(diff, "view vs propagate difference should stay within tolerance").to.be.lte(
        VIEW_TOLERANCE
      );

      await harness.propagate(queryLo, queryHi);

      const viewAfterFlush = await harness.rangeSum(queryLo, queryHi);
      expect(
        viewAfterFlush,
        "view sum should remain stable after propagation"
      ).to.equal(staticPropagate);

      const totalSum = await harness.rangeSum(0, TREE_SIZE - 1);
      expect(await harness.cachedRootSum(), "cached root sum must reflect full range").to.equal(
        totalSum
      );

      await harness.propagate(0, TREE_SIZE - 1);
    }
  });
});

```


## test/unit/libraries/lazyMulSegmentTree/root-consistency.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

async function deployHarnessFixture(treeSize: number) {
  const libs = await (await import("../../../helpers/fixtures/core")).unitFixture();
  const HarnessFactory = await ethers.getContractFactory(
    "LazyMulSegmentTreeHarness",
    {
      libraries: {
        LazyMulSegmentTree: await libs.lazyMulSegmentTree.getAddress(),
      },
    }
  );

  const harness = await HarnessFactory.deploy();
  await harness.waitForDeployment();
  await harness.init(treeSize);

  return { harness };
}

const TREE_SIZE = 128;
async function fixtureTree() {
  return deployHarnessFixture(TREE_SIZE);
}

const BIG = (value: bigint | number) => BigInt(value);

describe("LazyMulSegmentTree - Sum Consistency", function () {
  it("should keep parent sum equal to children sums after lazy push", async function () {
    const { harness } = await loadFixture(fixtureTree);

    await harness.applyFactor(0, TREE_SIZE - 1, ethers.parseEther("50"));
    await harness.applyFactor(0, TREE_SIZE - 1, ethers.parseEther("50"));
    await harness.applyFactor(0, TREE_SIZE - 1, ethers.parseEther("20"));

    const quarter = Math.floor(TREE_SIZE / 4);
    await harness.applyFactor(
      quarter,
      TREE_SIZE - 1 - quarter,
      ethers.parseEther("1.05")
    );

    const rootIndex = await harness.root();
    const [rootSum, , rootPtr] = await harness.getNode(rootIndex);
    const leftIndex = Number(rootPtr >> 32n);
    const rightIndex = Number(rootPtr & 0xffffffffn);

    const [leftSum] = await harness.getNode(leftIndex);
    const [rightSum] = await harness.getNode(rightIndex);

    expect(leftIndex).to.not.equal(0, "left child should exist");
    expect(rightIndex).to.not.equal(0, "right child should exist");
    expect(BIG(leftSum) + BIG(rightSum)).to.equal(
      BIG(rootSum),
      "parent sum must equal sum of children after push"
    );
  });
});

```


## test/unit/libraries/lazyMulSegmentTree/underflow.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";

const WAD = ethers.parseEther("1");
const UNDERFLOW_FLUSH_THRESHOLD = 1_000_000_000_000_000n; // 1e15
const HALF_WAD = WAD / 2n;
const TREE_SIZE = 1024;
const HALF_SIZE = TREE_SIZE / 2;
const FULL_RANGE_LO = 0;
const FULL_RANGE_HI = TREE_SIZE - 1;
const LEFT_RANGE_HI = HALF_SIZE - 1;

function mulWadNearest(a: bigint, b: bigint): bigint {
  const product = a * b;
  return (product + HALF_WAD) / WAD;
}

function expectedRangeSum(length: number, factor: bigint, iterations: number): bigint {
  let result = BigInt(length) * WAD;
  for (let i = 0; i < iterations; i++) {
    result = mulWadNearest(result, factor);
  }
  return result;
}

function simulatePending(factor: bigint, iterations: number): bigint {
  let pending = WAD;
  for (let i = 0; i < iterations; i++) {
    const candidate = mulWadNearest(pending, factor);
    pending = candidate < UNDERFLOW_FLUSH_THRESHOLD ? factor : candidate;
  }
  return pending;
}

describe(`${UNIT_TAG} LazyMulSegmentTree - Underflow Flush`, function () {
  async function deployHarnessFixture() {
    const libs = await unitFixture();

    const HarnessFactory = await ethers.getContractFactory(
      "LazyMulSegmentTreeHarness",
      {
        libraries: {
          LazyMulSegmentTree: await libs.lazyMulSegmentTree.getAddress(),
        },
      }
    );

    const harness = await HarnessFactory.deploy();
    await harness.waitForDeployment();
    await harness.init(TREE_SIZE);

    return { harness, fixedPointMathU: libs.fixedPointMathU };
  }

  it("flushes tiny pending factors instead of zeroing them", async function () {
    const { harness, fixedPointMathU } = await loadFixture(deployHarnessFixture);

    const expOne = await fixedPointMathU.wExp(WAD);
    const factor = await fixedPointMathU.wDiv(WAD, expOne);

    const iterations = 60;
    for (let i = 0; i < iterations; i++) {
      await harness.applyFactor(FULL_RANGE_LO, FULL_RANGE_HI, factor);
    }

    const rootIndex = await harness.root();
    const [rootSum, rootPendingBeforePartial] = await harness.getNode(rootIndex);

    const expectedPending = simulatePending(factor, iterations);
    expect(rootPendingBeforePartial).to.equal(expectedPending);
    expect(rootPendingBeforePartial).to.not.equal(0n);

    const expectedTotal = expectedRangeSum(TREE_SIZE, factor, iterations);
    expect(rootSum).to.equal(expectedTotal);
    expect(await harness.cachedRootSum()).to.equal(expectedTotal);
    expect(await harness.rangeSum(FULL_RANGE_LO, FULL_RANGE_HI)).to.equal(
      expectedTotal
    );

    // Trigger partial overlap to force a push of the accumulated pending factor
    await harness.applyFactor(FULL_RANGE_LO, LEFT_RANGE_HI, factor);

    const [rootSumAfterPartial, rootPendingAfterPartial, childPtr] =
      await harness.getNode(rootIndex);

    const expectedLeft = expectedRangeSum(HALF_SIZE, factor, iterations + 1);
    const expectedRight = expectedRangeSum(HALF_SIZE, factor, iterations);
    const expectedCombined = expectedLeft + expectedRight;

    expect(rootSumAfterPartial).to.equal(expectedCombined);
    expect(await harness.cachedRootSum()).to.equal(expectedCombined);
    expect(await harness.rangeSum(FULL_RANGE_LO, LEFT_RANGE_HI)).to.equal(
      expectedLeft
    );
    expect(await harness.rangeSum(HALF_SIZE, FULL_RANGE_HI)).to.equal(
      expectedRight
    );

    // Root pending should reset after the partial update and children must exist
    expect(rootPendingAfterPartial).to.equal(WAD);
    expect(childPtr).to.not.equal(0);

    await harness.propagate(FULL_RANGE_LO, LEFT_RANGE_HI);
    expect(await harness.rangeSum(FULL_RANGE_LO, LEFT_RANGE_HI)).to.equal(
      expectedLeft
    );
    expect(await harness.cachedRootSum()).to.equal(expectedCombined);
  });
});

```


## test/unit/libraries/lazyMulSegmentTree/update.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { UNIT_TAG } from "../../../helpers/tags";
import { unitFixture } from "../../../helpers/fixtures/core";

describe(`${UNIT_TAG} LazyMulSegmentTree - Update Operations`, function () {
  const WAD = ethers.parseEther("1");
  const TWO_WAD = ethers.parseEther("2");
  const HALF_WAD = ethers.parseEther("0.5");

  async function deployFixture() {
    const libs = await unitFixture();

    const LazyMulSegmentTreeTest = await ethers.getContractFactory(
      "LazyMulSegmentTreeTest",
      {
        libraries: {
          FixedPointMathU: await libs.fixedPointMathU.getAddress(),
        },
      }
    );
    const test = await LazyMulSegmentTreeTest.deploy();
    await test.waitForDeployment();

    return { test };
  }

  async function deploySmallTreeFixture() {
    const { test } = await deployFixture();
    await test.init(10); // Tree with 10 leaves
    return { test };
  }

  describe("Basic Operations", function () {
    it("Should update and query single values", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Update value at index 5
      await test.update(5, TWO_WAD);

      // Query single value
      const value = await test.getRangeSum(5, 5);
      expect(value).to.equal(TWO_WAD);

      // Verify total sum changed
      const totalSum = await test.getTotalSum();
      expect(totalSum).to.equal(ethers.parseEther("11")); // 9 * 1 + 1 * 2 = 11
    });

    it("Should update multiple values", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Update multiple values
      await test.update(0, TWO_WAD);
      await test.update(5, ethers.parseEther("3"));
      await test.update(9, HALF_WAD);

      // Verify individual values
      expect(await test.getRangeSum(0, 0)).to.equal(TWO_WAD);
      expect(await test.getRangeSum(5, 5)).to.equal(ethers.parseEther("3"));
      expect(await test.getRangeSum(9, 9)).to.equal(HALF_WAD);

      // Verify total sum: 7 * 1 + 1 * 2 + 1 * 3 + 1 * 0.5 = 12.5
      const totalSum = await test.getTotalSum();
      expect(totalSum).to.equal(ethers.parseEther("12.5"));
    });

    it("Should handle range queries correctly", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Update some values
      await test.update(2, TWO_WAD);
      await test.update(3, ethers.parseEther("3"));
      await test.update(4, HALF_WAD);

      // Query ranges - calculate as sums not products
      expect(await test.getRangeSum(2, 4)).to.equal(ethers.parseEther("5.5")); // 2 + 3 + 0.5 = 5.5
      expect(await test.getRangeSum(0, 1)).to.equal(ethers.parseEther("2")); // 1 + 1 = 2
      expect(await test.getRangeSum(5, 9)).to.equal(ethers.parseEther("5")); // 1 + 1 + 1 + 1 + 1 = 5
    });

    it("Should emit NodeUpdated event", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await expect(test.update(3, TWO_WAD))
        .to.emit(test, "NodeUpdated")
        .withArgs(3, TWO_WAD);
    });

    it("Should handle zero and one values correctly", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Update to zero (edge case)
      await test.update(0, 0);
      expect(await test.getRangeSum(0, 0)).to.equal(0);

      // Update to one (identity)
      await test.update(0, WAD);
      expect(await test.getRangeSum(0, 0)).to.equal(WAD);
    });

    it("Should handle large values within bounds", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const largeValue = ethers.parseEther("1000000");
      await test.update(5, largeValue);
      expect(await test.getRangeSum(5, 5)).to.equal(largeValue);
    });
  });

  describe("Batch Update Operations", function () {
    it("Should perform batch updates correctly", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const indices = [0, 2, 4, 6, 8];
      const values = [
        TWO_WAD,
        ethers.parseEther("3"),
        HALF_WAD,
        ethers.parseEther("0.25"),
        ethers.parseEther("4"),
      ];

      await test.batchUpdate(indices, values);

      // Verify all values
      for (let i = 0; i < indices.length; i++) {
        const value = await test.getRangeSum(indices[i], indices[i]);
        expect(value).to.equal(values[i]);
      }
    });

    it("Should revert on mismatched array lengths", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const indices = [0, 1, 2];
      const values = [TWO_WAD, ethers.parseEther("3")]; // One less value

      // Should revert (could be custom error or require statement)
      await expect(test.batchUpdate(indices, values)).to.be.reverted;
    });

    it("Should handle empty batch updates", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.batchUpdate([], []);

      // Tree should remain unchanged
      const totalSum = await test.getTotalSum();
      expect(totalSum).to.equal(ethers.parseEther("10"));
    });

    it("Should emit events for batch updates", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const indices = [1, 3];
      const values = [TWO_WAD, ethers.parseEther("3")];

      // Note: batchUpdate may not emit individual NodeUpdated events
      // depending on implementation - check if it emits any events
      await test.batchUpdate(indices, values);

      // Verify the updates worked by checking values
      expect(await test.getRangeSum(1, 1)).to.equal(TWO_WAD);
      expect(await test.getRangeSum(3, 3)).to.equal(ethers.parseEther("3"));
    });
  });

  describe("Update with Range Queries", function () {
    it("Should maintain range query consistency after updates", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Update values in a pattern
      await test.update(2, TWO_WAD);
      await test.update(3, TWO_WAD);
      await test.update(4, TWO_WAD);

      // Range [2,4] should be 2 + 2 + 2 = 6 (sum not product)
      expect(await test.getRangeSum(2, 4)).to.equal(ethers.parseEther("6"));

      // Range [0,1] should remain 1 + 1 = 2
      expect(await test.getRangeSum(0, 1)).to.equal(ethers.parseEther("2"));

      // Range [5,9] should remain 1 + 1 + 1 + 1 + 1 = 5
      expect(await test.getRangeSum(5, 9)).to.equal(ethers.parseEther("5"));

      // Full range [0,9] should be 1 + 1 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 1 = 13
      expect(await test.getRangeSum(0, 9)).to.equal(ethers.parseEther("13"));
    });

    it("Should handle overlapping range queries", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.update(1, TWO_WAD);
      await test.update(2, ethers.parseEther("3"));
      await test.update(3, HALF_WAD);

      // Overlapping ranges - calculate as sums
      expect(await test.getRangeSum(0, 2)).to.equal(ethers.parseEther("6")); // 1 + 2 + 3 = 6
      expect(await test.getRangeSum(1, 3)).to.equal(ethers.parseEther("5.5")); // 2 + 3 + 0.5 = 5.5
      expect(await test.getRangeSum(2, 4)).to.equal(ethers.parseEther("4.5")); // 3 + 0.5 + 1 = 4.5
    });

    it("Should handle single-element ranges", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.update(5, ethers.parseEther("42"));

      // Single element range should equal the value
      expect(await test.getRangeSum(5, 5)).to.equal(ethers.parseEther("42"));

      // Other single elements should be 1
      expect(await test.getRangeSum(0, 0)).to.equal(WAD);
      expect(await test.getRangeSum(9, 9)).to.equal(WAD);
    });

    it("Should handle updates at boundaries", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Update first element
      await test.update(0, ethers.parseEther("100"));
      expect(await test.getRangeSum(0, 0)).to.equal(ethers.parseEther("100"));

      // Update last element
      await test.update(9, ethers.parseEther("200"));
      expect(await test.getRangeSum(9, 9)).to.equal(ethers.parseEther("200"));

      // Verify full range includes both - sum not product
      // 100 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 200 = 308
      const fullRange = await test.getRangeSum(0, 9);
      expect(fullRange).to.equal(ethers.parseEther("308"));
    });

    it("Should handle rapid consecutive updates", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Rapid updates to same index
      await test.update(5, TWO_WAD);
      await test.update(5, ethers.parseEther("3"));
      await test.update(5, HALF_WAD);
      await test.update(5, ethers.parseEther("10"));

      // Should have latest value
      expect(await test.getRangeSum(5, 5)).to.equal(ethers.parseEther("10"));
    });

    it("Should maintain precision with small decimal values", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      const preciseValue = ethers.parseEther("0.123456789012345678");
      await test.update(3, preciseValue);

      expect(await test.getRangeSum(3, 3)).to.equal(preciseValue);
    });

    it("Should handle updates with maximum allowed values", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Test with large but valid values
      const maxSafeValue = ethers.parseEther("1000000000000000000"); // 1e18 WAD
      await test.update(7, maxSafeValue);

      expect(await test.getRangeSum(7, 7)).to.equal(maxSafeValue);
    });

    it("Should preserve tree invariants after updates", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Complex update pattern
      const updates = [
        [0, ethers.parseEther("100")],
        [2, ethers.parseEther("200")],
        [4, ethers.parseEther("300")],
        [6, ethers.parseEther("400")],
        [8, ethers.parseEther("500")],
      ];

      for (const [index, value] of updates) {
        await test.update(index, value);
      }

      // Calculate expected total sum
      // 100 + 1 + 200 + 1 + 300 + 1 + 400 + 1 + 500 + 1 = 1505
      const expectedSum = ethers.parseEther("1505");
      const totalSum = await test.getTotalSum();
      expect(totalSum).to.equal(expectedSum);
    });

    it("Should handle zero value updates correctly", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.update(5, 0);
      expect(await test.getRangeSum(5, 5)).to.equal(0);

      // Range including zero should still work
      // 1 + 1 + 1 + 1 + 1 + 0 + 1 + 1 + 1 + 1 = 9
      expect(await test.getRangeSum(0, 9)).to.equal(ethers.parseEther("9"));
    });
  });

  describe("Update Performance", function () {
    it("Should handle updates efficiently for larger trees", async function () {
      const { test } = await loadFixture(deployFixture);
      await test.init(1000);

      // Update scattered elements
      const indices = [0, 100, 200, 500, 750, 999];
      const values = [
        ethers.parseEther("2"),
        ethers.parseEther("3"),
        ethers.parseEther("0.5"),
        ethers.parseEther("4"),
        ethers.parseEther("0.25"),
        ethers.parseEther("8"),
      ];

      for (let i = 0; i < indices.length; i++) {
        await test.update(indices[i], values[i]);
      }

      // Verify all values are correct
      for (let i = 0; i < indices.length; i++) {
        const value = await test.getRangeSum(indices[i], indices[i]);
        expect(value).to.equal(values[i]);
      }
    });

    it("Should maintain consistency during stress updates", async function () {
      const { test } = await loadFixture(deployFixture);
      await test.init(100);

      // Perform many random updates
      for (let i = 0; i < 50; i++) {
        const index = i % 100;
        const value = ethers.parseEther(((i % 10) + 1).toString());
        await test.update(index, value);
      }

      // Tree should remain in valid state - check some ranges
      const range1 = await test.getRangeSum(0, 9);
      const range2 = await test.getRangeSum(50, 59);
      const total = await test.getTotalSum();

      expect(range1).to.be.gt(0);
      expect(range2).to.be.gt(0);
      expect(total).to.be.gt(0);
    });
  });

  describe("Extended Basic Operations", function () {
    it("Should update and get single values", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await expect(test.update(0, 100))
        .to.emit(test, "NodeUpdated")
        .withArgs(0, 100);

      await test.update(5, 200);
      await test.update(9, 300);

      expect(await test.getRangeSum(0, 0)).to.equal(100);
      expect(await test.getRangeSum(5, 5)).to.equal(200);
      expect(await test.getRangeSum(9, 9)).to.equal(300);
      expect(await test.getRangeSum(3, 3)).to.equal(WAD); // Default value is 1 WAD, not 0
    });

    it("Should handle index bounds correctly", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await expect(test.update(10, 100)).to.be.revertedWithCustomError(
        test,
        "IndexOutOfBounds"
      );

      await expect(test.getRangeSum(15, 15)).to.be.revertedWithCustomError(
        test,
        "IndexOutOfBounds"
      );
    });

    it("Should calculate total sum correctly", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.update(0, 100);
      await test.update(1, 200);
      await test.update(2, 300);

      // Total sum = 100 + 200 + 300 + 7 * WAD (remaining default values)
      const expectedSum = 100n + 200n + 300n + 7n * 10n ** 18n;
      expect(await test.getTotalSum()).to.equal(expectedSum);
    });

    it("Should handle repeated updates", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      await test.update(5, 100);
      expect(await test.getRangeSum(5, 5)).to.equal(100);

      await test.update(5, 200);
      expect(await test.getRangeSum(5, 5)).to.equal(200);

      await test.update(5, 0); // Set to zero
      expect(await test.getRangeSum(5, 5)).to.equal(0);
    });

    it("Should handle maximum values", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Use a large but safe value that won't cause overflow
      const maxValue = ethers.parseEther("1000000000"); // 1B ETH
      await test.update(0, maxValue);

      expect(await test.getRangeSum(0, 0)).to.equal(maxValue);
      // Total sum = maxValue + 9 * WAD
      const expectedSum = maxValue + 9n * 10n ** 18n;
      expect(await test.getTotalSum()).to.equal(expectedSum);
    });

    it("Should maintain total sum consistency after updates", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Track changes to verify sum calculations
      const initialSum = await test.getTotalSum();
      expect(initialSum).to.equal(ethers.parseEther("10")); // 10 * WAD

      // Update a few values
      await test.update(0, ethers.parseEther("5"));
      await test.update(4, ethers.parseEther("3"));
      await test.update(8, ethers.parseEther("7"));

      // Calculate expected sum: 5 + 3 + 7 + 7 * WAD (indices 1,2,3,5,6,7,9)
      const expectedSum =
        ethers.parseEther("5") +
        ethers.parseEther("3") +
        ethers.parseEther("7") +
        7n * WAD;
      expect(await test.getTotalSum()).to.equal(expectedSum);
    });

    it("Should handle boundary value updates", async function () {
      const { test } = await loadFixture(deploySmallTreeFixture);

      // Test first and last indices
      await test.update(0, ethers.parseEther("100"));
      await test.update(9, ethers.parseEther("200"));

      expect(await test.getRangeSum(0, 0)).to.equal(ethers.parseEther("100"));
      expect(await test.getRangeSum(9, 9)).to.equal(ethers.parseEther("200"));

      // Total = 100 + 200 + 8 * WAD
      const expectedSum =
        ethers.parseEther("100") + ethers.parseEther("200") + 8n * WAD;
      expect(await test.getTotalSum()).to.equal(expectedSum);
    });
  });
});

```


## test/unit/position/access.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  activePositionFixture,
  activePositionMarketFixture,
  createRealTestPosition,
} from "../../helpers/fixtures/position";
import { UNIT_TAG } from "../../helpers/tags";

describe(`${UNIT_TAG} Position Access Control`, function () {
  describe("Core Authorization", function () {
    it("should expose current core address", async function () {
      const { position, core } = await loadFixture(activePositionFixture);
      expect(await position.core()).to.equal(await core.getAddress());
    });

    it("should restrict updateCore to contract owner", async function () {
      const { position, core, keeper, alice } = await loadFixture(
        activePositionFixture
      );

      const newCore = ethers.Wallet.createRandom().address;

      await expect(
        position.connect(alice).updateCore(newCore)
      ).to.be.revertedWithCustomError(position, "OwnableUnauthorizedAccount");

      await expect(
        position.connect(keeper).updateCore(ethers.ZeroAddress)
      ).to.be.revertedWithCustomError(position, "ZeroAddress");

      await position.connect(keeper).updateCore(newCore);
      expect(await position.core()).to.equal(newCore);

      // restore original core
      await position.connect(keeper).updateCore(await core.getAddress());
    });
  });

  describe("onlyCore Modifier", function () {
    it("should allow core contract to mint positions", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { core, alice, marketId } = contracts;

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            100100,
            100200,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1", 6)
          )
      ).to.not.be.reverted;
    });

    it("should revert mintPosition when called directly by non-core", async function () {
      const { position, alice } = await loadFixture(activePositionFixture);

      await expect(
        position
          .connect(alice)
          .mintPosition(
            alice.address,
            1,
            100100,
            100200,
            ethers.parseUnits("0.01", 6)
          )
      )
        .to.be.revertedWithCustomError(position, "UnauthorizedCaller")
        .withArgs(alice.address);
    });

    it("should revert updateQuantity when called by non-core", async function () {
      const { position, alice } = await loadFixture(activePositionFixture);

      await expect(
        position.connect(alice).updateQuantity(1, ethers.parseUnits("0.02", 6))
      )
        .to.be.revertedWithCustomError(position, "UnauthorizedCaller")
        .withArgs(alice.address);
    });

    it("should revert burn when called by non-core", async function () {
      const { position, alice } = await loadFixture(activePositionFixture);

      await expect(position.connect(alice).burn(1))
        .to.be.revertedWithCustomError(position, "UnauthorizedCaller")
        .withArgs(alice.address);
    });
  });

  describe("Core Contract Interaction", function () {
    it("should allow core to increase position quantity", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, core, alice, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId,
        100100,
        100200,
        ethers.parseUnits("0.01", 6)
      );

      await expect(
        core
          .connect(alice)
          .increasePosition(
            positionId,
            ethers.parseUnits("0.005", 6),
            ethers.parseUnits("1", 6)
          )
      ).to.not.be.reverted;

      const positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(ethers.parseUnits("0.015", 6));
    });

    it("should allow core to decrease and burn position", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, core, alice, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId,
        100100,
        100200,
        ethers.parseUnits("0.01", 6)
      );

      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, ethers.parseUnits("0.01", 6), 0)
      ).to.not.be.reverted;

      await expect(
        position.getPosition(positionId)
      ).to.be.revertedWithCustomError(position, "PositionNotFound");
    });
  });

  describe("Security Edge Cases", function () {
    it("should handle sequential position operations safely", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, core, alice, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId,
        100100,
        100200,
        ethers.parseUnits("0.01", 6)
      );

      await expect(
        core
          .connect(alice)
          .increasePosition(
            positionId,
            ethers.parseUnits("0.002", 6),
            ethers.parseUnits("1", 6)
          )
      ).to.not.be.reverted;

      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, ethers.parseUnits("0.005", 6), 0)
      ).to.not.be.reverted;

      const positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(ethers.parseUnits("0.007", 6));
    });

    it("should prevent zero quantity minting even when called by core", async function () {
      const { position, alice } = await loadFixture(activePositionFixture);

      await expect(
        position
          .connect(alice)
          .mintPosition(
            alice.address,
            1,
            100100,
            100200,
            0
          )
      ).to.be.revertedWithCustomError(position, "UnauthorizedCaller");
    });
  });
});

```


## test/unit/position/erc721.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  positionFixture,
  positionMarketFixture,
  createTestPosition,
  activePositionFixture,
  activePositionMarketFixture,
  createRealTestPosition,
} from "../../helpers/fixtures/position";
import { UNIT_TAG } from "../../helpers/tags";

describe(`${UNIT_TAG} Position ERC721 Standard`, function () {
  describe("ERC721 Metadata", function () {
    it("should return correct name and symbol", async function () {
      const { position } = await loadFixture(activePositionFixture);

      expect(await position.name()).to.equal("CLMSR Position");
      expect(await position.symbol()).to.equal("CLMSR-POS");
    });

    it("should return dynamic tokenURI with position metadata", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      const tokenURI = await position.tokenURI(positionId);
      expect(tokenURI).to.include("data:application/json;base64,");

      // Decode and parse JSON
      const base64Data = tokenURI.split(",")[1];
      const jsonString = Buffer.from(base64Data, "base64").toString();
      const metadata = JSON.parse(jsonString);

      expect(metadata.name).to.include("CLMSR Position");
      expect(metadata.description).to.include("Position");
      expect(metadata.attributes).to.be.an("array");
      expect(metadata.attributes.length).to.equal(5);

      // Check specific attributes
      const marketIdAttr = metadata.attributes.find(
        (attr: any) => attr.trait_type === "Market ID"
      );
      expect(marketIdAttr.value).to.equal(marketId);
    });

    it("should revert tokenURI for non-existent token", async function () {
      const { position } = await loadFixture(activePositionFixture);

      await expect(position.tokenURI(999)).to.be.revertedWithCustomError(
        position,
        "PositionNotFound"
      );
    });
  });

  describe("ERC721 Balance and Ownership", function () {
    it("should track balances correctly", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, marketId } = contracts;

      expect(await position.balanceOf(alice.address)).to.equal(0);

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      expect(await position.balanceOf(alice.address)).to.equal(1);

      // Create another position
      await createRealTestPosition(contracts, alice, marketId, 100200, 100300);

      expect(await position.balanceOf(alice.address)).to.equal(2);
    });

    it("should return correct owner", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      expect(await position.ownerOf(positionId)).to.equal(alice.address);
    });

    it("should revert balanceOf for zero address", async function () {
      const { position } = await loadFixture(positionFixture);

      await expect(
        position.balanceOf(ethers.ZeroAddress)
      ).to.be.revertedWithCustomError(position, "ERC721InvalidOwner");
    });

    it("should revert ownerOf for non-existent token", async function () {
      const { position } = await loadFixture(positionFixture);

      await expect(position.ownerOf(999)).to.be.revertedWithCustomError(
        position,
        "ERC721NonexistentToken"
      );
    });
  });

  describe("ERC721 Transfers", function () {
    it("should transfer position correctly", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Transfer from alice to bob
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(1);
    });

    it("should update owner token tracking on transfer", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Check initial state
      let aliceTokens = await position.getPositionsByOwner(alice.address);
      let bobTokens = await position.getPositionsByOwner(bob.address);
      expect(aliceTokens.length).to.equal(1);
      expect(aliceTokens[0]).to.equal(positionId);
      expect(bobTokens.length).to.equal(0);

      // Transfer
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      // Check updated state
      aliceTokens = await position.getPositionsByOwner(alice.address);
      bobTokens = await position.getPositionsByOwner(bob.address);
      expect(aliceTokens.length).to.equal(0);
      expect(bobTokens.length).to.equal(1);
      expect(bobTokens[0]).to.equal(positionId);
    });

    it("should handle safe transfers", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Safe transfer should work
      await position
        .connect(alice)
        ["safeTransferFrom(address,address,uint256)"](
          alice.address,
          bob.address,
          positionId
        );

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
    });

    it("should revert transfer from non-owner", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      await expect(
        position
          .connect(charlie)
          .transferFrom(alice.address, bob.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InsufficientApproval");
    });
  });

  describe("ERC721 Approvals", function () {
    it("should approve and transfer", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Approve charlie to transfer
      await position.connect(alice).approve(charlie.address, positionId);
      expect(await position.getApproved(positionId)).to.equal(charlie.address);

      // Charlie transfers to bob
      await position
        .connect(charlie)
        .transferFrom(alice.address, bob.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
    });

    it("should set approval for all", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Set approval for all
      await position.connect(alice).setApprovalForAll(charlie.address, true);
      expect(await position.isApprovedForAll(alice.address, charlie.address)).to
        .be.true;

      // Charlie can now transfer
      await position
        .connect(charlie)
        .transferFrom(alice.address, bob.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
    });

    it("should clear approval on transfer", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Approve charlie
      await position.connect(alice).approve(charlie.address, positionId);
      expect(await position.getApproved(positionId)).to.equal(charlie.address);

      // Transfer clears approval
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      expect(await position.getApproved(positionId)).to.equal(
        ethers.ZeroAddress
      );
    });
  });

  describe("ERC165 Support", function () {
    it("should support required interfaces", async function () {
      const { position } = await loadFixture(activePositionFixture);

      expect(await position.supportsInterface("0x01ffc9a7")).to.be.true; // ERC165
      expect(await position.supportsInterface("0x80ac58cd")).to.be.true; // ERC721
      expect(await position.supportsInterface("0x5b5e139f")).to.be.true; // ERC721Metadata
      expect(await position.supportsInterface("0x780e9d63")).to.be.false; // No enumerable support
    });
  });
});

```


## test/unit/position/mock-abi.spec.ts

```typescript
import { expect } from "chai";
import fs from "fs";
import path from "path";
import { UNIT_TAG } from "../../helpers/tags";

describe(`${UNIT_TAG} MockPosition - ABI Golden Snapshot`, function () {
  const workspaceRoot = process.cwd();
  const artifactPath = path.join(
    workspaceRoot,
    "artifacts",
    "contracts",
    "mocks",
    "MockPosition.sol",
    "MockPosition.json"
  );
  const goldenPath = path.join(
    workspaceRoot,
    "test",
    "abi",
    "mock-position.abi.json"
  );

  const formatType = (param: any): string => {
    if (!param) {
      return "";
    }
    const base = param.type as string;
    if (base.startsWith("tuple")) {
      const suffix = base.slice("tuple".length);
      const inner = (param.components || []).map(formatType).join(",");
      return `(${inner})${suffix}`;
    }
    return base;
  };

  const formatInputs = (inputs: any[] | undefined, forEvent = false): string => {
    if (!inputs || inputs.length === 0) {
      return "";
    }
    return inputs
      .map((input) => {
        const type = formatType(input);
        if (forEvent && input.indexed) {
          return `indexed ${type}`;
        }
        return type;
      })
      .join(",");
  };

  const signatureForItem = (item: any): string => {
    switch (item.type) {
      case "function": {
        const inputs = formatInputs(item.inputs);
        const outputs = formatInputs(item.outputs);
        const mutability =
          item.stateMutability && item.stateMutability !== "nonpayable"
            ? ` ${item.stateMutability}`
            : "";
        const returnsClause = outputs ? ` returns (${outputs})` : "";
        return `function ${item.name}${mutability}(${inputs})${returnsClause}`.trim();
      }
      case "event": {
        const inputs = formatInputs(item.inputs, true);
        const anon = item.anonymous ? " anonymous" : "";
        return `event${anon} ${item.name}(${inputs})`.trim();
      }
      case "error": {
        const inputs = formatInputs(item.inputs);
        return `error ${item.name}(${inputs})`;
      }
      case "constructor": {
        const inputs = formatInputs(item.inputs);
        const mutability =
          item.stateMutability && item.stateMutability !== "nonpayable"
            ? ` ${item.stateMutability}`
            : "";
        return `constructor${mutability}(${inputs})`.trim();
      }
      case "fallback":
        return "fallback";
      case "receive":
        return "receive";
      default:
        return `${item.type}`;
    }
  };

  it("matches the golden snapshot", function () {
    const artifact = JSON.parse(fs.readFileSync(artifactPath, "utf8"));
    const current = (artifact.abi as any[])
      .map(signatureForItem)
      .sort();
    const golden = JSON.parse(fs.readFileSync(goldenPath, "utf8"));

    expect(current).to.deep.equal(golden);
  });
});

```


## test/unit/position/storage.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  positionFixture,
  positionMarketFixture,
  createTestPosition,
} from "../../helpers/fixtures/position";
import { setupMultipleMarkets } from "../../helpers/fixtures/core";
import { UNIT_TAG } from "../../helpers/tags";

describe(`${UNIT_TAG} Position Storage Management`, function () {
  this.timeout(120000);
  this.slow(60000);
  describe("Position Data Storage", function () {
    it("should store position data correctly", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, marketId } = contracts;

      const params = {
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
      };

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId,
        params.lowerTick,
        params.upperTick,
        params.quantity
      );

      const positionData = await position.getPosition(positionId);
      expect(positionData.marketId).to.equal(marketId);
      expect(positionData.lowerTick).to.equal(params.lowerTick);
      expect(positionData.upperTick).to.equal(params.upperTick);
      expect(positionData.quantity).to.equal(params.quantity);
      expect(positionData.createdAt).to.be.gt(0);
    });

    it("should handle multiple positions with different data", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      // Alice's position
      const aliceParams = {
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
      };

      const { positionId: alicePositionId } = await createTestPosition(
        contracts,
        alice,
        marketId,
        aliceParams.lowerTick,
        aliceParams.upperTick,
        aliceParams.quantity
      );

      // Bob's position with different parameters
      const bobParams = {
        lowerTick: 100300,
        upperTick: 100400,
        quantity: ethers.parseUnits("0.02", 6),
      };

      const { positionId: bobPositionId } = await createTestPosition(
        contracts,
        bob,
        marketId,
        bobParams.lowerTick,
        bobParams.upperTick,
        bobParams.quantity
      );

      // Verify both positions stored correctly
      const alicePosition = await position.getPosition(alicePositionId);
      const bobPosition = await position.getPosition(bobPositionId);

      expect(alicePosition.lowerTick).to.equal(aliceParams.lowerTick);
      expect(alicePosition.upperTick).to.equal(aliceParams.upperTick);
      expect(alicePosition.quantity).to.equal(aliceParams.quantity);

      expect(bobPosition.lowerTick).to.equal(bobParams.lowerTick);
      expect(bobPosition.upperTick).to.equal(bobParams.upperTick);
      expect(bobPosition.quantity).to.equal(bobParams.quantity);
    });

    it("should revert getPosition for non-existent position", async function () {
      const { position } = await loadFixture(positionFixture);

      await expect(position.getPosition(999)).to.be.revertedWithCustomError(
        position,
        "PositionNotFound"
      );
    });
  });

  describe("Owner Token Tracking", function () {
    it("should track owner tokens correctly with EnumerableSet", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, marketId } = contracts;

      // Initially no tokens
      let aliceTokens = await position.getPositionsByOwner(alice.address);
      expect(aliceTokens.length).to.equal(0);

      // Create first position
      const { positionId: positionId1 } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100100,
        100200
      );

      aliceTokens = await position.getPositionsByOwner(alice.address);
      expect(aliceTokens.length).to.equal(1);
      expect(aliceTokens[0]).to.equal(positionId1);

      // Create second position
      const { positionId: positionId2 } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100300,
        100400
      );

      aliceTokens = await position.getPositionsByOwner(alice.address);
      expect(aliceTokens.length).to.equal(2);
      expect(aliceTokens).to.include(positionId1);
      expect(aliceTokens).to.include(positionId2);
    });

    it("should update owner tracking on transfer", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Initial state
      let aliceTokens = await position.getPositionsByOwner(alice.address);
      let bobTokens = await position.getPositionsByOwner(bob.address);
      expect(aliceTokens.length).to.equal(1);
      expect(aliceTokens[0]).to.equal(positionId);
      expect(bobTokens.length).to.equal(0);

      // Transfer
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      // Updated state
      aliceTokens = await position.getPositionsByOwner(alice.address);
      bobTokens = await position.getPositionsByOwner(bob.address);
      expect(aliceTokens.length).to.equal(0);
      expect(bobTokens.length).to.equal(1);
      expect(bobTokens[0]).to.equal(positionId);
    });

    it("should handle multiple transfers correctly", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      // Create two positions for alice
      const { positionId: pos1 } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100100,
        100200
      );

      const { positionId: pos2 } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100300,
        100400
      );

      // Transfer pos1 to bob, pos2 to charlie
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, pos1);
      await position
        .connect(alice)
        .transferFrom(alice.address, charlie.address, pos2);

      // Verify final state
      const aliceTokens = await position.getPositionsByOwner(alice.address);
      const bobTokens = await position.getPositionsByOwner(bob.address);
      const charlieTokens = await position.getPositionsByOwner(charlie.address);

      expect(aliceTokens.length).to.equal(0);
      expect(bobTokens.length).to.equal(1);
      expect(bobTokens[0]).to.equal(pos1);
      expect(charlieTokens.length).to.equal(1);
      expect(charlieTokens[0]).to.equal(pos2);
    });
  });

  describe("Market-Specific Position Queries", function () {
    it("should filter positions by market correctly", async function () {
      const contracts = await loadFixture(positionFixture);
      const { position, alice } = contracts;

      const markets = await setupMultipleMarkets(contracts, 2);
      const marketId1 = markets[0].marketId;
      const marketId2 = markets[1].marketId;

      const baselineMarket1 = (
        await position.getUserPositionsInMarket(alice.address, marketId1)
      ).map((id: bigint) => id.toString());
      const baselineMarket2 = (
        await position.getUserPositionsInMarket(alice.address, marketId2)
      ).map((id: bigint) => id.toString());

      const { positionId: pos1 } = await createTestPosition(
        contracts,
        alice,
        marketId1,
        100100,
        100200
      );

      const { positionId: pos2 } = await createTestPosition(
        contracts,
        alice,
        marketId2,
        100100,
        100200
      );

      const { positionId: pos3 } = await createTestPosition(
        contracts,
        alice,
        marketId1,
        100300,
        100400
      );

      const market1Positions = (
        await position.getUserPositionsInMarket(alice.address, marketId1)
      ).map((id: bigint) => id.toString());
      const market2Positions = (
        await position.getUserPositionsInMarket(alice.address, marketId2)
      ).map((id: bigint) => id.toString());

      const newMarket1Positions = market1Positions.filter(
        (id: string) => !baselineMarket1.includes(id)
      );
      const newMarket2Positions = market2Positions.filter(
        (id: string) => !baselineMarket2.includes(id)
      );

      expect(newMarket1Positions.length).to.equal(2);
      expect(newMarket1Positions).to.include(pos1.toString());
      expect(newMarket1Positions).to.include(pos3.toString());

      expect(newMarket2Positions.length).to.equal(1);
      expect(newMarket2Positions[0]).to.equal(pos2.toString());
    });

    it("should return empty array for non-existent market", async function () {
      const { position, alice } = await loadFixture(positionFixture);

      const positions = await position.getUserPositionsInMarket(
        alice.address,
        999
      );
      expect(positions.length).to.equal(0);
    });

    it("should handle empty positions for user", async function () {
      const { position, alice, marketId } = await loadFixture(
        positionMarketFixture
      );

      const positions = await position.getUserPositionsInMarket(
        alice.address,
        marketId
      );
      expect(positions.length).to.equal(0);
    });

    it("should retain market token length when holes are created", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, core, alice, bob, marketId } = contracts;

      const { positionId: first } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100100,
        100200
      );
      const { positionId: second } = await createTestPosition(
        contracts,
        bob,
        marketId,
        100200,
        100300
      );
      const { positionId: third } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100300,
        100400
      );

      const lengthBefore = await position.getMarketTokenLength(marketId);
      expect(Number(lengthBefore)).to.equal(3);

      const secondData = await position.getPosition(second);
      await core
        .connect(bob)
        .decreasePosition(second, secondData.quantity, 0);

      const lengthAfterBurn = await position.getMarketTokenLength(marketId);
      expect(Number(lengthAfterBurn)).to.equal(3);
      expect(await position.getMarketTokenAt(marketId, 1)).to.equal(0);

      const { positionId: fourth } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100400,
        100500
      );

      const lengthAfterNew = await position.getMarketTokenLength(marketId);
      expect(Number(lengthAfterNew)).to.equal(4);
      expect(await position.getMarketTokenAt(marketId, 3)).to.equal(fourth);
      // Ensure original entries still accessible
      expect(await position.getMarketTokenAt(marketId, 0)).to.equal(first);
      expect(await position.getMarketTokenAt(marketId, 2)).to.equal(third);
    });
  });

  describe("Position ID Management", function () {
    it("should increment position IDs correctly", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, marketId } = contracts;

      const { positionId: pos1 } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      const { positionId: pos2 } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100200,
        100300
      );

      expect(pos2).to.equal(pos1 + 1n);
      expect(await position.getNextId()).to.equal(pos2 + 1n);
    });

    it("should maintain ID sequence after burns", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, core, alice, marketId } = contracts;

      const { positionId: pos1 } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Burn position by decreasing to zero
      const positionData = await position.getPosition(pos1);
      await core
        .connect(alice)
        .decreasePosition(pos1, positionData.quantity, 0);

      // Create new position - should continue sequence
      const { positionId: pos2 } = await createTestPosition(
        contracts,
        alice,
        marketId,
        100200,
        100300
      );

      expect(pos2).to.equal(pos1 + 1n);
    });
  });

  describe("Data Cleanup on Burn", function () {
    it("should clean up position data on burn", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, core, alice, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Verify position exists
      const positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.be.gt(0);

      // Burn position
      await core
        .connect(alice)
        .decreasePosition(positionId, positionData.quantity, 0);

      // Verify position data is cleaned up
      await expect(
        position.getPosition(positionId)
      ).to.be.revertedWithCustomError(position, "PositionNotFound");
    });

    it("should remove from owner tracking on burn", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, core, alice, marketId } = contracts;

      const { positionId } = await createTestPosition(
        contracts,
        alice,
        marketId
      );

      // Verify position is tracked
      let aliceTokens = await position.getPositionsByOwner(alice.address);
      expect(aliceTokens.length).to.equal(1);
      expect(aliceTokens[0]).to.equal(positionId);

      // Burn position
      const positionData = await position.getPosition(positionId);
      await core
        .connect(alice)
        .decreasePosition(positionId, positionData.quantity, 0);

      // Verify position is removed from tracking
      aliceTokens = await position.getPositionsByOwner(alice.address);
      expect(aliceTokens.length).to.equal(0);
    });
  });

  describe("Gas Optimization Verification", function () {
    it("should use EnumerableSet for O(1) operations", async function () {
      const contracts = await loadFixture(positionMarketFixture);
      const { position, alice, marketId } = contracts;

      // Create multiple positions
      const positions = [];
      for (let i = 0; i < 5; i++) {
        const { positionId } = await createTestPosition(
          contracts,
          alice,
          marketId,
          100100 + i * 10,
          100200 + i * 10
        );
        positions.push(positionId);
      }

      // Verify all positions are tracked
      const aliceTokens = await position.getPositionsByOwner(alice.address);
      expect(aliceTokens.length).to.equal(5);

      // Transfer middle position to test removal efficiency
      const middlePosition = positions[2];
      const { bob } = contracts;

      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, middlePosition);

      // Verify efficient removal
      const updatedAliceTokens = await position.getPositionsByOwner(
        alice.address
      );
      const bobTokens = await position.getPositionsByOwner(bob.address);

      expect(updatedAliceTokens.length).to.equal(4);
      expect(bobTokens.length).to.equal(1);
      expect(bobTokens[0]).to.equal(middlePosition);
      expect(updatedAliceTokens).to.not.include(middlePosition);
    });
  });
});

```


## test/unit/sdk/cost-proceeds.parity.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import Big from "big.js";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

import { CLMSRSDK } from "../../../clmsr-sdk/src/clmsr-sdk";
import {
  Market,
  MarketDistribution,
  MarketDistributionRaw,
  mapDistribution,
  Position as SDKPosition,
} from "../../../clmsr-sdk/src/types";
import * as MathUtils from "../../../clmsr-sdk/src/utils/math";
import {
  coreFixture,
  createActiveMarket,
  increaseToSafe,
} from "../../helpers/fixtures/core";

type Contracts = Awaited<ReturnType<typeof coreFixture>>;

async function snapshotDistribution(
  core: Contracts["core"],
  marketId: number,
  marketStruct: any
): Promise<MarketDistribution> {
  const minTick = Number(marketStruct.minTick);
  const maxTick = Number(marketStruct.maxTick);
  const tickSpacing = Number(marketStruct.tickSpacing);
  const numBins = Number(marketStruct.numBins);

  const binFactors: string[] = [];
  for (let i = 0; i < numBins; i++) {
    const lower = minTick + i * tickSpacing;
    const upper = lower + tickSpacing;
    const binSum = await core.getRangeSum(marketId, lower, upper);
    binFactors.push(binSum.toString());
  }

  const totalSum = await core.getRangeSum(marketId, minTick, maxTick);

  const raw: MarketDistributionRaw = {
    totalSum: totalSum.toString(),
    binFactors,
  };

  return mapDistribution(raw);
}

function toSDKMarket(marketStruct: any): Market {
  return {
    liquidityParameter: new Big(marketStruct.liquidityParameter.toString()),
    minTick: Number(marketStruct.minTick),
    maxTick: Number(marketStruct.maxTick),
    tickSpacing: Number(marketStruct.tickSpacing),
  };
}

function toMicro(amount: bigint): Big {
  return new Big(amount.toString());
}

async function latestPositionId(mockPosition: any): Promise<number> {
  return Number(await mockPosition.getNextId()) - 1;
}

function assertMicroDelta(
  label: string,
  sdkValue: Big,
  coreValue: bigint,
  tolerance: bigint = 1n
) {
  const delta = BigInt(sdkValue.toString()) - coreValue;
  expect(
    delta <= tolerance && delta >= -tolerance,
    `${label} delta ${delta.toString()} exceeds tolerance`
  ).to.equal(true);
}

describe("SDK ‚Üî Core cost/proceeds parity (public views)", function () {
  this.timeout(120_000);

  it("matches open cost and sell proceeds within ‚â§1 micro USDC using public APIs", async function () {
    const contracts = await loadFixture(coreFixture);
    const { core, keeper, alice, mockPosition } = contracts;

    const { marketId } = await createActiveMarket(contracts);

    const marketStruct = await core.getMarket(marketId);
    const sdkMarket = toSDKMarket(marketStruct);

    const initialDistribution = await snapshotDistribution(
      core,
      marketId,
      marketStruct
    );

    const sdk = new CLMSRSDK();

    const tickSpacing = sdkMarket.tickSpacing;

    const additionalCostCases = [
      { offset: 5, width: 3, quantity: 1_000_000n },   // narrow, 1 USDC
      { offset: 15, width: 8, quantity: 3_000_000n },  // mid, 3 USDC
      { offset: 30, width: 12, quantity: 12_500_000n }, // wide, 12.5 USDC
    ];

    for (const testCase of additionalCostCases) {
      const lowerTick = sdkMarket.minTick + testCase.offset * tickSpacing;
      const upperTick = lowerTick + testCase.width * tickSpacing;

      const sdkCost = sdk.calculateOpenCost(
        lowerTick,
        upperTick,
        toMicro(testCase.quantity),
        initialDistribution,
        sdkMarket
      ).cost;

      const coreCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        testCase.quantity
      );

      assertMicroDelta(
        `Open cost offset=${testCase.offset},width=${testCase.width}`,
        sdkCost,
        coreCost
      );
    }

    const baseLowerTick = sdkMarket.minTick + 20 * tickSpacing;
    const baseUpperTick = baseLowerTick + 5 * tickSpacing;
    const baseQuantity = 2_500_000n; // 2.5 USDC

    const sdkOpen = sdk.calculateOpenCost(
      baseLowerTick,
      baseUpperTick,
      toMicro(baseQuantity),
      initialDistribution,
      sdkMarket
    ).cost;

    const coreOpen = await core.calculateOpenCost(
      marketId,
      baseLowerTick,
      baseUpperTick,
      baseQuantity
    );

    assertMicroDelta("Base open cost", sdkOpen, coreOpen);

    const chunkQuantity = 4_000_000n; // 4 USDC > max chunk quantity
    const sdkChunk = sdk.calculateOpenCost(
      baseLowerTick,
      baseUpperTick,
      toMicro(chunkQuantity),
      initialDistribution,
      sdkMarket
    ).cost;
    const coreChunk = await core.calculateOpenCost(
      marketId,
      baseLowerTick,
      baseUpperTick,
      chunkQuantity
    );
    assertMicroDelta("Chunked open cost", sdkChunk, coreChunk);

    const sellLowerTick = sdkMarket.minTick + 10 * tickSpacing;
    const sellUpperTick = sellLowerTick + 6 * tickSpacing;
    const positionQuantity = 6_000_000n; // 6 USDC
    const maxCost = BigInt(10_000_000_000_000n); // generous cap

    const positionTx = await core
      .connect(alice)
      .openPosition(
        marketId,
        sellLowerTick,
        sellUpperTick,
        positionQuantity,
        maxCost
      );
    await positionTx.wait();

    const positionId = await latestPositionId(mockPosition);

    await increaseToSafe((await ethers.provider.getBlock("latest"))!.timestamp + 1);

    const distributionAfterOpen = await snapshotDistribution(
      core,
      marketId,
      await core.getMarket(marketId)
    );

    const positionData = await mockPosition.getPosition(positionId);

    const sdkPosition: SDKPosition = {
      lowerTick: Number(positionData.lowerTick),
      upperTick: Number(positionData.upperTick),
      quantity: new Big(positionData.quantity.toString()),
    };

    const sellQuantity = positionQuantity / 2n;

    const sdkSell = sdk.calculateDecreaseProceeds(
      sdkPosition,
      toMicro(sellQuantity),
      distributionAfterOpen,
      sdkMarket
    ).proceeds;

    const coreSell = await core.calculateDecreaseProceeds(positionId, sellQuantity);
    assertMicroDelta("Sell proceeds", sdkSell, coreSell);

    const sdkClose = sdk.calculateCloseProceeds(
      sdkPosition,
      distributionAfterOpen,
      sdkMarket
    ).proceeds;
    const coreClose = await core.calculateCloseProceeds(positionId);
    assertMicroDelta("Close proceeds", sdkClose, coreClose);

    const additionalSellQuantities = [
      positionQuantity / 4n,
      (positionQuantity * 3n) / 4n,
    ];

    for (const qty of additionalSellQuantities) {
      const sdkSellVariant = sdk.calculateDecreaseProceeds(
        sdkPosition,
        toMicro(qty),
        distributionAfterOpen,
        sdkMarket
      ).proceeds;

      const coreSellVariant = await core.calculateDecreaseProceeds(
        positionId,
        qty
      );

      assertMicroDelta(
        `Sell proceeds qty=${qty.toString()}`,
        sdkSellVariant,
        coreSellVariant
      );
    }
  });
});

```


## test/unit/sdk/safeExp.parity.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import Big from "big.js";

import { safeExp } from "../../../clmsr-sdk/src/utils/math";
import { unitFixture } from "../../helpers/fixtures/core";

type HarnessContracts = Awaited<ReturnType<typeof deployHarnessFixture>>;

async function deployHarnessFixture() {
  const libs = await unitFixture();

  const harnessFactory = await ethers.getContractFactory("CLMSRMathHarness", {
    libraries: {
      FixedPointMathU: await libs.fixedPointMathU.getAddress(),
      LazyMulSegmentTree: await libs.lazyMulSegmentTree.getAddress(),
    },
  });

  const harness = await harnessFactory.deploy();
  await harness.waitForDeployment();

  return { harness };
}

function toBigInt(big: Big): bigint {
  return BigInt(big.toFixed(0, Big.roundDown));
}

describe("SDK ‚Üî Core safeExp parity", function () {
  it("matches contract _safeExp outputs across representative samples", async function () {
    const { harness }: HarnessContracts = await loadFixture(deployHarnessFixture);

    const alphaSamples = [
      ethers.parseEther("0.001"),
      ethers.parseEther("0.01"),
      ethers.parseEther("0.05"),
      ethers.parseEther("0.5"),
      ethers.parseEther("1"),
    ];

const ratioSamples = ["0", "0.0625", "0.25", "0.5", "1"];

for (const alpha of alphaSamples) {
      const alphaBig = new Big(alpha.toString());

      for (const ratio of ratioSamples) {
        const qBig = alphaBig.mul(ratio);
        const q = toBigInt(qBig);

        const onChain = await harness.exposedSafeExp(q, alpha);
        const sdk = safeExp(new Big(q.toString()), alphaBig);
        const sdkAsBigInt = toBigInt(sdk);
        const delta =
          onChain >= sdkAsBigInt ? onChain - sdkAsBigInt : sdkAsBigInt - onChain;

        expect(
          delta,
          `safeExp mismatch alpha=${alpha.toString()} ratio=${ratio}`
        ).to.lte(1_000_000_000_000n); // ‚â§ 1 micro WAD tolerance
      }
    }
  });

  it("handles large multi-chunk quantities consistently", async function () {
    const { harness }: HarnessContracts = await loadFixture(deployHarnessFixture);

    const alpha = ethers.parseEther("0.75"); // realistic liquidity parameter
    const alphaBig = new Big(alpha.toString());

    // Quantity pushes chunking but stays within overflow-safe bounds
    const qBig = alphaBig.mul("10");
    const q = toBigInt(qBig);

    const onChain = await harness.exposedSafeExp(q, alpha);
    const sdk = safeExp(new Big(q.toString()), alphaBig);
    const sdkAsBigInt = toBigInt(sdk);
    const delta =
      onChain >= sdkAsBigInt ? onChain - sdkAsBigInt : sdkAsBigInt - onChain;

    expect(delta).to.lte(1_000_000_000_000n); // ‚â§ 1 micro WAD tolerance
  });
});

```


## test/integration/core/abi-golden.spec.ts

```typescript
import { expect } from "chai";
import fs from "fs";
import path from "path";
import { COMPONENT_TAG } from "../../helpers/tags";

describe(`${COMPONENT_TAG} CLMSRMarketCore - ABI Golden Snapshot`, function () {
  const workspaceRoot = process.cwd();
  const artifactPath = path.join(
    workspaceRoot,
    "artifacts",
    "contracts",
    "core",
    "CLMSRMarketCore.sol",
    "CLMSRMarketCore.json"
  );
  const goldenPath = path.join(
    workspaceRoot,
    "test",
    "abi",
    "clmsr-market-core.abi.json"
  );

  const formatType = (param: any): string => {
    if (!param) {
      return "";
    }
    const base = param.type as string;
    if (base.startsWith("tuple")) {
      const suffix = base.slice("tuple".length);
      const inner = (param.components || []).map(formatType).join(",");
      return `(${inner})${suffix}`;
    }
    return base;
  };

  const formatInputs = (inputs: any[] | undefined, forEvent = false): string => {
    if (!inputs || inputs.length === 0) {
      return "";
    }
    return inputs
      .map((input) => {
        const type = formatType(input);
        if (forEvent && input.indexed) {
          return `indexed ${type}`;
        }
        return type;
      })
      .join(",");
  };

  const signatureForItem = (item: any): string => {
    switch (item.type) {
      case "function": {
        const inputs = formatInputs(item.inputs);
        const outputs = formatInputs(item.outputs);
        const mutability =
          item.stateMutability && item.stateMutability !== "nonpayable"
            ? ` ${item.stateMutability}`
            : "";
        const returnsClause = outputs ? ` returns (${outputs})` : "";
        return `function ${item.name}${mutability}(${inputs})${returnsClause}`.trim();
      }
      case "event": {
        const inputs = formatInputs(item.inputs, true);
        const anon = item.anonymous ? " anonymous" : "";
        return `event${anon} ${item.name}(${inputs})`.trim();
      }
      case "error": {
        const inputs = formatInputs(item.inputs);
        return `error ${item.name}(${inputs})`;
      }
      case "constructor": {
        const inputs = formatInputs(item.inputs);
        const mutability =
          item.stateMutability && item.stateMutability !== "nonpayable"
            ? ` ${item.stateMutability}`
            : "";
        return `constructor${mutability}(${inputs})`.trim();
      }
      case "fallback":
        return "fallback";
      case "receive":
        return "receive";
      default:
        return `${item.type}`;
    }
  };

  it("matches the golden snapshot", function () {
    const artifact = JSON.parse(fs.readFileSync(artifactPath, "utf8"));
    const current = (artifact.abi as any[])
      .map(signatureForItem)
      .sort();
    const golden = JSON.parse(fs.readFileSync(goldenPath, "utf8"));

    expect(current).to.deep.equal(golden);
  });
});

```


## test/integration/core/access-control.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  createActiveMarketFixture,
  createMarketWithConfig,
  setMarketActivation,
  setupActiveMarket,
  unitFixture,
  toSettlementValue,
  ALPHA,
  TICK_COUNT,
  MARKET_DURATION,
} from "../../helpers/fixtures/core";
import { COMPONENT_TAG } from "../../helpers/tags";

describe(`${COMPONENT_TAG} CLMSRMarketCore - Access Control`, function () {
  describe("Role Management", function () {
    it("Should have correct initial admin roles", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      // Manager should be able to pause/unpause
      await expect(core.connect(keeper).pause("Test pause"))
        .to.emit(core, "EmergencyPaused")
        .withArgs(keeper.address, "Test pause"); // reason ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÍ∞Ä

      expect(await core.isPaused()).to.be.true;

      // Test unpause functionality
      await expect(core.connect(keeper).unpause())
        .to.emit(core, "EmergencyUnpaused")
        .withArgs(keeper.address);

      expect(await core.isPaused()).to.be.false;
    });

    it("Should reject unauthorized manager operations", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      // Non-manager should not be able to pause
      await expect(core.connect(alice).pause("Unauthorized"))
        .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
        .withArgs(alice.address);
    });
  });

  describe("Trading Access", function () {
    it("Should allow public trading operations", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper, alice, paymentToken } = contracts;

      // Create a test market using helper (already active)
      const { marketId } = await setupActiveMarket(contracts);

      // Approve tokens for alice
      await paymentToken
        .connect(alice)
        .approve(await core.getAddress(), ethers.parseUnits("1000", 6));

      // Alice should be able to open position directly (no authorization needed)
      const quantity = 100;
      const maxCost = ethers.parseUnits("10", 6); // 10 USDC

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            100100,
            100200,
            quantity,
            maxCost
          )
      ).to.not.be.reverted;
    });
  });

  describe("Market Activation Controls", function () {
    it("Should restrict activation toggles to owner", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper, alice } = contracts;

      const now = await time.latest();
      const startTime = now + 600;
      const endTime = startTime + MARKET_DURATION;
      const marketId = await createMarketWithConfig(core, keeper, {
        minTick: 100000,
        maxTick: 100990,
        tickSpacing: 10,
        startTime,
        endTime,
        liquidityParameter: ALPHA,
      });

      await expect(
        core.connect(alice).setMarketActive(marketId, true)
      )
        .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
        .withArgs(alice.address);

      const tx = core.connect(keeper).setMarketActive(marketId, true);
      await expect(tx)
        .to.emit(core, "MarketActivationUpdated")
        .withArgs(BigInt(marketId), true);
    });

    it("Should prevent activation changes after settlement", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const now = await time.latest();
      const startTime = now + 600;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;
      const marketId = await createMarketWithConfig(core, keeper, {
        minTick: 100000,
        maxTick: 100990,
        tickSpacing: 10,
        startTime,
        endTime,
        liquidityParameter: ALPHA,
        settlementTime,
      });

      await setMarketActivation(core, keeper, marketId, true);
      await time.increaseTo(settlementTime + 1);

      await core
        .connect(keeper)
        .settleMarket(marketId, toSettlementValue(100450));

      await expect(
        core.connect(keeper).setMarketActive(marketId, true)
      ).to.be.revertedWithCustomError(core, "MarketAlreadySettled");
    });

    it("Should be idempotent when toggling to same state", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const now = await time.latest();
      const startTime = now + 600;
      const endTime = startTime + MARKET_DURATION;
      const marketId = await createMarketWithConfig(core, keeper, {
        minTick: 100000,
        maxTick: 100990,
        tickSpacing: 10,
        startTime,
        endTime,
        liquidityParameter: ALPHA,
      });

      const activateTx = core.connect(keeper).setMarketActive(marketId, true);
      await expect(activateTx)
        .to.emit(core, "MarketActivationUpdated")
        .withArgs(BigInt(marketId), true);

      const noopTx = core.connect(keeper).setMarketActive(marketId, true);
      await expect(noopTx).to.not.emit(core, "MarketActivationUpdated");
    });
  });

  describe("Position Contract Integration", function () {
    it("Should have correct position contract reference", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, mockPosition } = contracts;

      // Core should reference the correct position contract
      expect(await core.getPositionContract()).to.equal(
        await mockPosition.getAddress()
      );
    });
  });

  describe("Manager Delegation", function () {
    it("Should emit ManagerUpdated and update manager pointer", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper, manager, lazyMulSegmentTree } = contracts as any;

      const ManagerFactory = await ethers.getContractFactory(
        "CLMSRMarketManager",
        {
          libraries: {
            LazyMulSegmentTree: await lazyMulSegmentTree.getAddress(),
          },
        }
      );
      const newManager = await ManagerFactory.deploy();
      await newManager.waitForDeployment();

      await expect(
        core.connect(keeper).setManager(await newManager.getAddress())
      )
        .to.emit(core, "ManagerUpdated")
        .withArgs(
          await manager.getAddress(),
          await newManager.getAddress()
        );

      expect(await core.manager()).to.equal(
        await newManager.getAddress()
      );
    });

    it("Should revert lifecycle calls when manager is not configured", async function () {
      const base = await loadFixture(unitFixture);
      const { deployer, fixedPointMathU, lazyMulSegmentTree } = base as any;

      const MockERC20Factory = await ethers.getContractFactory("MockERC20");
      const paymentToken = await MockERC20Factory.deploy("USD Coin", "USDC", 6);
      await paymentToken.waitForDeployment();

      const MockPositionFactory = await ethers.getContractFactory("MockPosition");
      const mockPosition = await MockPositionFactory.deploy();
      await mockPosition.waitForDeployment();

      const CoreFactory = await ethers.getContractFactory(
        "CLMSRMarketCore",
        {
          libraries: {
            FixedPointMathU: await fixedPointMathU.getAddress(),
            LazyMulSegmentTree: await lazyMulSegmentTree.getAddress(),
          },
        }
      );
      const core = await CoreFactory.deploy();
      await core.waitForDeployment();

      await core.initialize(
        await paymentToken.getAddress(),
        await mockPosition.getAddress()
      );

      const now = await time.latest();
      const startTime = now + 60;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      await expect(
        core
          .connect(deployer)
          .createMarket(
            100000,
            100000 + (TICK_COUNT - 1) * 10,
            10,
            startTime,
            endTime,
            settlementTime,
            ALPHA,
            ethers.ZeroAddress
          )
      ).to.be.revertedWithCustomError(core, "ManagerNotSet");
    });
  });
});

```


## test/integration/core/boundaries/liquidity.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  createActiveMarketFixture,
  setupCustomMarket,
} from "../../../helpers/fixtures/core";
import { COMPONENT_TAG } from "../../../helpers/tags";

describe(`${COMPONENT_TAG} CLMSRMarketCore - Liquidity Parameter Boundaries`, function () {
  describe("Factor Limits", function () {
    it("Should handle trades that approach MIN_FACTOR boundary", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, mockPosition, alice, keeper } = contracts;

      const extremeAlpha = ethers.parseEther("1000"); // High alpha for extreme testing
      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: extremeAlpha,
      });

      // Use very small quantity to approach MIN_FACTOR
      const verySmallQuantity = ethers.parseUnits("0.000001", 6);

      const tradeParams = {
        marketId,
        lowerTick: 100450,
        upperTick: 100550,
        quantity: verySmallQuantity,
        maxCost: ethers.parseUnits("1", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should handle trades that approach MAX_FACTOR boundary", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, mockPosition, alice, keeper } = contracts;

      const extremeAlpha = ethers.parseEther("1000"); // High alpha for extreme testing
      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: extremeAlpha,
      });

      // Use moderately large quantity to approach MAX_FACTOR without triggering safety guards
      const largeQuantity = ethers.parseUnits("10", 6);

      const tradeParams = {
        marketId,
        lowerTick: 100450,
        upperTick: 100550,
        quantity: largeQuantity,
        maxCost: ethers.parseUnits("1000000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should revert when factor exceeds MAX_FACTOR", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, mockPosition, alice, keeper } = contracts;

      const extremeAlpha = ethers.parseEther("1000"); // High alpha for extreme testing
      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: extremeAlpha,
      });

      // Use extremely large quantity to exceed MAX_FACTOR
      const extremeQuantity = ethers.parseUnits("100000", 6);

      const tradeParams = {
        marketId,
        lowerTick: 100450,
        upperTick: 100550,
        quantity: extremeQuantity,
        maxCost: ethers.parseUnits("10000000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.reverted;
    });
  });

  describe("Liquidity Parameter Boundaries", function () {
    it("Should handle minimum liquidity parameter", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, mockPosition, keeper, alice } = contracts;

      const minAlpha = ethers.parseEther("0.001"); // MIN_LIQUIDITY_PARAMETER
      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 3,
        alpha: minAlpha,
      });

      const tradeParams = {
        marketId,
        lowerTick: 100450,
        upperTick: 100550,
        quantity: ethers.parseUnits("0.001", 6), // Use very small quantity for extreme alpha
        maxCost: ethers.parseUnits("1000000", 6), // Use very large maxCost
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should handle maximum liquidity parameter", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, mockPosition, keeper, alice } = contracts;

      const maxAlpha = ethers.parseEther("1000"); // MAX_LIQUIDITY_PARAMETER
      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 4,
        alpha: maxAlpha,
      });

      const tradeParams = {
        marketId,
        lowerTick: 100450,
        upperTick: 100550,
        quantity: ethers.parseUnits("0.001", 6), // Use very small quantity for extreme alpha
        maxCost: ethers.parseUnits("1000000", 6), // Use very large maxCost
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });
  });

  describe("Extreme Alpha Values with Large Trades", function () {
    it("Should handle low alpha values with moderate trades", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper, alice } = contracts;

      // Test with relatively low alpha using setupCustomMarket
      const { marketId: lowAlphaMarketId } = await setupCustomMarket(
        contracts,
        {
          marketId: 10,
          alpha: ethers.parseEther("0.1"), // 0.1 ETH (higher than minimum to avoid overflow)
        }
      );

      // Use reasonable trade size
      const tradeParams = {
        marketId: lowAlphaMarketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("1", 6), // 1 USDC
        maxCost: ethers.parseUnits("10", 6), // Allow up to 10 USDC cost
      };

      const lowAlphaCost = await core.calculateOpenCost(
        lowAlphaMarketId,
        100100,
        100200,
        tradeParams.quantity
      );

      expect(lowAlphaCost).to.be.gt(0);

      // Test with high alpha
      const { marketId: highAlphaMarketId } = await setupCustomMarket(
        contracts,
        {
          marketId: 11,
          alpha: ethers.parseEther("100"), // 100 ETH (high liquidity)
        }
      );

      // Same trade with high alpha should have lower price impact
      const highAlphaCost = await core.calculateOpenCost(
        highAlphaMarketId,
        100100,
        100200,
        tradeParams.quantity
      );

      // Cost should be lower with high alpha
      expect(highAlphaCost).to.be.lt(lowAlphaCost);
      expect(highAlphaCost).to.be.gt(0);
    });

    it("Should handle extreme minimum alpha with tiny trades", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      // Test that extreme minimum alpha with tiny trades can cause overflow
      // This is expected behavior for unrealistic parameter combinations
      const { marketId: extremeMinAlphaMarketId } = await setupCustomMarket(
        contracts,
        {
          marketId: 12,
          alpha: ethers.parseEther("0.001"), // MIN_LIQUIDITY_PARAMETER
        }
      );

      // Tiny trades succeed thanks to chunk splitting
      const tinyQuantity = ethers.parseUnits("0.000001", 6); // 1 micro USDC
      const tinyCost = await core.calculateOpenCost(
        extremeMinAlphaMarketId,
        100100,
        100200,
        tinyQuantity
      );
      expect(tinyCost).to.be.gt(0);

      // Slightly larger trades hit precision limits and revert deterministically
      await expect(
        core.calculateOpenCost(
          extremeMinAlphaMarketId,
          100100,
          100200,
          ethers.parseUnits("0.1", 6)
        )
      ).to.be.revertedWithCustomError(core, "MathMulOverflow");
    });

    it("Should demonstrate cost difference between extreme alpha values", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      // Low alpha market
      const { marketId: lowAlphaMarketId } = await setupCustomMarket(
        contracts,
        {
          marketId: 20,
          alpha: ethers.parseEther("0.01"), // Low liquidity
        }
      );

      // High alpha market
      const { marketId: highAlphaMarketId } = await setupCustomMarket(
        contracts,
        {
          marketId: 21,
          alpha: ethers.parseEther("100"), // High liquidity
        }
      );

      const testQuantity = ethers.parseUnits("0.01", 6); // 0.01 USDC

      const lowAlphaCost = await core.calculateOpenCost(
        lowAlphaMarketId,
        100450,
        100550,
        testQuantity
      );

      const highAlphaCost = await core.calculateOpenCost(
        highAlphaMarketId,
        100450,
        100550,
        testQuantity
      );

      // Low alpha should result in higher cost (less liquidity)
      expect(lowAlphaCost).to.be.gt(highAlphaCost);

      // Both should be positive
      expect(lowAlphaCost).to.be.gt(0);
      expect(highAlphaCost).to.be.gt(0);

      // The difference should be significant
      const costRatio = (lowAlphaCost * 100n) / highAlphaCost;
      expect(costRatio).to.be.gt(110n); // At least 10% difference
    });
  });

  describe("Liquidity Parameter Validation", function () {
    it("Should validate tick count limits", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;
      const alpha = ethers.parseEther("0.1");

      const createMarket = core.connect(keeper)[
        "createMarket(int256,int256,int256,uint64,uint64,uint64,uint256,address)"
      ];

      // Test zero tick count - create market with minTick >= maxTick
      await expect(
        createMarket(
          100000, // minTick
          100000, // maxTick (same as minTick = 0 ticks)
          10, // tickSpacing
          startTime,
          endTime,
          endTime + 3600,
          alpha
        )
      ).to.be.revertedWithCustomError(core, "InvalidMarketParameters");

      // Test excessive tick count - create market with huge range
      await expect(
        createMarket(
          100000, // minTick
          10100990, // maxTick (10M+ ticks)
          10, // tickSpacing
          startTime,
          endTime,
          endTime + 3600,
          alpha
        )
      ).to.be.revertedWithCustomError(core, "InvalidRangeCount");
    });

    it("Should validate liquidity parameter limits", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      const createMarket = core.connect(keeper)[
        "createMarket(int256,int256,int256,uint64,uint64,uint64,uint256,address)"
      ];

      const settlementTime = endTime + 3600;

      const minAlpha = await core.MIN_LIQUIDITY_PARAMETER();
      const maxAlpha = await core.MAX_LIQUIDITY_PARAMETER();

      const belowMinAlpha = minAlpha > 0n ? minAlpha - 1n : 0n;
      const aboveMaxAlpha = maxAlpha + 1n;

      // Test too small alpha
      await expect(
        createMarket(
          100000, // minTick
          100990, // maxTick
          10, // tickSpacing
          startTime,
          endTime,
          settlementTime,
          belowMinAlpha // below MIN_LIQUIDITY_PARAMETER
        )
      ).to.be.revertedWithCustomError(core, "InvalidLiquidityParameter");

      // Test too large alpha
      await expect(
        createMarket(
          100000, // minTick
          100990, // maxTick
          10, // tickSpacing
          startTime,
          endTime,
          settlementTime,
          aboveMaxAlpha // above MAX_LIQUIDITY_PARAMETER
        )
      ).to.be.revertedWithCustomError(core, "InvalidLiquidityParameter");
    });

    it("Should check constants are correct", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;

      expect(await core.MAX_TICK_COUNT()).to.equal(1_000_000);
      expect(await core.MIN_LIQUIDITY_PARAMETER()).to.equal(
        ethers.parseEther("0.001")
      );
      expect(await core.MAX_LIQUIDITY_PARAMETER()).to.equal(
        ethers.parseEther("100000")
      );
    });
  });

  describe("Liquidity Parameter Boundaries", function () {
    it("Should handle minimum liquidity parameter", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, mockPosition, keeper, alice } = contracts;

      const minAlpha = ethers.parseEther("0.001"); // MIN_LIQUIDITY_PARAMETER
      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 3,
        alpha: minAlpha,
      });

      const tradeParams = {
        marketId,
        lowerTick: 100450,
        upperTick: 100550,
        quantity: ethers.parseUnits("0.001", 6), // Use very small quantity for extreme alpha
        maxCost: ethers.parseUnits("1000000", 6), // Use very large maxCost
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should handle maximum liquidity parameter", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, mockPosition, keeper, alice } = contracts;

      const maxAlpha = ethers.parseEther("1000"); // MAX_LIQUIDITY_PARAMETER
      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 4,
        alpha: maxAlpha,
      });

      const tradeParams = {
        marketId,
        lowerTick: 100450,
        upperTick: 100550,
        quantity: ethers.parseUnits("0.001", 6), // Use very small quantity for extreme alpha
        maxCost: ethers.parseUnits("1000000", 6), // Use very large maxCost
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });
  });
});

```


## test/integration/core/boundaries/quantity.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  createActiveMarketFixture,
  setupCustomMarket,
} from "../../../helpers/fixtures/core";
import { COMPONENT_TAG } from "../../../helpers/tags";

describe(`${COMPONENT_TAG} CLMSRMarketCore - Quantity Boundaries`, function () {
  describe("Quantity Validation", function () {
    it("Should handle minimum possible quantity (1 wei)", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("0.1"),
      });

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: 1n, // 1 wei
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should revert with zero quantity", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("0.1"),
      });

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: 0n, // zero quantity
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "InvalidQuantity");
    });

    it("Should handle very small quantities without underflow", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("1"), // Higher alpha to handle small quantities
      });

      const smallQuantity = ethers.parseUnits("0.000001", 6); // 1 micro USDC

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: smallQuantity,
        maxCost: ethers.parseUnits("1000", 6),
      };

      // Should be able to calculate cost without underflow
      const cost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        smallQuantity
      );
      expect(cost).to.be.gt(0);

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });
  });

  describe("Chunk-Split Boundaries", function () {
    it("Should handle quantity exactly at chunk boundary", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("0.1"),
      });

      const CHUNK_BOUNDARY_QUANTITY = ethers.parseUnits("0.013", 6);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: CHUNK_BOUNDARY_QUANTITY,
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should handle quantity slightly above chunk boundary", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("0.1"),
      });

      const CHUNK_BOUNDARY_QUANTITY = ethers.parseUnits("0.013", 6);
      const slightlyAbove =
        CHUNK_BOUNDARY_QUANTITY + ethers.parseUnits("0.001", 6);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: slightlyAbove,
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should handle multiple chunk splits correctly", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("0.1"),
      });

      const CHUNK_BOUNDARY_QUANTITY = ethers.parseUnits("0.013", 6);
      const multipleChunks = CHUNK_BOUNDARY_QUANTITY * 3n;

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: multipleChunks,
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should maintain cost consistency across chunk splits", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("0.1"),
      });

      const CHUNK_BOUNDARY_QUANTITY = ethers.parseUnits("0.013", 6);

      const singleCost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        CHUNK_BOUNDARY_QUANTITY
      );

      const multipleCost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        CHUNK_BOUNDARY_QUANTITY * 2n
      );

      // Multiple chunks should cost more than single chunk
      expect(multipleCost).to.be.gt(singleCost);
    });

    it("Should handle massive chunk-split scenarios", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("0.1"),
      });

      // Calculate quantity that will require 12+ chunks
      const CHUNK_BOUNDARY_QUANTITY = ethers.parseUnits("0.013", 6);
      const massiveQuantity = CHUNK_BOUNDARY_QUANTITY * 12n; // 12x chunk boundary

      const massiveCost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        massiveQuantity
      );

      // Should handle massive chunk-split without reverting
      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            100100,
            100200,
            massiveQuantity,
            massiveCost + ethers.parseUnits("1000", 6)
          )
      ).to.not.be.reverted;

      // Verify position was created correctly
      const positionId = 1n;
      const position = await core
        .positionContract()
        .then((addr) => ethers.getContractAt("ICLMSRPosition", addr))
        .then((contract) => contract.getPosition(positionId));

      expect(position.quantity).to.equal(massiveQuantity);
    });
  });

  describe("Mathematical Precision Edge Cases", function () {
    it("Should handle chunk boundary calculations precisely", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: ethers.parseEther("0.1"),
      });

      const CHUNK_BOUNDARY_QUANTITY = ethers.parseUnits("0.013", 6);

      const cost1 = await core.calculateOpenCost(
        marketId,
        100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100200, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        CHUNK_BOUNDARY_QUANTITY
      );

      // Test multiple calculations for consistency
      for (let i = 0; i < 5; i++) {
        const cost2 = await core.calculateOpenCost(
          marketId,
          100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100200, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          CHUNK_BOUNDARY_QUANTITY
        );
        expect(cost2).to.equal(cost1);
      }
    });

    it("Should handle multiple chunk calculations consistently", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: ethers.parseEther("0.1"),
      });

      const CHUNK_BOUNDARY_QUANTITY = ethers.parseUnits("0.013", 6);

      await core.connect(alice).openPosition(
        marketId,
        100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100200, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        CHUNK_BOUNDARY_QUANTITY,
        ethers.parseUnits("1000", 6)
      );

      // Calculate cost for second chunk
      const cost2 = await core.calculateOpenCost(
        marketId,
        100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100200, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        CHUNK_BOUNDARY_QUANTITY
      );

      await expect(
        core.connect(alice).openPosition(
          marketId,
          100300, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100400, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          CHUNK_BOUNDARY_QUANTITY,
          ethers.parseUnits("1000", 6)
        )
      ).to.not.be.reverted;

      // Second chunk should cost more due to price impact
      const initialCost = await core.calculateOpenCost(
        marketId,
        100300, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100400, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        CHUNK_BOUNDARY_QUANTITY
      );
      expect(cost2).to.be.gt(initialCost);
    });

    it("Should handle first trade scenario (sumBefore == 0)", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: ethers.parseEther("0.1"),
      });

      // This is the first trade, so sumBefore should be handled correctly
      const cost = await core.calculateOpenCost(
        marketId,
        100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100200, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        ethers.parseUnits("0.01", 6)
      );

      expect(cost).to.be.gt(0);

      const tradeParams = {
        marketId,
        lowerTick: 100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        upperTick: 100200, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should handle edge case where sumAfter equals sumBefore", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: ethers.parseEther("0.1"),
      });

      // This is a theoretical edge case - in practice, any non-zero quantity should change the sum
      // But we test with the smallest possible quantity to approach this edge case
      const minimalQuantity = 1n; // 1 wei in USDC terms

      const cost = await core.calculateOpenCost(
        marketId,
        100500, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100510, // ÏµúÏÜå ÌóàÏö© Î≤îÏúÑ
        minimalQuantity
      );

      // Cost might be 0 for extremely small quantities due to precision limits
      // This is acceptable behavior
      expect(cost).to.be.gte(0);
    });
  });

  describe("Security Tests", function () {
    it("Should prevent zero-cost position attacks with round-up", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, paymentToken, mockPosition } = contracts;

      // Create market with very high alpha to make costs extremely small
      const highAlpha = ethers.parseEther("1000"); // Very high liquidity parameter
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: highAlpha,
      });

      // Try to open position with extremely small quantity
      const tinyQuantity = 1; // 1 micro USDC worth
      const maxCost = 1000; // Allow up to 1000 micro USDC

      const tradeParams = {
        marketId,
        lowerTick: 100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        upperTick: 100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        quantity: tinyQuantity,
        maxCost,
      };

      // Calculate expected cost
      const calculatedCost = await core.calculateOpenCost(
        marketId,
        100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        tinyQuantity
      );

      // Cost should be at least 1 micro USDC due to round-up
      expect(calculatedCost).to.be.at.least(1);

      // Should be able to open position with minimum cost
      await core
        .connect(alice)
        .openPosition(
          tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity,
          tradeParams.maxCost
        );

      // Verify position was created
      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = positions[0];
      const position = await mockPosition.getPosition(positionId);
      expect(position.quantity).to.equal(tinyQuantity);
    });

    it("Should prevent repeated tiny trades from accumulating free positions", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, paymentToken } = contracts;

      // Create market with very high alpha
      const highAlpha = ethers.parseEther("1000");
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: highAlpha,
      });

      const initialBalance = await paymentToken.balanceOf(alice.address);
      let totalCostPaid = 0n;

      // Try to make 10 tiny trades
      for (let i = 0; i < 10; i++) {
        const tinyQuantity = 1; // 1 micro USDC worth
        const maxCost = 10; // Allow up to 10 micro USDC

        const tradeParams = {
          marketId,
          lowerTick: 100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          upperTick: 100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          quantity: tinyQuantity,
          maxCost,
        };

        const costBefore = await core.calculateOpenCost(
          marketId,
          100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          tinyQuantity
        );

        await core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          );
        totalCostPaid += BigInt(costBefore);
      }

      // Verify that some cost was actually paid
      const finalBalance = await paymentToken.balanceOf(alice.address);
      const actualCostPaid = initialBalance - finalBalance;

      expect(actualCostPaid).to.be.at.least(10); // At least 10 micro USDC paid
      expect(actualCostPaid).to.equal(totalCostPaid);
    });

    it("Should prevent gas DoS attacks with excessive chunk splitting", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, paymentToken } = contracts;

      // Create market with very small alpha to maximize chunk count
      const smallAlpha = ethers.parseEther("0.001"); // Very small liquidity parameter
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: smallAlpha,
      });

      // Calculate quantity that would require > 1000 chunks (new limit)
      // maxSafeQuantityPerChunk = alpha * 0.13 = 0.001 * 0.13 = 0.00013 ETH
      // To exceed 1000 chunks: quantity > 1000 * 0.00013 = 0.13 ETH
      const excessiveQuantity = ethers.parseUnits("0.15", 6); // 0.15 USDC

      const tradeParams = {
        marketId,
        lowerTick: 100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        upperTick: 100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        quantity: excessiveQuantity,
        maxCost: ethers.parseUnits("1000000", 6), // Very high max cost
      };

      // Should revert due to excessive chunk count
      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "MathMulOverflow");
    });

    it("Should handle maximum allowed chunks successfully", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, paymentToken } = contracts;

      // Create market with small alpha
      const smallAlpha = ethers.parseEther("0.001");
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: smallAlpha,
      });

      // Calculate quantity that requires exactly 50 chunks (well under limit)
      // maxSafeQuantityPerChunk = alpha * 0.13 = 0.001 * 0.13 = 0.00013 ETH
      // For 50 chunks: quantity = 50 * 0.00013 = 0.0065 ETH
      const moderateQuantity = ethers.parseUnits("0.007", 6); // 0.007 USDC

      const tradeParams = {
        marketId,
        lowerTick: 100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        upperTick: 100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        quantity: moderateQuantity,
        maxCost: ethers.parseUnits("1000000", 6),
      };

      // Should succeed with moderate chunk count
      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });
  });
});

```


## test/integration/core/boundaries/ticks.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import { COMPONENT_TAG } from "../../../helpers/tags";
import { createActiveMarketFixture } from "../../../helpers/fixtures/core";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

describeMaybe(`${COMPONENT_TAG} CLMSRMarketCore - Price Range Trading`, function () {
  const MIN_TICK = 100000;
  const MAX_TICK = 100990;
  const TICK_SPACING = 10;

  describe("Price Range Validation", function () {
    it("Should reject single tick trades (lowerTick == upperTick)", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            100500,
            100500,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.be.revertedWithCustomError(core, "InvalidTickRange");
    });

    it("Should reject single tick trades at market boundaries", async function () {
      const { core, alice, bob, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            MIN_TICK,
            MIN_TICK,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.be.revertedWithCustomError(core, "InvalidTickRange");

      await expect(
        core
          .connect(bob)
          .openPosition(
            marketId,
            MAX_TICK,
            MAX_TICK,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.be.revertedWithCustomError(core, "InvalidTickRange");
    });

    it("Should allow minimum-width range trades at boundaries", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      const tx = await core
        .connect(alice)
        .openPosition(
          marketId,
          MIN_TICK,
          MIN_TICK + TICK_SPACING,
          ethers.parseUnits("0.01", 6),
          ethers.parseUnits("1000", 6)
        );

      await expect(tx)
        .to.emit(core, "PositionOpened")
        .withArgs(
          anyValue,
          alice.address,
          marketId,
          MIN_TICK,
          MIN_TICK + TICK_SPACING,
          ethers.parseUnits("0.01", 6),
          anyValue
        );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            MAX_TICK - TICK_SPACING,
            MAX_TICK,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.not.be.reverted;
    });
  });

  describe("Tick Range Boundaries", function () {
    it("Should handle trades starting at first tick", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            MIN_TICK,
            MIN_TICK + 3 * TICK_SPACING,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.not.be.reverted;
    });

    it("Should handle trades ending at last tick", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            MAX_TICK - 3 * TICK_SPACING,
            MAX_TICK,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.not.be.reverted;
    });

    it("Should handle maximum tick range", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            MIN_TICK,
            MAX_TICK,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.not.be.reverted;
    });

    it("Should revert when tick exceeds market bounds", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            MIN_TICK,
            MAX_TICK + TICK_SPACING,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.be.revertedWithCustomError(core, "InvalidTick");
    });
  });

  describe("Edge Cases for Tick Handling", function () {
    it("Should handle boundary tick positions with minimal range", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            MIN_TICK,
            MIN_TICK + TICK_SPACING,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.not.be.reverted;

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            MAX_TICK - TICK_SPACING,
            MAX_TICK,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.not.be.reverted;
    });

    it("Should handle large tick range operations efficiently", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      const tx = await core
        .connect(alice)
        .openPosition(
          marketId,
          MIN_TICK,
          MAX_TICK,
          ethers.parseUnits("0.05", 6),
          ethers.parseUnits("1000", 6)
        );
      const receipt = await tx.wait();

      expect(receipt!.gasUsed).to.be.lt(500000n);
    });

    it("Should handle overlapping tick ranges", async function () {
      const { core, alice, bob, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await core
        .connect(alice)
        .openPosition(
          marketId,
          100400,
          100600,
          ethers.parseUnits("0.05", 6),
          ethers.parseUnits("1000", 6)
        );

      await core
        .connect(bob)
        .openPosition(
          marketId,
          100500,
          100700,
          ethers.parseUnits("0.05", 6),
          ethers.parseUnits("1000", 6)
        );

      expect(true).to.be.true;
    });

    it("Should validate tick order (lowerTick <= upperTick)", async function () {
      const { core, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            100550,
            100450,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.be.revertedWithCustomError(core, "InvalidTickRange");
    });
  });
});

```


## test/integration/core/boundaries/time.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  setupCustomMarket,
  createMarketWithConfig,
  setMarketActivation,
  toSettlementValue,
} from "../../../helpers/fixtures/core";
import { COMPONENT_TAG } from "../../../helpers/tags";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

async function setNextBlockTimestampSafe(targetTimestamp: number) {
  const latest = await time.latest();
  const safeTarget = Math.max(targetTimestamp, latest + 1);
  await time.setNextBlockTimestamp(safeTarget);
}

async function createTimedMarket(
  contracts: Awaited<ReturnType<typeof coreFixture>>,
  options: {
    minTick?: number;
    maxTick?: number;
    tickSpacing?: number;
    startTime?: number;
    endTime?: number;
    settlementTime?: number;
    startOffset?: number;
    duration?: number;
    settlementOffset?: number;
    liquidity?: bigint;
  } = {}
) {
  const {
    minTick = 100000,
    maxTick = 100990,
    tickSpacing = 10,
    startOffset = 100,
    duration = 86400,
    settlementOffset = 3600,
    liquidity = ethers.parseEther("0.1"),
  } = options;

  const currentTime = Number(await time.latest());
  const startTime = options.startTime ?? currentTime + startOffset;
  const endTime = options.endTime ?? startTime + duration;
  const settlementTime = options.settlementTime ?? endTime + settlementOffset;

  const marketId = await createMarketWithConfig(contracts.core, contracts.keeper, {
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    liquidityParameter: liquidity,
    settlementTime,
  });

  await setMarketActivation(contracts.core, contracts.keeper, marketId, true);

  return { marketId, startTime, endTime, settlementTime };
}

describeMaybe(`${COMPONENT_TAG} CLMSRMarketCore - Time Boundaries`, function () {
  describe("Trade Timing Validation", function () {
    it("Should handle trade at exact market start time", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId } = await setupCustomMarket(contracts, {
        marketId: 1,
        alpha: ethers.parseEther("0.1"),
      });

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should handle trade 1 second before market end", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, endTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
        liquidity: ethers.parseEther("0.1"),
      });

      // Move to 1 second before end
      await setNextBlockTimestampSafe(endTime - 1);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should deactivate market when trading after end time", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, endTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
        liquidity: ethers.parseEther("0.1"),
      });

      // Move past end time
      await setNextBlockTimestampSafe(endTime + 1);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "MarketExpired");
    });

    it("Should prevent trading before market start", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const futureStart = Number(await time.latest()) + 3600; // 1 hour from now
      const futureEnd = futureStart + 86400; // 1 day duration

      const { marketId } = await createTimedMarket(contracts, {
        startTime: futureStart,
        endTime: futureEnd,
        liquidity: ethers.parseEther("0.1"),
      });

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "MarketNotStarted");
    });
  });

  describe("Block Timestamp Edge Cases", function () {
    it("Should handle block timestamp jumps correctly", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, endTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
        liquidity: ethers.parseEther("0.1"),
      });

      // Jump to near end time
      await setNextBlockTimestampSafe(endTime - 10);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;

      // Jump past end time
      await setNextBlockTimestampSafe(endTime + 1);

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "MarketExpired");
    });

    it("Should handle extreme timestamp values", async function () {
      const contracts = await loadFixture(coreFixture);

      // Test with very large timestamp values
      const farFuture = 2_147_483_647; // Max 32-bit timestamp
      const farFutureEnd = farFuture + 86_400;

      await expect(
        createTimedMarket(contracts, {
          startTime: farFuture,
          endTime: farFutureEnd,
          settlementTime: farFutureEnd + 3600,
          liquidity: ethers.parseEther("0.1"),
        })
      ).to.be.fulfilled;
    });
  });

  describe("Market Expiry Operations", function () {
    it("Should handle market expiry edge cases during operations", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, startTime, endTime } = await createTimedMarket(
        contracts,
        {
          startOffset: 100,
          duration: 86400,
          liquidity: ethers.parseEther("0.1"),
        }
      );

      await setNextBlockTimestampSafe(startTime + 1);

      // Open position before expiry
      const openParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.05", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await core
        .connect(alice)
        .openPosition(
          openParams.marketId,
          openParams.lowerTick,
          openParams.upperTick,
          openParams.quantity,
          openParams.maxCost
        );
      const positionId = 1n;

      // Move to exactly 1 second after expiry
      await setNextBlockTimestampSafe(endTime + 1);

      // All operations should fail after expiry
      await expect(
        core
          .connect(alice)
          .increasePosition(
            positionId,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.be.revertedWithCustomError(core, "MarketExpired");

      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, ethers.parseUnits("0.01", 6), 0)
      ).to.be.revertedWithCustomError(core, "MarketExpired");

      await expect(
        core.connect(alice).closePosition(positionId, 0)
      ).to.be.revertedWithCustomError(core, "MarketExpired");
    });

    it("Should allow settlement after expiry", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const { marketId, settlementTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
      });

      // Fast forward past settlement time
      await time.increaseTo(settlementTime + 1);

      // Settlement should still work after expiry
      const settlementTick = 100450;
      await expect(
        core
          .connect(keeper)
          .settleMarket(marketId, toSettlementValue(settlementTick))
      ).to.not.be.reverted;
    });
  });

  describe("Extended Time Boundaries", function () {
    it("Should handle trade at exact market start time", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, startTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
      });

      // Move to exact start time
      await setNextBlockTimestampSafe(startTime);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should handle trade 1 second before market end", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, endTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
      });

      // Move to 1 second before end
      await setNextBlockTimestampSafe(endTime - 1);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;
    });

    it("Should deactivate market when trading after end time", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, endTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
      });

      // Move past end time
      await setNextBlockTimestampSafe(endTime + 1);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "MarketExpired");
    });

    it("Should prevent trading before market start", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const futureStart = Number(await time.latest()) + 3600; // 1 hour from now

      const { marketId } = await createTimedMarket(contracts, {
        startTime: futureStart,
        endTime: futureStart + 86400,
      });

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "MarketNotStarted");
    });

    it("Should handle block timestamp jumps correctly", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, endTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
      });

      // Jump to near end time
      await setNextBlockTimestampSafe(endTime - 10);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.01", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.not.be.reverted;

      // Jump past end time
      await setNextBlockTimestampSafe(endTime + 1);

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "MarketExpired");
    });

    it("Should handle extreme timestamp values", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      // Test with very large timestamp values
      const farFuture = 2147483647; // Max 32-bit timestamp
      const farFutureEnd = farFuture + 86400;

      await expect(
        core.connect(keeper).createMarket(
          5,
          100000, // minTick
          100990, // maxTick
          10, // tickSpacing
          farFuture,
          farFutureEnd,
          ethers.parseEther("0.1")
        )
      ).to.not.be.reverted;
    });

    it("Should handle market expiry edge cases during operations", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, alice } = contracts;

      const { marketId, startTime, endTime } = await createTimedMarket(
        contracts,
        {
          startOffset: 100,
          duration: 86400,
          liquidity: ethers.parseEther("0.1"),
        }
      );

      await setNextBlockTimestampSafe(startTime + 1);

      // Open position before expiry
      const openParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.05", 6),
        maxCost: ethers.parseUnits("1000", 6),
      };

      await core
        .connect(alice)
        .openPosition(
          openParams.marketId,
          openParams.lowerTick,
          openParams.upperTick,
          openParams.quantity,
          openParams.maxCost
        );
      const positionId = 1n;

      // Move to exactly 1 second after expiry
      await setNextBlockTimestampSafe(endTime + 1);

      // All operations should fail after expiry
      await expect(
        core
          .connect(alice)
          .increasePosition(
            positionId,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1000", 6)
          )
      ).to.be.revertedWithCustomError(core, "MarketExpired");

      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, ethers.parseUnits("0.01", 6), 0)
      ).to.be.revertedWithCustomError(core, "MarketExpired");

      await expect(
        core.connect(alice).closePosition(positionId, 0)
      ).to.be.revertedWithCustomError(core, "MarketExpired");
    });
  });

  describe("Settlement Timestamp Features", function () {
    it("Should create market with settlement timestamp using createMarket", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core } = contracts;

      const { marketId, startTime, endTime, settlementTime } =
        await createTimedMarket(contracts, {
          startOffset: 100,
          duration: 86400,
          settlementOffset: 3600,
        });

      const market = await core.getMarket(marketId);
      expect(market.startTimestamp).to.equal(startTime);
      expect(market.endTimestamp).to.equal(endTime);
      expect(market.settlementTimestamp).to.equal(settlementTime);
    });

    it("Should reject createMarket with invalid time order", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const currentTime = Number(await time.latest());
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;
      const invalidSettlementTime = endTime - 100;

      await expect(
        core
          .connect(keeper)
          .createMarket(
            100000,
            100990,
            10,
            startTime,
            endTime,
            invalidSettlementTime,
            ethers.parseEther("0.1")
          )
      ).to.be.revertedWithCustomError(core, "InvalidTimeRange");
    });

    it("Should enforce settlement time gate in settleMarket", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const { marketId, settlementTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
        settlementOffset: 3600,
      });

      await expect(
        core
          .connect(keeper)
          .settleMarket(marketId, toSettlementValue(100450))
      ).to.be.revertedWithCustomError(core, "SettlementTooEarly");

      await setNextBlockTimestampSafe(settlementTime);
      await expect(
        core
          .connect(keeper)
          .settleMarket(marketId, toSettlementValue(100450))
      ).to.not.be.reverted;
    });

    it("Should allow settlement after endTime when settlement equals end", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const { marketId, endTime, settlementTime } = await createTimedMarket(
        contracts,
        {
          startOffset: 100,
          duration: 86400,
          settlementOffset: 1,
        }
      );

      await setNextBlockTimestampSafe(settlementTime);
      await expect(
        core
          .connect(keeper)
          .settleMarket(marketId, toSettlementValue(100500))
      ).to.not.be.reverted;
    });

    it("Should enforce cross-constraint in updateMarketTiming", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const { marketId, startTime, endTime, settlementTime } =
        await createTimedMarket(contracts, {
          startOffset: 100,
          duration: 86400,
          settlementOffset: 3600,
        });

      const invalidEnd = endTime + 3600;
      const invalidSettlement = settlementTime - 100;

      await expect(
        core
          .connect(keeper)
          .updateMarketTiming(
            marketId,
            startTime,
            invalidEnd,
            invalidSettlement
          )
      ).to.be.revertedWithCustomError(core, "InvalidTimeRange");
    });

    it("Should allow updateMarketTiming with valid inputs", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const { marketId, startTime, endTime, settlementTime } =
        await createTimedMarket(contracts, {
          startOffset: 100,
          duration: 86400,
          settlementOffset: 3600,
        });

      const newStart = startTime + 60;
      const newEnd = endTime + 120;
      const newSettlement = settlementTime + 300;

      await expect(
        core
          .connect(keeper)
          .updateMarketTiming(marketId, newStart, newEnd, newSettlement)
      ).to.not.be.reverted;

      const market = await core.getMarket(marketId);
      expect(market.startTimestamp).to.equal(newStart);
      expect(market.endTimestamp).to.equal(newEnd);
      expect(market.settlementTimestamp).to.equal(newSettlement);
    });

    it("Should prevent updateMarketTiming on settled market", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const { marketId, settlementTime } = await createTimedMarket(contracts, {
        startOffset: 100,
        duration: 86400,
        settlementOffset: 3600,
      });

      await setNextBlockTimestampSafe(settlementTime + 1);
      await core
        .connect(keeper)
        .settleMarket(marketId, toSettlementValue(100400));

      await expect(
        core
          .connect(keeper)
          .updateMarketTiming(
            marketId,
            settlementTime,
            settlementTime + 3600,
            settlementTime + 7200
          )
      ).to.be.revertedWithCustomError(core, "MarketAlreadySettled");
    });
  });
});

```


## test/integration/core/deployment.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { COMPONENT_TAG } from "../../helpers/tags";
import {
  createActiveMarketFixture,
  unitFixture,
  TICK_COUNT,
} from "../../helpers/fixtures/core";

describe(`${COMPONENT_TAG} CLMSRMarketCore - Deployment & Configuration`, function () {
  const WAD = ethers.parseEther("1");

  describe("Contract Deployment", function () {
    it("Should deploy all contracts successfully with linked libraries", async function () {
      const {
        core,
        paymentToken,
        mockPosition,
        fixedPointMathU,
        lazyMulSegmentTree,
      } = await loadFixture(createActiveMarketFixture);

      expect(await core.getAddress()).to.not.equal(ethers.ZeroAddress);
      expect(await paymentToken.getAddress()).to.not.equal(ethers.ZeroAddress);
      expect(await mockPosition.getAddress()).to.not.equal(ethers.ZeroAddress);
      expect(await fixedPointMathU.getAddress()).to.not.equal(
        ethers.ZeroAddress
      );
      expect(await lazyMulSegmentTree.getAddress()).to.not.equal(
        ethers.ZeroAddress
      );
    });

    it("Should initialize core contract with correct parameters", async function () {
      const { core, paymentToken, mockPosition, keeper } = await loadFixture(
        createActiveMarketFixture
      );

      expect(await core.getPaymentToken()).to.equal(
        await paymentToken.getAddress()
      );
      expect(await core.getPositionContract()).to.equal(
        await mockPosition.getAddress()
      );
      expect(await core.owner()).to.equal(keeper.address);
      expect(await core.isPaused()).to.be.false;
    });

    it("Should revert initialization with zero addresses", async function () {
      const { fixedPointMathU, lazyMulSegmentTree } = await loadFixture(
        unitFixture
      );

      const CLMSRMarketCoreFactory = await ethers.getContractFactory(
        "CLMSRMarketCore",
        {
          libraries: {
            FixedPointMathU: await fixedPointMathU.getAddress(),
            LazyMulSegmentTree: await lazyMulSegmentTree.getAddress(),
          },
        }
      );

      const core = await CLMSRMarketCoreFactory.deploy();

      await expect(
        core.initialize(ethers.ZeroAddress, ethers.ZeroAddress)
      ).to.be.revertedWithCustomError(core, "ZeroAddress");
    });

    it("Should reject payment tokens with non-6 decimals", async function () {
      const { fixedPointMathU, lazyMulSegmentTree } = await loadFixture(
        unitFixture
      );

      const CLMSRMarketCoreFactory = await ethers.getContractFactory(
        "CLMSRMarketCore",
        {
          libraries: {
            FixedPointMathU: await fixedPointMathU.getAddress(),
            LazyMulSegmentTree: await lazyMulSegmentTree.getAddress(),
          },
        }
      );
      const MockERC20Factory = await ethers.getContractFactory("MockERC20");
      const MockPositionFactory = await ethers.getContractFactory("MockPosition");

      const weirdToken = await MockERC20Factory.deploy("Weird USD", "WUSD", 18);
      await weirdToken.waitForDeployment();
      const mockPosition = await MockPositionFactory.deploy();
      await mockPosition.waitForDeployment();

      const core = await CLMSRMarketCoreFactory.deploy();
      await core.waitForDeployment();

      await expect(
        core.initialize(await weirdToken.getAddress(), await mockPosition.getAddress())
      )
        .to.be.revertedWithCustomError(core, "InvalidTokenDecimals")
        .withArgs(18, 6);
    });

    it("Should verify contract state after deployment", async function () {
      const { core, paymentToken, marketId, startTime, endTime } =
        await loadFixture(createActiveMarketFixture);

      // Check basic state
      expect(await core.getPaymentToken()).to.equal(
        await paymentToken.getAddress()
      );
      expect(await core.isPaused()).to.be.false;

      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;
      expect(market.startTimestamp).to.equal(BigInt(startTime));
      expect(market.endTimestamp).to.equal(BigInt(endTime));
      expect(market.minTick).to.equal(BigInt(100000));
      expect(market.maxTick).to.equal(
        BigInt(100000 + (TICK_COUNT - 1) * 10)
      );

      // Next market should not exist yet
      await expect(core.getMarket(marketId + 1)).to.be.revertedWithCustomError(
        core,
        "MarketNotFound"
      );
    });

    it("Should handle proper library linking verification", async function () {
      const { core, marketId } = await loadFixture(createActiveMarketFixture);

      const cost = await core.calculateOpenCost(
        marketId,
        100000,
        100010,
        ethers.parseUnits("0.01", 6)
      );
      expect(cost).to.be.greaterThan(0n);

      // This would fail if libraries aren't properly linked
      const code = await ethers.provider.getCode(await core.getAddress());
      expect(code).to.not.include("__$"); // No unlinked library placeholders
    });
  });

  describe("Initial Configuration", function () {
    it("Should have tokens approved for users", async function () {
      const { core, paymentToken, alice, bob } = await loadFixture(
        createActiveMarketFixture
      );

      const coreAddress = await core.getAddress();
      expect(await paymentToken.allowance(alice.address, coreAddress)).to.equal(
        ethers.MaxUint256
      );
      expect(await paymentToken.allowance(bob.address, coreAddress)).to.equal(
        ethers.MaxUint256
      );
    });

    it("Should have correct token balances", async function () {
      const { paymentToken, alice, bob, charlie } = await loadFixture(
        createActiveMarketFixture
      );

      const expectedBalance = ethers.parseUnits("1000000000000", 6); // 1T USDC (INITIAL_SUPPLY)
      expect(await paymentToken.balanceOf(alice.address)).to.equal(
        expectedBalance
      );
      expect(await paymentToken.balanceOf(bob.address)).to.equal(
        expectedBalance
      );
      expect(await paymentToken.balanceOf(charlie.address)).to.equal(
        expectedBalance
      );
    });

    it("Should verify payment token properties", async function () {
      const { paymentToken } = await loadFixture(createActiveMarketFixture);

      expect(await paymentToken.name()).to.equal("USD Coin");
      expect(await paymentToken.symbol()).to.equal("USDC");
      expect(await paymentToken.decimals()).to.equal(6);
    });

    it("Should link position contract correctly", async function () {
      const { core, mockPosition } = await loadFixture(
        createActiveMarketFixture
      );

      expect(await mockPosition.coreContract()).to.equal(
        await core.getAddress()
      );
    });
  });

  describe("Access Control Setup", function () {
    it("Should set keeper as manager", async function () {
      const { core, keeper } = await loadFixture(createActiveMarketFixture);

      expect(await core.owner()).to.equal(keeper.address);
    });

    it("Should verify initial paused state", async function () {
      const { core } = await loadFixture(createActiveMarketFixture);

      expect(await core.isPaused()).to.be.false;
    });

    it("Should allow keeper to pause/unpause", async function () {
      const { core, keeper } = await loadFixture(createActiveMarketFixture);

      await core.connect(keeper).pause("Test pause");
      expect(await core.isPaused()).to.be.true;

      await core.connect(keeper).unpause();
      expect(await core.isPaused()).to.be.false;
    });

    it("Should prevent non-keeper from pause operations", async function () {
      const { core, alice } = await loadFixture(createActiveMarketFixture);

      await expect(
        core.connect(alice).pause("Unauthorized")
      )
        .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
        .withArgs(alice.address);

      await expect(core.connect(alice).unpause())
        .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
        .withArgs(alice.address);
    });
  });

  describe("Contract Interaction Setup", function () {
    it("Should properly link position contract", async function () {
      const { core, mockPosition } = await loadFixture(
        createActiveMarketFixture
      );

      const linkedPosition = await core.getPositionContract();
      expect(linkedPosition).to.equal(await mockPosition.getAddress());

      // Verify bidirectional link
      expect(await mockPosition.coreContract()).to.equal(
        await core.getAddress()
      );
    });

    it("Should handle library function calls correctly", async function () {
      const { core } = await loadFixture(createActiveMarketFixture);

      // These calls should work if libraries are properly linked
      // (will revert for business logic reasons, not linking issues)
      await expect(core.getMarket(999)).to.be.revertedWithCustomError(
        core,
        "MarketNotFound"
      );
    });

    it("Should verify payment token integration", async function () {
      const { core, paymentToken } = await loadFixture(
        createActiveMarketFixture
      );

      expect(await core.getPaymentToken()).to.equal(
        await paymentToken.getAddress()
      );

      // Core should have tokens from setup
      const coreBalance = await paymentToken.balanceOf(await core.getAddress());
      expect(coreBalance).to.be.gt(0);
    });
  });

  describe("Error Handling", function () {
    it("Should handle basic error scenarios", async function () {
      const { core } = await loadFixture(createActiveMarketFixture);

      // Market not found
      await expect(core.getMarket(999)).to.be.revertedWithCustomError(
        core,
        "MarketNotFound"
      );

      // Invalid tick value on existing market
      await expect(core.getRangeSum(1, 0, 10)).to.be.revertedWithCustomError(
        core,
        "InvalidTick"
      );
    });
  });

  describe("Gas and Performance", function () {
    it("Should deploy within gas limits", async function () {
      if (process.env.COVERAGE) {
        this.skip();
      }

      const { core } = await loadFixture(createActiveMarketFixture);

      const deploymentTx = core.deploymentTransaction();
      expect(deploymentTx).to.not.be.null;

      if (deploymentTx) {
        const receipt = await deploymentTx.wait();
        expect(receipt?.gasUsed).to.be.lt(15_000_000); // Reasonable deployment limit
      }
    });

    it("Should handle multiple deployment scenarios", async function () {
      // loadFixture caches deployments in the same test run
      // This is expected behavior - different tests get fresh deployments
      // but multiple loadFixtures in the same test return cached instances
      const contracts1 = await loadFixture(createActiveMarketFixture);
      const contracts2 = await loadFixture(createActiveMarketFixture);

      // They should be the same due to fixture caching
      expect(await contracts1.core.getAddress()).to.equal(
        await contracts2.core.getAddress()
      );

      // Verify both work correctly
      expect(await contracts1.core.isPaused()).to.be.false;
      expect(await contracts2.core.isPaused()).to.be.false;
    });

    it("Should verify all required contracts are functional", async function () {
      const { core, paymentToken, mockPosition, keeper } = await loadFixture(
        createActiveMarketFixture
      );

      // Test core functionality
      expect(await core.isPaused()).to.be.false;

      // Test token functionality
      expect(await paymentToken.totalSupply()).to.be.gt(0);

      // Test position functionality
      expect(await mockPosition.coreContract()).to.equal(
        await core.getAddress()
      );

      // Test manager functionality
      await core.connect(keeper).pause("Test pause");
      expect(await core.isPaused()).to.be.true;
      await core.connect(keeper).unpause();
    });
  });

  describe("Contract Deployment from Original", function () {
    it("Should deploy all contracts successfully with linked libraries", async function () {
      const { core, paymentToken, mockPosition } = await loadFixture(
        createActiveMarketFixture
      );

      expect(await core.getAddress()).to.not.equal(ethers.ZeroAddress);
      expect(await paymentToken.getAddress()).to.not.equal(ethers.ZeroAddress);
      expect(await mockPosition.getAddress()).to.not.equal(ethers.ZeroAddress);
    });

    it("Should initialize core contract with correct parameters", async function () {
      const { core, paymentToken, mockPosition, keeper } = await loadFixture(
        createActiveMarketFixture
      );

      expect(await core.getPaymentToken()).to.equal(
        await paymentToken.getAddress()
      );
      expect(await core.getPositionContract()).to.equal(
        await mockPosition.getAddress()
      );
      expect(await core.owner()).to.equal(keeper.address);
      expect(await core.isPaused()).to.be.false;
    });

  });
});

```


## test/integration/core/events.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  createActiveMarketFixture,
  settleMarketAtTick,
  increaseToSafe,
  advanceToClaimOpen,
} from "../../helpers/fixtures/core";
import { COMPONENT_TAG } from "../../helpers/tags";

describe(`${COMPONENT_TAG} CLMSRMarketCore - Events`, function () {
  const ALPHA = ethers.parseEther("1");
  const MIN_TICK = 100000;
  const MAX_TICK = 100990;
  const TICK_SPACING = 10;
  const MARKET_DURATION = 7 * 24 * 60 * 60; // 7 days
  const USDC_DECIMALS = 6;
  const SMALL_QUANTITY = ethers.parseUnits("0.01", USDC_DECIMALS);
  const INCREASE_QUANTITY = ethers.parseUnits("0.005", USDC_DECIMALS);
  const BPS_DENOMINATOR = 10_000n;
  const DEFAULT_BUFFER_BPS = 500n;

  const applyBuffer = (amount: bigint, buffer: bigint = DEFAULT_BUFFER_BPS) =>
    ((amount * (BPS_DENOMINATOR + buffer)) / BPS_DENOMINATOR) + 1n;

  async function setupSettledBatchFixture() {
    const contracts = await loadFixture(createActiveMarketFixture);
    const { core, keeper, alice, bob, charlie, marketId, mockPosition } =
      contracts;

    const ranges = [
      { signer: alice, lower: 100100, upper: 100200 },
      { signer: bob, lower: 100110, upper: 100210 },
      { signer: charlie, lower: 100120, upper: 100220 },
    ];

    const minted: bigint[] = [];
    for (const { signer, lower, upper } of ranges) {
      const quotedCost = await core.calculateOpenCost(
        marketId,
        lower,
        upper,
        SMALL_QUANTITY
      );
      const maxCost = applyBuffer(quotedCost);
      await core
        .connect(signer)
        .openPosition(
          marketId,
          lower,
          upper,
          SMALL_QUANTITY,
          maxCost
        );
      const owned = await mockPosition.getPositionsByOwner(signer.address);
      minted.push(owned[owned.length - 1]);
    }

    // Create a burned hole in market token list
    const bobId = minted[1];
    await core.connect(bob).closePosition(bobId, 0);

    await time.increase(MARKET_DURATION + 3600);
    await settleMarketAtTick(core, keeper, marketId, 100150);

    const listLength = await mockPosition.getMarketTokenLength(marketId);

    return {
      ...contracts,
      aliceId: minted[0],
      charlieId: minted[2],
      listLength,
    };
  }

  describe("Market Events", function () {
    it("Should emit MarketCreated event with correct parameters", async function () {
      const { core, keeper } = await loadFixture(createActiveMarketFixture);
      const currentTime = await time.latest();
      const startTime = currentTime + 60;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      const expectedId = await core.connect(keeper).createMarket.staticCall(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );

      const numBins = BigInt((MAX_TICK - MIN_TICK) / TICK_SPACING);

      const tx = core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA,
          ethers.ZeroAddress
        );

      await expect(tx)
        .to.emit(core, "MarketCreated")
        .withArgs(
          expectedId,
          BigInt(startTime),
          BigInt(endTime),
          BigInt(MIN_TICK),
          BigInt(MAX_TICK),
          BigInt(TICK_SPACING),
          numBins,
          ALPHA
        );

      await expect(tx)
        .to.emit(core, "MarketActivationUpdated")
        .withArgs(expectedId, false);
    });

    it("Should emit MarketSettled event with correct parameters", async function () {
      const { core, keeper } = await loadFixture(createActiveMarketFixture);
      const currentTime = await time.latest();
      const startTime = currentTime + 60;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      const expectedId = await core.connect(keeper).createMarket.staticCall(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );

      await core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA,
          ethers.ZeroAddress
        );

      await increaseToSafe(startTime + 1);

      const settlementTick = 100490;

      await expect(
        settleMarketAtTick(core, keeper, Number(expectedId), settlementTick)
      )
        .to.emit(core, "MarketSettled")
        .withArgs(expectedId, BigInt(settlementTick));
    });

    it("Should emit MarketSettled when status transitions to settled", async function () {
      const { core, keeper } = await loadFixture(createActiveMarketFixture);
      const currentTime = await time.latest();
      const startTime = currentTime + 60;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      const expectedId = await core.connect(keeper).createMarket.staticCall(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );

      await core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA,
          ethers.ZeroAddress
        );

      await increaseToSafe(endTime + 1);

      await expect(
        settleMarketAtTick(core, keeper, Number(expectedId), 100450)
      ).to.emit(core, "MarketSettled");
    });
  });

  describe("Position Events", function () {
    async function createActiveMarket() {
      return await loadFixture(createActiveMarketFixture);
    }

    it("Should emit PositionOpened event with correct parameters", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = SMALL_QUANTITY;

      // Pre-calculate expected cost for verification
      const expectedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );

      const maxCost = expectedCost + ethers.parseUnits("0.01", USDC_DECIMALS);

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            lowerTick,
            upperTick,
            quantity,
            maxCost
          )
      )
        .to.emit(core, "PositionOpened")
        .withArgs(
          (positionId: any) => positionId >= 1, // Position ID should be >= 1
          alice.address, // owner
          marketId, // marketId
          lowerTick, // lowerTick
          upperTick, // upperTick
          quantity, // quantity
          (actualCost: any) => actualCost <= maxCost // cost should be <= maxCost
        );
    });

    it("Should emit PositionIncreased event with correct parameters", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const initialQuantity = SMALL_QUANTITY;
      const increaseQuantity = INCREASE_QUANTITY;

      // First, open a position
      const initialCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        initialQuantity
      );
      const initialMaxCost = initialCost + ethers.parseUnits("0.01", USDC_DECIMALS);
      await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          initialQuantity,
          initialMaxCost
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      const increaseCost = await core.calculateIncreaseCost(
        positionId,
        increaseQuantity
      );
      const increaseMaxCost = increaseCost + ethers.parseUnits("0.01", USDC_DECIMALS);

      // Then increase it
      await expect(
        core
          .connect(alice)
          .increasePosition(positionId, increaseQuantity, increaseMaxCost)
      )
        .to.emit(core, "PositionIncreased")
        .withArgs(
          positionId, // positionId
          alice.address, // user
          increaseQuantity, // quantityAdded
          (newTotalQuantity: any) => newTotalQuantity > increaseQuantity, // newTotalQuantity
          (cost: any) => cost > 0 // cost should be positive
        );
    });

    it("Should emit PositionDecreased event with correct parameters", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const initialQuantity = SMALL_QUANTITY * 2n;
      const decreaseQuantity = INCREASE_QUANTITY;

      // First, open a position
      const initialCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        initialQuantity
      );
      const initialMaxCost = initialCost + ethers.parseUnits("0.01", USDC_DECIMALS);
      await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          initialQuantity,
          initialMaxCost
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      const expectedProceeds = await core.calculateDecreaseProceeds(
        positionId,
        decreaseQuantity
      );
      const minProceeds = expectedProceeds > 0n ? expectedProceeds - 1n : 0n;

      // Then decrease it
      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, decreaseQuantity, minProceeds)
      )
        .to.emit(core, "PositionDecreased")
        .withArgs(
          positionId, // positionId
          alice.address, // user
          decreaseQuantity, // quantityRemoved
          (newTotalQuantity: any) => newTotalQuantity >= 0, // newTotalQuantity
          (proceeds: any) => proceeds >= 0 // proceeds should be non-negative
        );
    });

    it("Should emit PositionClosed event with correct parameters", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = SMALL_QUANTITY;

      // First, open a position
      const initialCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );
      const maxCost = initialCost + ethers.parseUnits("0.01", USDC_DECIMALS);
      await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);
      const closeProceeds = await core.calculateCloseProceeds(positionId);
      const minProceeds = closeProceeds > 0n ? closeProceeds - 1n : 0n;

      // Then close it
      await expect(core.connect(alice).closePosition(positionId, minProceeds))
        .to.emit(core, "PositionClosed")
        .withArgs(
          positionId, // positionId
          alice.address, // user
          (proceeds: any) => proceeds >= 0 // finalProceeds should be non-negative
        );
    });

    it("Should emit PositionClaimed event with correct parameters", async function () {
      const { core, alice, keeper, marketId, endTime, mockPosition } =
        await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = SMALL_QUANTITY;

      // First, open a position
      const maxCost =
        (await core.calculateOpenCost(marketId, lowerTick, upperTick, quantity)) +
        ethers.parseUnits("0.01", USDC_DECIMALS);
      await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      // Fast forward past market end and settle
      await increaseToSafe(endTime + 1);
      await settleMarketAtTick(core, keeper, marketId, 100150);
      await advanceToClaimOpen(core, marketId);

      // Claim the position
      await expect(core.connect(alice).claimPayout(positionId))
        .to.emit(core, "PositionClaimed")
        .withArgs(
          positionId, // positionId
          alice.address, // user
          (payout: any) => payout >= 0 // payout should be non-negative
        );
    });
  });

  describe("Trading Events with Detailed Parameters", function () {
    async function createActiveMarket() {
      return await loadFixture(createActiveMarketFixture);
    }

    it("Should emit detailed events for complex position operations", async function () {
      const { core, alice, bob, marketId, mockPosition } = await loadFixture(
        createActiveMarket
      );

      const lowerTick = 100100;
      const upperTick = 100300;
      const quantity = ethers.parseUnits("0.01", USDC_DECIMALS);
      const quotedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );
      const maxCost = (quotedCost * 1005n) / 1000n + 1n;

      // Complex sequence: open, increase, decrease, transfer
      const openTx = await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      await expect(openTx).to.emit(core, "PositionOpened");

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      // Increase position
      const increaseCost = await core.calculateIncreaseCost(positionId, quantity);
      const increaseMaxCost = (increaseCost * 1005n) / 1000n + 1n;

      const increaseTx = await core
        .connect(alice)
        .increasePosition(positionId, quantity, increaseMaxCost);

      await expect(increaseTx).to.emit(core, "PositionIncreased");

      // Decrease position
      const decreaseTx = await core
        .connect(alice)
        .decreasePosition(positionId, quantity, 0);

      await expect(decreaseTx).to.emit(core, "PositionDecreased");
    });

    it("Should emit events with proper gas tracking", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = ethers.parseUnits("0.005", USDC_DECIMALS);
      const quotedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );
      const maxCost = (quotedCost * 1005n) / 1000n + 1n;

      // Track gas usage through events
      const tx = await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      const receipt = await tx.wait();
      expect(receipt!.gasUsed).to.be.gt(0);

      // Verify event was emitted with correct gas context
      await expect(tx).to.emit(core, "PositionOpened");
    });
  });

  describe("Error Events", function () {
    async function createActiveMarket() {
      return createActiveMarketFixture();
    }

    it("Should emit error-related events on failed operations", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = ethers.parseUnits("0.01", USDC_DECIMALS);
      const quotedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );
      const tooLowMaxCost = quotedCost - 1n;

      // This should fail with CostExceedsMaximum
      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            lowerTick,
            upperTick,
            quantity,
            tooLowMaxCost
          )
      )
        .to.be.revertedWithCustomError(core, "CostExceedsMaximum")
        .withArgs(quotedCost, tooLowMaxCost);
    });

    it("Should handle event emissions during edge cases", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const smallQuantity = ethers.parseUnits("0.000001", USDC_DECIMALS); // Very small
      const quotedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        smallQuantity
      );
      const maxCost = (quotedCost * 1010n) / 1000n + 1n;

      // This should still work and emit proper events
      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            lowerTick,
            upperTick,
            smallQuantity,
            maxCost
          )
      ).to.emit(core, "PositionOpened");
    });
  });

  describe("Market State Events", function () {
    it("Should emit events during market lifecycle transitions", async function () {
      const { core, keeper } = await loadFixture(createActiveMarketFixture);
      const startTime = (await time.latest()) + 60;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      const marketId = await core.connect(keeper).createMarket.staticCall(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );

      // Market creation
      const createTx = core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA,
          ethers.ZeroAddress
        );

      await expect(createTx)
        .to.emit(core, "MarketCreated")
        .withArgs(
          marketId,
          BigInt(startTime),
          BigInt(endTime),
          BigInt(MIN_TICK),
          BigInt(MAX_TICK),
          BigInt(TICK_SPACING),
          BigInt((MAX_TICK - MIN_TICK) / TICK_SPACING),
          ALPHA
        );

      await expect(createTx)
        .to.emit(core, "MarketActivationUpdated")
        .withArgs(marketId, false);

      // Market activation (start time reached)
      await increaseToSafe(startTime + 1);

      // Market ending (end time reached)
      await increaseToSafe(endTime + 1);

      // Market settlement
      await expect(
        settleMarketAtTick(core, keeper, Number(marketId), 100450)
      ).to.emit(core, "MarketSettled");
    });

    it("Should emit proper timestamp information in events", async function () {
      const { core, keeper } = await loadFixture(createActiveMarketFixture);
      const startTime = (await time.latest()) + 60;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      const currentBlockTime = await time.latest();

      const marketId = await core.connect(keeper).createMarket.staticCall(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        ALPHA
      );

      const createTx = core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA
        );

      await expect(createTx)
        .to.emit(core, "MarketCreated")
        .withArgs(
          marketId,
          BigInt(startTime),
          BigInt(endTime),
          BigInt(MIN_TICK),
          BigInt(MAX_TICK),
          BigInt(TICK_SPACING),
          BigInt((MAX_TICK - MIN_TICK) / TICK_SPACING),
          ALPHA
        );

      await expect(createTx)
        .to.emit(core, "MarketActivationUpdated")
        .withArgs(marketId, false);

      // Verify timestamps are within reasonable bounds
      expect(startTime).to.be.gt(currentBlockTime);
      expect(endTime).to.be.gt(startTime);
    });
  });

  describe("Event Data Integrity", function () {
    async function createActiveMarket() {
      return createActiveMarketFixture();
    }

    it("Should maintain event parameter consistency across operations", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = ethers.parseUnits("0.01", USDC_DECIMALS);
      const quotedOpenCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );
      const maxCost = (quotedOpenCost * 1005n) / 1000n + 1n;

      // Capture events from multiple operations
      const operations = [];

      // Open position
      const openTx = await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );
      operations.push({ type: "open", tx: openTx });

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      // Increase position
      const quotedIncreaseCost = await core.calculateIncreaseCost(
        positionId,
        quantity
      );
      const increaseMaxCost = (quotedIncreaseCost * 1005n) / 1000n + 1n;

      const increaseTx = await core
        .connect(alice)
        .increasePosition(positionId, quantity, increaseMaxCost);
      operations.push({ type: "increase", tx: increaseTx });

      // Decrease position
      const decreaseTx = await core
        .connect(alice)
        .decreasePosition(positionId, quantity, 0);
      operations.push({ type: "decrease", tx: decreaseTx });

      // Verify all operations emitted their respective events
      await expect(operations[0].tx).to.emit(core, "PositionOpened");
      await expect(operations[1].tx).to.emit(core, "PositionIncreased");
      await expect(operations[2].tx).to.emit(core, "PositionDecreased");
    });

    it("Should handle large numeric values in events", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(createActiveMarket);

      const lowerTick = 100100;
      const upperTick = 100900; // Large range
      const largeQuantity = ethers.parseUnits("0.05", USDC_DECIMALS); // Keep within stable range
      const quotedLargeCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        largeQuantity
      );
      const largeMaxCost = (quotedLargeCost * 1005n) / 1000n + 1n;

      // This should handle large values properly in events
      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            lowerTick,
            upperTick,
            largeQuantity,
            largeMaxCost
          )
      ).to.emit(core, "PositionOpened");
    });
  });

  describe("Settlement Batch Emission", function () {
    it("Should revert when limit is zero", async function () {
      const { core, keeper, alice, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      const lowerTick = 100100;
      const upperTick = 100200;
      const quotedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        SMALL_QUANTITY
      );
      await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          SMALL_QUANTITY,
          applyBuffer(quotedCost)
        );

      await time.increase(MARKET_DURATION + 3600);
      await settleMarketAtTick(core, keeper, marketId, 100140);

      await expect(
        core.connect(keeper).emitPositionSettledBatch(marketId, 0)
      ).to.be.revertedWithCustomError(core, "ZeroLimit");
    });

    it("Should revert when market is not settled", async function () {
      const { core, keeper, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core.connect(keeper).emitPositionSettledBatch(marketId, 1)
      )
        .to.be.revertedWithCustomError(core, "MarketNotSettled")
        .withArgs(marketId);
    });

    it("Should resume cursor across batches and skip burned holes", async function () {
      const {
        core,
        keeper,
        marketId,
        alice,
        charlie,
        aliceId,
        charlieId,
        listLength,
      } = await loadFixture(setupSettledBatchFixture);

      const firstBatch = core
        .connect(keeper)
        .emitPositionSettledBatch(marketId, 1);
      await expect(firstBatch)
        .to.emit(core, "PositionSettled")
        .withArgs(
          aliceId,
          alice.address,
          (payout: bigint) => payout >= 0n,
          (isWin: boolean) => typeof isWin === "boolean"
        );
      await expect(firstBatch)
        .to.emit(core, "PositionEventsProgress")
        .withArgs(BigInt(marketId), 0, 0, false);

      const secondBatch = core
        .connect(keeper)
        .emitPositionSettledBatch(marketId, 1);
      await expect(secondBatch).to.not.emit(core, "PositionSettled");
      await expect(secondBatch)
        .to.emit(core, "PositionEventsProgress")
        .withArgs(BigInt(marketId), 1, 1, false);

      const thirdBatch = core
        .connect(keeper)
        .emitPositionSettledBatch(marketId, 1);
      await expect(thirdBatch)
        .to.emit(core, "PositionSettled")
        .withArgs(
          charlieId,
          charlie.address,
          (payout: bigint) => payout >= 0n,
          (isWin: boolean) => typeof isWin === "boolean"
        );
      await expect(thirdBatch)
        .to.emit(core, "PositionEventsProgress")
        .withArgs(BigInt(marketId), 2, 2, true);

      const market = await core.getMarket(marketId);
      expect(market.positionEventsEmitted).to.be.true;
      expect(Number(market.positionEventsCursor)).to.equal(Number(listLength));

      await expect(
        core.connect(keeper).emitPositionSettledBatch(marketId, 5)
      ).to.not.emit(core, "PositionSettled");
    });
  });

  describe("Market Reopen Flow", function () {
    it("Should revert reopen before settlement", async function () {
      const { core, keeper, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(core.connect(keeper).reopenMarket(marketId))
        .to.be.revertedWithCustomError(core, "MarketNotSettled")
        .withArgs(marketId);
    });

    it("Should reset settlement state and enable new trades", async function () {
      const { core, keeper, alice, marketId } = await loadFixture(
        setupSettledBatchFixture
      );

      await expect(core.connect(keeper).reopenMarket(marketId))
        .to.emit(core, "MarketReopened")
        .withArgs(marketId);

      const market = await core.getMarket(marketId);
      expect(market.settled).to.be.false;
      expect(market.isActive).to.be.true;
      expect(Number(market.positionEventsCursor)).to.equal(0);
      expect(market.positionEventsEmitted).to.be.false;

      const current = await time.latest();
      const newStart = Number(current) + 500;
      const newEnd = newStart + MARKET_DURATION;
      const newSettlement = newEnd + 3600;

      await core
        .connect(keeper)
        .updateMarketTiming(marketId, newStart, newEnd, newSettlement);

      await increaseToSafe(newStart + 1);

      const lowerTick = 100200;
      const upperTick = 100260;
      const quotedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        SMALL_QUANTITY
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            lowerTick,
            upperTick,
            SMALL_QUANTITY,
            applyBuffer(quotedCost)
          )
      ).to.emit(core, "PositionOpened");
    });
  });
});

```


## test/integration/core/pause.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { COMPONENT_TAG } from "../../helpers/tags";
import {
  createActiveMarketFixture,
  settleMarketAtTick,
  increaseToSafe,
} from "../../helpers/fixtures/core";


async function createTestMarket(
  core: any,
  keeper: any,
  startTime: number,
  endTime: number,
  alpha: bigint = ethers.parseEther("0.1"),
  minTick = 100000,
  maxTick = 100990,
  tickSpacing = 10
) {
  const settlementTime = endTime + 3600;
  const marketIdBig = await core
    .connect(keeper)
    .createMarket.staticCall(
      minTick,
      maxTick,
      tickSpacing,
      startTime,
      endTime,
      settlementTime,
      alpha
    );
  await core
    .connect(keeper)
    .createMarket(
      minTick,
      maxTick,
      tickSpacing,
      startTime,
      endTime,
      settlementTime,
      alpha
    );
  const marketId = Number(marketIdBig);
  await core.connect(keeper).setMarketActive(marketId, true);
  return { marketId, settlementTime };
}



describe(`${COMPONENT_TAG} CLMSRMarketCore - Pause Functionality`, function () {
  describe("Pause State Management", function () {
    it("Should not be paused initially", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;

      expect(await core.isPaused()).to.be.false;
    });

    it("Should allow keeper to pause", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      await expect(core.connect(keeper).pause("Emergency pause test"))
        .to.emit(core, "EmergencyPaused")
        .withArgs(keeper.address, "Emergency pause test");

      expect(await core.isPaused()).to.be.true;
    });

    it("Should allow keeper to unpause", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      // Pause first
      await core.connect(keeper).pause("Test pause");
      expect(await core.isPaused()).to.be.true;

      // Then unpause
      await expect(core.connect(keeper).unpause())
        .to.emit(core, "EmergencyUnpaused")
        .withArgs(keeper.address);

      expect(await core.isPaused()).to.be.false;
    });

    it("Should prevent non-keeper from pausing", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice } = contracts;

      await expect(
        core.connect(alice).pause("Test")
      )
        .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
        .withArgs(alice.address);
    });

    it("Should prevent non-keeper from unpausing", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper, alice } = contracts;

      // Keeper pauses first
      await core.connect(keeper).pause("Test pause");

      // Alice tries to unpause
      await expect(core.connect(alice).unpause())
        .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
        .withArgs(alice.address);
    });

    it("Should revert when trying to pause already paused contract", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      // Pause first
      await core.connect(keeper).pause("First pause");

      // Try to pause again - should work (no specific error in implementation)
      await expect(
        core.connect(keeper).pause("Second pause")
      ).to.be.revertedWithCustomError(core, "EnforcedPause");
    });

    it("Should revert when trying to unpause non-paused contract", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      // Contract is not paused initially - should work (no specific error in implementation)
      await expect(core.connect(keeper).unpause()).to.be.revertedWithCustomError(
        core,
        "ExpectedPause"
      );
    });
  });

  describe("Paused State Restrictions", function () {
    it("Should prevent market creation when paused", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      // Pause the contract
      await core.connect(keeper).pause("Emergency");

      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      await expect(
        core
          .connect(keeper)
          .createMarket(
            1,
            100000,
            100990,
            10,
            startTime,
            endTime,
            ethers.parseEther("0.1")
          )
      ).to.be.revertedWithCustomError(core, "EnforcedPause");
    });

    it("Should prevent market settlement when paused", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      const currentTime = Number(await time.latest());
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      // Create market first (before pausing)
      const { marketId, settlementTime } = await createTestMarket(
        core,
        keeper,
        startTime,
        endTime
      );

      // Fast forward to settlement time
      await increaseToSafe(settlementTime + 1);

      // Pause the contract
      await core.connect(keeper).pause("Emergency");

      // Settlement should work even when paused (emergency functionality)
      await expect(
        settleMarketAtTick(core, keeper, marketId, 100490)
      ).to.not.be.reverted;
    });

    it("Should prevent position opening when paused", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, mockPosition } = contracts;

      const currentTime = Number(await time.latest());
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      // Create market first (before pausing)
      const { marketId } = await createTestMarket(
        core,
        keeper,
        startTime,
        endTime
      );

      await increaseToSafe(startTime + 1);

      // Pause the contract
      await core.connect(keeper).pause("Emergency");

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("1", 6),
        maxCost: ethers.parseUnits("10", 6),
      };

      await expect(
        core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            tradeParams.maxCost
          )
      ).to.be.revertedWithCustomError(core, "EnforcedPause");
    });

    it("Should prevent position modification when paused", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, mockPosition } = contracts;

      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      // Create market
      const { marketId } = await createTestMarket(
        core,
        keeper,
        startTime,
        endTime,
        ethers.parseEther("0.1")
      );

      await increaseToSafe(startTime + 1);

      // Open position first (before pausing)
      const tradeParams = {
        marketId: 1,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("0.05", 6),
        maxCost: ethers.parseUnits("1", 6),
      };

      await core
        .connect(alice)
        .openPosition(
          tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity,
          tradeParams.maxCost
        );

      // Pause the contract
      await core.connect(keeper).pause("Emergency");

      // Try to increase position while paused
      await expect(
        core
          .connect(alice)
          .increasePosition(
            1,
            ethers.parseUnits("0.01", 6),
            ethers.parseUnits("1", 6)
          )
      ).to.be.revertedWithCustomError(core, "EnforcedPause");

      // Try to decrease position while paused
      await expect(
        core.connect(alice).decreasePosition(1, ethers.parseUnits("0.01", 6), 0)
      ).to.be.revertedWithCustomError(core, "EnforcedPause");

      // Try to close position while paused
      await expect(
        core.connect(alice).closePosition(1, 0)
      ).to.be.revertedWithCustomError(core, "EnforcedPause");
    });

    it("Should prevent position claiming when paused", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, mockPosition } = contracts;

      const currentTime = Number(await time.latest());
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      // Create market and position
      const { marketId, settlementTime } = await createTestMarket(
        core,
        keeper,
        startTime,
        endTime
      );

      await increaseToSafe(startTime + 1);

      const tradeParams = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("1", 6),
        maxCost: ethers.parseUnits("10", 6),
      };

      await core
        .connect(alice)
        .openPosition(
          tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity,
          tradeParams.maxCost
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      // Settle market
      await increaseToSafe(settlementTime + 1);
      await settleMarketAtTick(core, keeper, marketId, 100150);

      // Pause the contract
      await core.connect(keeper).pause("Emergency");

      // Try to claim settled position while paused
      await expect(
        core.connect(alice).claimPayout(positionId)
      ).to.be.revertedWithCustomError(core, "EnforcedPause");
    });
  });

  describe("View Functions During Pause", function () {
    it("Should allow view functions when paused", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      const currentTime = Number(await time.latest());
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      // Create market first
      const { marketId } = await createTestMarket(
        core,
        keeper,
        startTime,
        endTime
      );

      // Pause the contract
      await core.connect(keeper).pause("Emergency");

      // View functions should still work
      const market = await core.getMarket(marketId);
      expect(market.numBins).to.equal(
        BigInt((100990 - 100000) / 10)
      );

      const cost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        ethers.parseUnits("0.01", 6)
      );
      expect(cost).to.be.gt(0);

      // Pause state check should work
      expect(await core.isPaused()).to.be.true;
    });

    it("Should allow cost calculations when paused", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, mockPosition } = contracts;

      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      const { marketId } = await createTestMarket(
        core,
        keeper,
        startTime,
        endTime,
        ethers.parseEther("0.1")
      );

      await increaseToSafe(startTime + 1);

      const tradeQuantity = ethers.parseUnits("0.01", 6);
      const quotedOpenCost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        tradeQuantity
      );

      await core
        .connect(alice)
        .openPosition(
          marketId,
          100100,
          100200,
          tradeQuantity,
          (quotedOpenCost * 1005n) / 1000n + 1n
        );

      // Pause the contract
      await core.connect(keeper).pause("Emergency");

      // Cost calculations should still work
      const openCost = await core.calculateOpenCost(
        marketId,
        100300,
        100400,
        ethers.parseUnits("0.01", 6)
      );
      expect(openCost).to.be.gt(0);

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      const closeProceeds = await core.calculateCloseProceeds(positionId);
      expect(closeProceeds).to.be.gt(0);
    });
  });

  describe("Resume Operations After Unpause", function () {
    it("Should allow all operations after unpause", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, mockPosition } = contracts;

      // Pause and then unpause
      await core.connect(keeper).pause("Emergency");
      await core.connect(keeper).unpause();

      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      const { marketId } = await createTestMarket(
        core,
        keeper,
        startTime,
        endTime,
        ethers.parseEther("0.1")
      );

      await increaseToSafe(startTime + 1);

      const tradeQuantity = ethers.parseUnits("0.01", 6);
      const quotedOpenCost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        tradeQuantity
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            100100,
            100200,
            tradeQuantity,
            (quotedOpenCost * 1005n) / 1000n + 1n
          )
      ).to.not.be.reverted;

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);
      const quotedIncreaseCost = await core.calculateIncreaseCost(
        positionId,
        tradeQuantity
      );

      await expect(
        core
          .connect(alice)
          .increasePosition(
            positionId,
            tradeQuantity,
            (quotedIncreaseCost * 1005n) / 1000n + 1n
          )
      ).to.not.be.reverted;
    });

    it("Should maintain state consistency across pause/unpause cycles", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, mockPosition, marketId } = contracts;

      const tradeQuantity = ethers.parseUnits("0.01", 6);
      const quotedOpenCost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        tradeQuantity
      );

      await core
        .connect(alice)
        .openPosition(
          marketId,
          100100,
          100200,
          tradeQuantity,
          (quotedOpenCost * 1005n) / 1000n + 1n
        );

      // Get initial state
      const initialMarket = await core.getMarket(marketId);
      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);
      const initialPositionInfo = await mockPosition.getPosition(positionId);

      // Pause and unpause
      await core.connect(keeper).pause("Emergency");
      await core.connect(keeper).unpause();

      // Verify state is preserved
      const finalMarket = await core.getMarket(marketId);
      const finalPositionInfo = await mockPosition.getPosition(positionId);

      expect(finalMarket.numBins).to.equal(initialMarket.numBins);
      expect(finalMarket.liquidityParameter).to.equal(
        initialMarket.liquidityParameter
      );
      expect(finalPositionInfo.quantity).to.equal(initialPositionInfo.quantity);
      expect(finalPositionInfo.marketId).to.equal(initialPositionInfo.marketId);
    });

    it("Should handle multiple pause/unpause cycles", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;

      for (let i = 0; i < 3; i++) {
        // Pause
        await expect(core.connect(keeper).pause(`Emergency ${i}`)).to.emit(
          core,
          "EmergencyPaused"
        );
        expect(await core.isPaused()).to.be.true;

        // Unpause
        await expect(core.connect(keeper).unpause()).to.emit(
          core,
          "EmergencyUnpaused"
        );
        expect(await core.isPaused()).to.be.false;
      }

      // Should still be functional after multiple cycles
      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + 86400;

      await expect(
        core
          .connect(keeper)
          .createMarket(
            1,
            100000,
            100990,
            10,
            startTime,
            endTime,
            ethers.parseEther("0.1")
          )
      ).to.not.be.reverted;
    });
  });

  describe("Emergency Scenarios", function () {
    it("Should handle pause during active trading", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, marketId } = contracts;

      const tradeQuantity = ethers.parseUnits("0.01", 6);
      const quotedOpenCost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        tradeQuantity
      );

      await core
        .connect(alice)
        .openPosition(
          marketId,
          100100,
          100200,
          tradeQuantity,
          (quotedOpenCost * 1005n) / 1000n + 1n
        );

      // Emergency pause during active market
      await core.connect(keeper).pause("Emergency during trading");

      // All trading should be stopped
      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            100100,
            100200,
            tradeQuantity,
            (quotedOpenCost * 1005n) / 1000n + 1n
          )
      ).to.be.revertedWithCustomError(core, "EnforcedPause");

      // But view functions should work
      const market = await core.getMarket(marketId);
      expect(market.startTimestamp).to.be.lte(await time.latest());
    });

    it("Should handle pause during market settlement period", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper, marketId } = contracts;

      const market = await core.getMarket(marketId);
      const endTime = Number(market.endTimestamp);

      // Move to settlement period
      await increaseToSafe(endTime + 1);

      // Pause during settlement period
      await core.connect(keeper).pause("Emergency during settlement");

      // Settlement should work even when paused (emergency functionality)
      await expect(
        settleMarketAtTick(core, keeper, marketId, 100490)
      ).to.not.be.reverted;

      // Market should show as ended
      const settledMarket = await core.getMarket(marketId);
      expect(settledMarket.endTimestamp).to.be.lte(await time.latest());
    });
  });
});

```


## test/integration/core/state-getters.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  createActiveMarketFixture,
  setupActiveMarket,
  setupCustomMarket,
  setMarketActivation,
  settleMarketAtTick,
  toSettlementValue,
  getTickValue,
  createMarketWithConfig,
  increaseToSafe,
} from "../../helpers/fixtures/core";
import { COMPONENT_TAG } from "../../helpers/tags";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

describeMaybe(`${COMPONENT_TAG} CLMSRMarketCore - State Getters`, function () {
  const ALPHA = ethers.parseEther("1");
  const MIN_TICK = 100000;
  const MAX_TICK = 100990;
  const TICK_SPACING = 10;
  const MARKET_DURATION = 86400; // 1 day
  const USDC_DECIMALS = 6;
  const POSITION_QUANTITY = ethers.parseUnits("10", USDC_DECIMALS);
  const POSITION_MAX_COST = ethers.parseUnits("1000", USDC_DECIMALS);

  describe("Market Information Getters", function () {
    it("Should return correct market information after creation", async function () {
      const { core, keeper, marketId, startTime, endTime } = await loadFixture(
        createActiveMarketFixture
      );

      const market = await core.getMarket(marketId);

      expect(market.startTimestamp).to.equal(startTime);
      expect(market.endTimestamp).to.equal(endTime);
      expect(market.liquidityParameter).to.equal(ALPHA);
      expect(market.settled).to.be.false;
    });

    it("Should return correct market status transitions", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      // ÏãúÍ∞Ñ ÏÉÅÌÉú Î≥ÄÌôîÎ•º ÌÖåÏä§Ìä∏ÌïòÍ∏∞ ÏúÑÌï¥ ÎØ∏Îûò ÏãúÍ∞ÑÏúºÎ°ú ÎßàÏºì ÏÉùÏÑ±
      const currentTime = await time.latest();
      const startTime = currentTime + 1000; // ÎØ∏Îûò ÏãúÍ∞Ñ
      const endTime = startTime + MARKET_DURATION;
      const marketId = await createMarketWithConfig(core, keeper, {
        minTick: MIN_TICK,
        maxTick: MAX_TICK,
        tickSpacing: TICK_SPACING,
        startTime,
        endTime,
        liquidityParameter: ALPHA,
      });

      // Market should be PENDING before start time
      let market = await core.getMarket(marketId);
      expect(market.startTimestamp).to.be.gt(await time.latest());

      // Fast forward to market start
      await increaseToSafe(startTime + 1);
      market = await core.getMarket(marketId);
      expect(market.startTimestamp).to.be.lte(await time.latest());

      // Fast forward past market end
      await increaseToSafe(endTime + 1);
      market = await core.getMarket(marketId);
      expect(market.endTimestamp).to.be.lte(await time.latest());
      expect(market.settled).to.be.false;

      // Settle market using helper
      await settleMarketAtTick(core, keeper, marketId, 100450);
      market = await core.getMarket(marketId);
      expect(market.settled).to.be.true;
      expect(market.settlementTick).to.equal(BigInt(100450));
      expect(market.settlementValue).to.equal(toSettlementValue(100450));
    });

    it("Should handle multiple markets independently", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core } = contracts;

      // Îëê Í∞úÏùò ÎèÖÎ¶ΩÏ†ÅÏù∏ ÎßàÏºì ÏÉùÏÑ±
      const marketConfig1 = await setupCustomMarket(contracts, {
        numTicks: 50, // 100000-100490
      });
      const marketConfig2 = await setupCustomMarket(contracts, {
        numTicks: 100, // 100000-100990
      });

      const marketId1 = marketConfig1.marketId;
      const marketId2 = marketConfig2.marketId;

      // Get both markets
      const marketInfo1 = await core.getMarket(marketId1);
      const marketInfo2 = await core.getMarket(marketId2);

      expect(marketInfo1.startTimestamp).to.equal(marketConfig1.startTime);
      expect(marketInfo2.startTimestamp).to.equal(marketConfig2.startTime);
      expect(marketInfo1.endTimestamp).to.equal(marketConfig1.endTime);
      expect(marketInfo2.endTimestamp).to.equal(marketConfig2.endTime);
    });

    it("Should revert when getting info for non-existent market", async function () {
      const { core } = await loadFixture(createActiveMarketFixture);

      await expect(core.getMarket(999)).to.be.revertedWithCustomError(
        core,
        "MarketNotFound"
      );
    });

    it("Should return correct tick values after market creation", async function () {
      const { core, keeper, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      // Check initial tick values (should all be WAD initially)
      const WAD = ethers.parseEther("1");

      const tickValue1 = await getTickValue(core, marketId, 100000);
      const tickValue2 = await getTickValue(core, marketId, 100500);
      const tickValue3 = await getTickValue(core, marketId, 100990);

      expect(tickValue1).to.equal(WAD);
      expect(tickValue2).to.equal(WAD);
      expect(tickValue3).to.equal(WAD);
    });

    it("Should handle tick value queries for invalid ticks", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;
      const { marketId, startTime, endTime } = await setupActiveMarket(
        contracts
      );

      // Should revert for ticks outside the valid range
      await expect(
        core.getRangeSum(marketId, 99999, 99999 + TICK_SPACING)
      ).to.be.revertedWithCustomError(core, "InvalidTick");

      await expect(
        core.getRangeSum(marketId, 101000, 101000 + TICK_SPACING)
      ).to.be.revertedWithCustomError(core, "InvalidTick");
    });

    it("Should handle tick value queries for non-existent markets", async function () {
      const { core } = await loadFixture(createActiveMarketFixture);

      await expect(
        core.getRangeSum(999, 100500, 100500 + TICK_SPACING)
      ).to.be.revertedWithCustomError(core, "MarketNotFound");
    });
  });

  describe("Position Information Getters", function () {
    it("Should return correct position information after opening", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(
        createActiveMarketFixture
      );

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = POSITION_QUANTITY;
      const maxCost = POSITION_MAX_COST;

      // Open position
      await core
        .connect(alice)
        .openPosition(marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      // Get position information
      const positionData = await mockPosition.getPosition(1);

      expect(positionData.marketId).to.equal(marketId);
      expect(positionData.lowerTick).to.equal(lowerTick);
      expect(positionData.upperTick).to.equal(upperTick);
      expect(positionData.quantity).to.equal(quantity);

      // Check ownership
      const owner = await mockPosition.ownerOf(1);
      expect(owner).to.equal(alice.address);

      // Check user's positions
      const userPositions = await mockPosition.getPositionsByOwner(
        alice.address
      );
      expect(userPositions).to.have.length(1);
      expect(userPositions[0]).to.equal(1);
    });

    it("Should track position count correctly", async function () {
      const { core, alice, bob, marketId, mockPosition } = await loadFixture(
        createActiveMarketFixture
      );

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = POSITION_QUANTITY;
      const maxCost = POSITION_MAX_COST;

      // Initially no positions
      expect(await mockPosition.totalSupply()).to.equal(0);

      // Open first position
      await core
        .connect(alice)
        .openPosition(marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      expect(await mockPosition.totalSupply()).to.equal(1);

      // Open second position (different user)
      await core
        .connect(bob)
        .openPosition(marketId, 100300, 100400, quantity, maxCost);

      expect(await mockPosition.totalSupply()).to.equal(2);

      // Open third position (same user as first)
      await core
        .connect(alice)
        .openPosition(marketId,
          100500,
          100600,
          quantity,
          maxCost
        );

      expect(await mockPosition.totalSupply()).to.equal(3);

      // Check individual user counts
      const alicePositions = await mockPosition.getPositionsByOwner(
        alice.address
      );
      const bobPositions = await mockPosition.getPositionsByOwner(bob.address);

      expect(alicePositions).to.have.length(2);
      expect(bobPositions).to.have.length(1);
    });

    it("Should handle position ownership correctly", async function () {
      const { core, alice, bob, charlie, marketId, mockPosition } =
        await loadFixture(createActiveMarketFixture);

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = POSITION_QUANTITY;
      const maxCost = POSITION_MAX_COST;

      // Open position
      await core
        .connect(alice)
        .openPosition(marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      const positionId = 1;

      // Check initial ownership
      expect(await mockPosition.ownerOf(positionId)).to.equal(alice.address);

      // Transfer position to bob
      await mockPosition
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      // Check ownership after transfer
      expect(await mockPosition.ownerOf(positionId)).to.equal(bob.address);

      // Check user position lists are updated
      const alicePositions = await mockPosition.getPositionsByOwner(
        alice.address
      );
      const bobPositions = await mockPosition.getPositionsByOwner(bob.address);

      expect(alicePositions).to.have.length(0);
      expect(bobPositions).to.have.length(1);
      expect(bobPositions[0]).to.equal(positionId);

      // Transfer to charlie
      await mockPosition
        .connect(bob)
        .transferFrom(bob.address, charlie.address, positionId);

      expect(await mockPosition.ownerOf(positionId)).to.equal(charlie.address);
    });
  });

  describe("Market State Calculations", function () {
    it("Should calculate open costs correctly", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, keeper } = contracts;
      const { marketId, startTime, endTime } = await setupActiveMarket(
        contracts
      );

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = POSITION_QUANTITY;

      const cost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );

      expect(cost).to.be.gt(0);
      expect(cost).to.be.lt(POSITION_MAX_COST);
    });

    it("Should calculate close costs correctly", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, mockPosition } = contracts;
      const { marketId, startTime, endTime } = await setupActiveMarket(
        contracts
      );

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = POSITION_QUANTITY;
      const maxCost = POSITION_MAX_COST;

      // Open position first
      await core
        .connect(alice)
        .openPosition(marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      expect(positions.length).to.be.gte(
        1,
        "Expected at least one position after opening"
      );
      const positionId = positions[positions.length - 1];

      // Calculate close proceeds
      const proceeds = await core.calculateCloseProceeds(positionId);

      expect(proceeds).to.be.gte(0);
      expect(proceeds).to.be.lt(maxCost); // Should get less back than paid
    });

    it("Should calculate settled payouts correctly", async function () {
      const { core, alice, keeper, mockPosition, marketId, endTime } =
        await loadFixture(createActiveMarketFixture);

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = POSITION_QUANTITY;
      const maxCost = POSITION_MAX_COST;

      // Open position
      await core
        .connect(alice)
        .openPosition(marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      // Fast forward past market end
      await increaseToSafe(endTime + 1);

      // Settle market with winning outcome in range
      await settleMarketAtTick(core, keeper, marketId, 100150);

      // Calculate claim amount
      const claimAmount = await core.calculateClaimAmount(positionId);

      expect(claimAmount).to.be.gt(0);
    });

    it("Should handle cost calculations for different tick ranges", async function () {
      const { core, keeper, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      const quantity = POSITION_QUANTITY;

      // Calculate costs for different ranges
      const narrowCost = await core.calculateOpenCost(
        marketId,
        100100,
        100110,
        quantity
      );
      const wideCost = await core.calculateOpenCost(
        marketId,
        100100,
        100200,
        quantity
      );
      const veryWideCost = await core.calculateOpenCost(
        marketId,
        100100,
        100500,
        quantity
      );

      // Wider ranges should generally cost more
      expect(wideCost).to.be.gte(narrowCost);
      expect(veryWideCost).to.be.gte(wideCost);
    });
  });

  describe("Market Existence and Validation", function () {
    it("Should correctly identify existing vs non-existing markets", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const nonexistentId = 999999;
      await expect(core.getMarket(nonexistentId)).to.be.revertedWithCustomError(
        core,
        "MarketNotFound"
      );

      const currentTime = await time.latest();
      const startTime = currentTime + 1000;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      const createdMarketId = await createMarketWithConfig(core, keeper, {
        minTick: MIN_TICK,
        maxTick: MAX_TICK,
        tickSpacing: TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        liquidityParameter: ALPHA,
      });

      const market = await core.getMarket(createdMarketId);
      expect(market.startTimestamp).to.equal(startTime);
      expect(market.endTimestamp).to.equal(endTime);

      const missingId = createdMarketId + 1000;
      await expect(core.getMarket(missingId)).to.be.revertedWithCustomError(
        core,
        "MarketNotFound"
      );
    });

    it("Should validate market parameters on creation", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      await expect(
        core
          .connect(keeper)
          .createMarket(
            MIN_TICK,
            MIN_TICK - 10,
            TICK_SPACING,
            startTime,
            endTime,
            settlementTime,
            ALPHA
          )
      ).to.be.revertedWithCustomError(core, "InvalidMarketParameters");

      await expect(
        core
          .connect(keeper)
          .createMarket(
            MIN_TICK,
            MAX_TICK,
            TICK_SPACING,
            endTime,
            startTime,
            settlementTime,
            ALPHA
          )
      ).to.be.revertedWithCustomError(core, "InvalidTimeRange");

      await expect(
        core
          .connect(keeper)
          .createMarket(
            MIN_TICK,
            MAX_TICK,
            TICK_SPACING,
            startTime,
            endTime,
            settlementTime,
            ALPHA
          )
      ).not.to.be.reverted;
    });

    it("Should generate unique market identifiers", async function () {
      const contracts = await loadFixture(coreFixture);
      const { core, keeper } = contracts;

      const currentTime = await time.latest();
      const startTime = currentTime + 100;
      const endTime = startTime + MARKET_DURATION;

      const firstMarketId = await createMarketWithConfig(core, keeper, {
        minTick: MIN_TICK,
        maxTick: MAX_TICK,
        tickSpacing: TICK_SPACING,
        startTime,
        endTime,
        liquidityParameter: ALPHA,
      });

      const secondMarketId = await createMarketWithConfig(core, keeper, {
        minTick: MIN_TICK + TICK_SPACING,
        maxTick: MAX_TICK + TICK_SPACING,
        tickSpacing: TICK_SPACING,
        startTime: startTime + 500,
        endTime: endTime + 500,
        liquidityParameter: ALPHA,
      });

      expect(secondMarketId).to.be.gt(firstMarketId);
    });
  });

  describe("Market State Queries", function () {
    it("Should return correct market information", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;
      const { marketId, startTime, endTime } = await setupCustomMarket(
        contracts,
        {
          alpha: ethers.parseEther("10"),
        }
      );

      const market = await core.getMarket(marketId);

      expect(market.startTimestamp).to.equal(startTime);
      expect(market.endTimestamp).to.equal(endTime);
      expect(market.liquidityParameter).to.equal(ethers.parseEther("10"));
      expect(market.settled).to.be.false;
    });

    it("Should return correct tick values", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: ethers.parseEther("10"),
      });

      const WAD = ethers.parseEther("1");

      // All ticks should initially have value WAD
      expect(await getTickValue(core, marketId, 100000)).to.equal(WAD);
      expect(await getTickValue(core, marketId, 100500)).to.equal(WAD);
      expect(await getTickValue(core, marketId, 100990)).to.equal(WAD);
    });

    it("Should handle queries for non-existent markets", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;
      await setupCustomMarket(contracts, {
        alpha: ethers.parseEther("10"),
      });

      await expect(core.getMarket(999)).to.be.revertedWithCustomError(
        core,
        "MarketNotFound"
      );

      await expect(
        core.getRangeSum(999, 100500, 100500 + TICK_SPACING)
      ).to.be.revertedWithCustomError(core, "MarketNotFound");
    });

    it("Should handle invalid tick queries", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core } = contracts;
      const { marketId } = await setupCustomMarket(contracts, {
        alpha: ethers.parseEther("10"),
      });

      // Ticks outside the valid range
      await expect(
        core.getRangeSum(marketId, 99999, 99999 + TICK_SPACING)
      ).to.be.revertedWithCustomError(core, "InvalidTick");

      await expect(
        core.getRangeSum(marketId, 101000, 101000 + TICK_SPACING)
      ).to.be.revertedWithCustomError(core, "InvalidTick");

      // Invalid tick spacing
      await expect(
        core.getRangeSum(marketId, 100001, 100001 + TICK_SPACING)
      ).to.be.revertedWithCustomError(core, "InvalidTickSpacing");
    });
  });

  describe("State Consistency Checks", function () {
    it("Should maintain consistent state after multiple operations", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, bob, keeper } = contracts;
      const { marketId, startTime, endTime } = await setupActiveMarket(
        contracts
      );

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = POSITION_QUANTITY;
      const maxCost = POSITION_MAX_COST;

      // Perform multiple operations
      await core
        .connect(alice)
        .openPosition(marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );

      await core
        .connect(bob)
        .openPosition(marketId, 100300, 100400, quantity, maxCost);

      // State should remain consistent
      const market = await core.getMarket(marketId);
      expect(market.startTimestamp).to.equal(startTime);
      expect(market.endTimestamp).to.equal(endTime);

      // Tick values should be updated but still reasonable
      const tickValue = await getTickValue(core, marketId, 100150);
      expect(tickValue).to.be.gt(ethers.parseEther("1")); // Should be greater than initial WAD
    });

    it("Should handle view functions during different market states", async function () {
      const contracts = await loadFixture(createActiveMarketFixture);
      const { core, alice, keeper, mockPosition } = contracts;

      const currentTime = Number(await time.latest());
      const startTime = currentTime + 100;
      const endTime = startTime + MARKET_DURATION;
      const settlementTime = endTime + 3600;

      const marketIdBig = await core
        .connect(keeper)
        .createMarket.staticCall(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA
        );

      await core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA
        );

      const marketId = Number(marketIdBig);
      await setMarketActivation(core, keeper, marketId, true);

      // PENDING state - before market starts
      let market = await core.getMarket(marketId);
      expect(market.startTimestamp).to.equal(BigInt(startTime));

      const lowerTick = 100100;
      const upperTick = 100200;
      const quantity = POSITION_QUANTITY;

      // Should be able to calculate costs even before market starts
      const preCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );
      expect(preCost).to.be.gt(0);

      // ACTIVE state - during market
      await increaseToSafe(startTime + 1);
      const activeCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );
      expect(activeCost).to.equal(preCost); // Should be same as market state hasn't changed

      // Open a position
      const maxCost = POSITION_MAX_COST;
      await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          quantity,
          maxCost
        );
      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);

      // ENDED state - after market ends
      await increaseToSafe(endTime + 1);
      market = await core.getMarket(marketId);
      expect(market.endTimestamp).to.be.lte(await time.latest());

      // SETTLED state
      await settleMarketAtTick(core, keeper, marketId, 100150);
      market = await core.getMarket(marketId);
      expect(market.settled).to.be.true;

      // Should still be able to query state
      const claimAmount = await core.calculateClaimAmount(positionId);
      expect(claimAmount).to.be.gte(0);
    });
  });
});

```


## test/integration/core/storage-layout.spec.ts

```typescript
import { expect } from "chai";
import { artifacts } from "hardhat";
import { COMPONENT_TAG } from "../../helpers/tags";

describe(`${COMPONENT_TAG} CLMSRMarketCoreStorage - Storage layout`, function () {
  let layout: any;

  before(async function () {
    const buildInfo = await artifacts.getBuildInfo(
      "contracts/core/storage/CLMSRMarketCoreStorage.sol:CLMSRMarketCoreStorage"
    );

    if (!buildInfo) {
      throw new Error("Missing build info for CLMSRMarketCoreStorage");
    }

    const contracts =
      buildInfo.output.contracts["contracts/core/storage/CLMSRMarketCoreStorage.sol"];
    layout = contracts.CLMSRMarketCoreStorage.storageLayout;
  });

  it("includes settlement oracle state mapping with expected members", function () {
    const mappingEntry = layout.storage.find(
      (slot: any) => slot.label === "settlementOracleState"
    );
    expect(mappingEntry, "settlementOracleState mapping not found").to.exist;

    const mappingType = layout.types[mappingEntry.type];
    expect(mappingType?.encoding).to.equal("mapping");
    expect(String(mappingType?.value)).to.contain("SettlementOracleState");

    const structType = layout.types[mappingType.value];
    expect(structType, "SettlementOracleState struct missing from layout").to.exist;

    const memberLabels = (structType.members || []).map((m: any) => m.label);
    expect(memberLabels).to.include.members([
      "candidateValue",
      "candidatePriceTimestamp",
    ]);

    const candidateValueType = structType.members.find(
      (m: any) => m.label === "candidateValue"
    )?.type;
    const candidateTimestampType = structType.members.find(
      (m: any) => m.label === "candidatePriceTimestamp"
    )?.type;

    expect(candidateValueType).to.match(/^t_int256$/);
    expect(candidateTimestampType).to.match(/^t_uint64$/);
  });

  it("exposes signer slot and shrinks the gap after inserting new fields", function () {
    const signerEntry = layout.storage.find(
      (slot: any) => slot.label === "settlementOracleSigner"
    );
    expect(signerEntry, "settlementOracleSigner not found").to.exist;
    expect(signerEntry.type).to.equal("t_address");

    const gapEntry = layout.storage.find((slot: any) => slot.label === "__gap");
    expect(gapEntry, "__gap slot missing").to.exist;

    const match = /t_array\(t_uint256\)(\d+)_storage/.exec(gapEntry.type);
    expect(match?.[1]).to.equal("43");
  });
});

```


## test/integration/market/claim-gating.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import {
  coreFixture,
  createMarketWithConfig,
  toSettlementValue,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";
import type { CLMSRMarketCore } from "../../../typechain-types";
import {
  DataPackage,
  NumericDataPoint,
  RedstonePayload,
} from "@redstone-finance/protocol";
import type { Wallet } from "ethers";

const SUBMIT_WINDOW = 10 * 60; // 10 minutes
const FINALIZE_DEADLINE = 15 * 60; // 15 minutes
const DATA_FEED_ID = "BTC";
const DATA_SERVICE_ID = "redstone-primary-prod";
const FEED_DECIMALS = 8;
const AUTHORISED_SIGNER_KEYS = [
  "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
  "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
  "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a",
];
const authorisedWallets = AUTHORISED_SIGNER_KEYS.map(
  (key) => new ethers.Wallet(key)
);
const SUBMIT_IFACE = new ethers.Interface([
  "function submitSettlement(uint256 marketId)",
]);

describe(`${INTEGRATION_TAG} claim gating after settlement`, function () {
  async function fixture() {
    const contracts = await coreFixture();
    const { core, keeper, alice } = contracts;
    const coreTyped = core as unknown as CLMSRMarketCore;

    const now = await time.latest();
    const startTime = now + 100;
    const endTime = startTime + 100;
    const settlementTime = endTime + 200;

    const marketId = await createMarketWithConfig(coreTyped, keeper, {
      minTick: 100000,
      maxTick: 100500,
      tickSpacing: 10,
      startTime,
      endTime,
      settlementTime,
      liquidityParameter: ethers.parseEther("1"),
      feePolicy: ethers.ZeroAddress,
    });

    await coreTyped.connect(keeper).setMarketActive(marketId, true);

    // move just after start
    await time.increaseTo(startTime + 1);

    // open a small position
    await coreTyped
      .connect(alice)
      .openPosition(marketId, 100000, 100010, 1_000_000n, ethers.MaxUint256);

    return { ...contracts, core: coreTyped, marketId, settlementTime };
  }

  function buildSignedDataPackage(
    valueNumeric: number,
    timestampSec: number,
    signer: Wallet
  ) {
    const dataPoint = new NumericDataPoint({
      dataFeedId: DATA_FEED_ID,
      value: valueNumeric,
      decimals: FEED_DECIMALS,
    });
    const pkg = new DataPackage(
      [dataPoint],
      timestampSec * 1000,
      DATA_FEED_ID
    );
    return pkg.sign(signer.privateKey);
  }

  function buildRedstonePayload(
    valueNumeric: number,
    timestampSec: number,
    signers: Wallet[]
  ) {
    const signedPackages = signers.map((signer) =>
      buildSignedDataPackage(valueNumeric, timestampSec, signer)
    );
    return RedstonePayload.prepare(signedPackages, DATA_SERVICE_ID);
  }

  async function submitWithPayload(
    core: CLMSRMarketCore,
    submitter: any,
    marketId: number | bigint,
    payload: string
  ) {
    const baseData = SUBMIT_IFACE.encodeFunctionData("submitSettlement", [
      marketId,
    ]);
    const data = `${baseData}${payload.replace(/^0x/, "")}`;
    return submitter.sendTransaction({
      to: await core.getAddress(),
      data,
    });
  }

  it("blocks claim before T+15 even after settlement, allows after", async function () {
    const { core, marketId, settlementTime, alice, keeper } = await loadFixture(
      fixture
    );

    // submit candidate
    const settlementValue = toSettlementValue(100005);
    const priceTimestamp = settlementTime + 1;

    await time.increaseTo(settlementTime + 1);

    const payload = buildRedstonePayload(
      100_005,
      priceTimestamp,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);

    // finalize within window
    await time.increaseTo(settlementTime + SUBMIT_WINDOW + 1);
    await core.connect(alice).finalizeSettlement(marketId, false);

    const market = await core.getMarket(marketId);
    expect(market.settlementTimestamp).to.equal(BigInt(settlementTime));
    const claimOpen =
      Number(
        market.settlementTimestamp === 0n
          ? market.endTimestamp
          : market.settlementTimestamp
      ) + FINALIZE_DEADLINE;
    const nowAfterFinalize = await time.latest();
    expect(BigInt(claimOpen)).to.be.greaterThan(nowAfterFinalize);

    // before claimOpen: claim should revert
    await time.increaseTo(claimOpen - 10);
    await expect(core.connect(alice).claimPayout(1)).to.be.reverted;

    // after claimOpen: claim succeeds
    await time.increaseTo(claimOpen + 1);
    await expect(core.connect(alice).claimPayout(1)).to.emit(
      core,
      "PositionClaimed"
    );
  });

  it("enforces claim gate after manual settleMarket", async function () {
    const { core, marketId, settlementTime, keeper, alice } =
      await loadFixture(fixture);

    // manual settle by owner (keeper)
    await time.increaseTo(settlementTime + 1);
    await core.connect(keeper).settleMarket(marketId, toSettlementValue(100010));

    const market = await core.getMarket(marketId);
    const claimOpen =
      Number(
        market.settlementTimestamp === 0n
          ? market.endTimestamp
          : market.settlementTimestamp
      ) + FINALIZE_DEADLINE;

    await time.setNextBlockTimestamp(claimOpen - 100);
    await expect(core.connect(alice).claimPayout(1)).to.be.reverted;

    await time.setNextBlockTimestamp(claimOpen + 1);
    await expect(core.connect(alice).claimPayout(1)).to.emit(
      core,
      "PositionClaimed"
    );
  });
});

```


## test/integration/market/create.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  getTickValue,
  setMarketActivation,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";
describe(`${INTEGRATION_TAG} Market Creation`, function () {
  const ALPHA = ethers.parseEther("1");
  const MARKET_DURATION = 7 * 24 * 60 * 60; // 7 days
  const SETTLEMENT_OFFSET = 3600; // 1 hour after end

  // ÌëúÏ§Ä Ìã± ÏãúÏä§ÌÖú ÌååÎùºÎØ∏ÌÑ∞
  const MIN_TICK = 100000;
  const MAX_TICK = 100990;
  const TICK_SPACING = 10;

  function calculateNumBins(
    minTick: number,
    maxTick: number,
    tickSpacing: number
  ) {
    return (maxTick - minTick) / tickSpacing;
  }

  it("Should create market successfully", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const settlementTime = endTime + SETTLEMENT_OFFSET;

    const expectedId = await core
      .connect(keeper)
      .createMarket.staticCall(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );

    const tx = core
      .connect(keeper)
      .createMarket(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );

    await expect(tx)
      .to.emit(core, "MarketCreated")
      .withArgs(
        expectedId,
        BigInt(startTime),
        BigInt(endTime),
        BigInt(MIN_TICK),
        BigInt(MAX_TICK),
        BigInt(TICK_SPACING),
        calculateNumBins(MIN_TICK, MAX_TICK, TICK_SPACING),
        ALPHA
      );

    await expect(tx)
      .to.emit(core, "MarketActivationUpdated")
      .withArgs(expectedId, false);

    const market = await core.getMarket(Number(expectedId));
    expect(market.minTick).to.equal(BigInt(MIN_TICK));
    expect(market.maxTick).to.equal(BigInt(MAX_TICK));
    expect(market.tickSpacing).to.equal(BigInt(TICK_SPACING));
    expect(market.numBins).to.equal(
      calculateNumBins(MIN_TICK, MAX_TICK, TICK_SPACING)
    );
    expect(market.liquidityParameter).to.equal(ALPHA);
    expect(market.startTimestamp).to.equal(BigInt(startTime));
    expect(market.endTimestamp).to.equal(BigInt(endTime));
    expect(market.settlementTimestamp).to.equal(BigInt(settlementTime));
    expect(market.isActive).to.be.false;
    expect(market.settled).to.be.false;
    expect(market.settlementTick).to.equal(BigInt(0));
    expect(market.settlementValue).to.equal(BigInt(0));

    await setMarketActivation(core, keeper, Number(expectedId), true);
    const activated = await core.getMarket(Number(expectedId));
    expect(activated.isActive).to.be.true;
  });

  it("Should initialize segment tree correctly", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const WAD = ethers.parseEther("1");
    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const settlementTime = endTime + SETTLEMENT_OFFSET;

    const marketId = await core
      .connect(keeper)
      .createMarket.staticCall(
        1000,
        1099,
        1,
        startTime,
        endTime,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );

    await core
      .connect(keeper)
      .createMarket(
        1000,
        1099,
        1,
        startTime,
        endTime,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );

    for (let i = 0; i < 10; i++) {
      const actualTick = 1000 + i;
      const tickValue = await getTickValue(core, Number(marketId), actualTick);
      expect(tickValue).to.equal(WAD);
    }
  });

  it("Should create multiple markets sequentially", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const settlementTime = endTime + SETTLEMENT_OFFSET;

    for (let i = 1; i <= 5; i++) {
      const expectedId = await core
        .connect(keeper)
        .createMarket.staticCall(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime + i * 1000,
          endTime + i * 1000,
          settlementTime + i * 1000,
          ALPHA
        );

      const tx = await core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime + i * 1000,
          endTime + i * 1000,
          settlementTime + i * 1000,
          ALPHA
        );
      await tx.wait();

      expect(expectedId).to.equal(BigInt(i));
      const market = await core.getMarket(Number(expectedId));
      expect(market.isActive).to.be.false;
      expect(market.numBins).to.equal(
        calculateNumBins(MIN_TICK, MAX_TICK, TICK_SPACING)
      );

      await setMarketActivation(core, keeper, Number(expectedId), true);
      const activated = await core.getMarket(Number(expectedId));
      expect(activated.isActive).to.be.true;
    }
  });

  it("Should compute bin counts for various ranges", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const settlementTime = endTime + SETTLEMENT_OFFSET;

    const testCases = [
      { minTick: 100000, maxTick: 100010 },
      { minTick: 100000, maxTick: 100090 },
      { minTick: 100000, maxTick: 100990 },
      { minTick: 100000, maxTick: 109990 },
      { minTick: 100000, maxTick: 149990 },
    ];

    for (const { minTick, maxTick } of testCases) {
      const marketId = await core
        .connect(keeper)
        .createMarket.staticCall(
          minTick,
          maxTick,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA
        );

      await core
        .connect(keeper)
        .createMarket(
          minTick,
          maxTick,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA
        );

      const market = await core.getMarket(Number(marketId));
      expect(market.numBins).to.equal(
        calculateNumBins(minTick, maxTick, TICK_SPACING)
      );
    }
  });

  it("Should handle various liquidity parameters", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const settlementTime = endTime + SETTLEMENT_OFFSET;

    const testAlphas = [
      ethers.parseEther("0.001"),
      ethers.parseEther("0.01"),
      ethers.parseEther("0.1"),
      ethers.parseEther("1"),
      ethers.parseEther("10"),
      ethers.parseEther("100"),
      ethers.parseEther("1000"),
    ];

    for (const alpha of testAlphas) {
      const marketId = await core
        .connect(keeper)
        .createMarket.staticCall(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          alpha
        );

      await core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          alpha
        );

      const market = await core.getMarket(Number(marketId));
      expect(market.liquidityParameter).to.equal(alpha);
    }
  });

  it("Should validate time range correctly", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const settlementTime = endTime + SETTLEMENT_OFFSET;

    await expect(
      core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          startTime,
          settlementTime,
          ALPHA
        )
    ).to.be.revertedWithCustomError(core, "InvalidTimeRange");

    await expect(
      core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          endTime,
          startTime,
          settlementTime,
          ALPHA
        )
    ).to.be.revertedWithCustomError(core, "InvalidTimeRange");

    await expect(
      core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          endTime,
          ALPHA
        )
    ).to.be.revertedWithCustomError(core, "InvalidTimeRange");
  });

  it("Should validate liquidity parameter boundaries", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const settlementTime = endTime + SETTLEMENT_OFFSET;

    const minAlpha = await core.MIN_LIQUIDITY_PARAMETER();
    const maxAlpha = await core.MAX_LIQUIDITY_PARAMETER();

    await expect(
      core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          minAlpha - 1n
        )
    ).to.be.revertedWithCustomError(core, "InvalidLiquidityParameter");

    await expect(
      core
        .connect(keeper)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          maxAlpha + 1n
        )
    ).to.be.revertedWithCustomError(core, "InvalidLiquidityParameter");

    await core
      .connect(keeper)
      .createMarket(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        minAlpha
      );

    await core
      .connect(keeper)
      .createMarket(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        startTime,
        endTime,
        settlementTime,
        maxAlpha
      );
  });

  it("Should only allow manager to create markets", async function () {
    const { core, alice, bob } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const settlementTime = endTime + SETTLEMENT_OFFSET;

    await expect(
      core
        .connect(alice)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA
        )
    )
      .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
      .withArgs(alice.address);

    await expect(
      core
        .connect(bob)
        .createMarket(
          MIN_TICK,
          MAX_TICK,
          TICK_SPACING,
          startTime,
          endTime,
          settlementTime,
          ALPHA
        )
    )
      .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
      .withArgs(bob.address);
  });
});

```


## test/integration/market/finalize-oracle.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import {
  coreFixture,
  createMarketWithConfig,
  toSettlementValue,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";
import type { CLMSRMarketCore } from "../../../typechain-types";
import {
  DataPackage,
  NumericDataPoint,
  RedstonePayload,
} from "@redstone-finance/protocol";
import type { Wallet } from "ethers";

const SUBMIT_WINDOW = 10 * 60; // 10 minutes
const FINALIZE_DEADLINE = 15 * 60; // 15 minutes
const ORACLE_STATE_SLOT = 9; // settlementOracleState mapping slot index
const MIN_TICK = 100000;
const MAX_TICK = 100500;
const DATA_FEED_ID = "BTC";
const DATA_SERVICE_ID = "redstone-primary-prod";
const FEED_DECIMALS = 8;

const AUTHORISED_SIGNER_KEYS = [
  "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80", // hardhat default #0
  "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d", // hardhat default #1
  "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a", // hardhat default #2
];
const authorisedWallets = AUTHORISED_SIGNER_KEYS.map(
  (key) => new ethers.Wallet(key)
);
const SUBMIT_IFACE = new ethers.Interface([
  "function submitSettlement(uint256 marketId)",
]);

describe(`${INTEGRATION_TAG} finalizeSettlement windows and state`, function () {
  async function fixture() {
    const contracts = await coreFixture();
    const { core, keeper } = contracts;
    const coreTyped = core as unknown as CLMSRMarketCore;

    const now = await time.latest();
    const startTime = now - 400;
    const endTime = now - 100;
    const settlementTime = now + 100;

    const marketId = await createMarketWithConfig(coreTyped, keeper, {
      minTick: MIN_TICK,
      maxTick: MAX_TICK,
      tickSpacing: 10,
      startTime,
      endTime,
      settlementTime,
      liquidityParameter: ethers.parseEther("1"),
      feePolicy: ethers.ZeroAddress,
    });

    return { ...contracts, core: coreTyped, marketId, settlementTime, keeper };
  }

  function mappingSlot(marketId: number | bigint) {
    return BigInt(
      ethers.keccak256(
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["uint256", "uint256"],
          [marketId, ORACLE_STATE_SLOT]
        )
      )
    );
  }

  async function setCandidateRaw(core: any, marketId: number, value: bigint, ts: number) {
    const base = mappingSlot(marketId);
    const coreAddress = await core.getAddress();
    await ethers.provider.send("hardhat_setStorageAt", [
      coreAddress,
      ethers.toBeHex(base, 32),
      ethers.toBeHex(value, 32),
    ]);
    await ethers.provider.send("hardhat_setStorageAt", [
      coreAddress,
      ethers.toBeHex(base + 1n, 32),
      ethers.toBeHex(BigInt(ts), 32),
    ]);
  }

  function buildSignedDataPackage(
    valueWithDecimals: number,
    timestampSec: number,
    signer: Wallet
  ) {
    const dataPoint = new NumericDataPoint({
      dataFeedId: DATA_FEED_ID,
      value: valueWithDecimals,
      decimals: FEED_DECIMALS,
    });
    const pkg = new DataPackage(
      [dataPoint],
      timestampSec * 1000,
      DATA_FEED_ID
    );
    return pkg.sign(signer.privateKey);
  }

  function buildRedstonePayload(
    valueNumeric: number,
    timestampSec: number,
    signers: Wallet[]
  ) {
    const signedPackages = signers.map((signer) =>
      buildSignedDataPackage(valueNumeric, timestampSec, signer)
    );
    return RedstonePayload.prepare(signedPackages, DATA_SERVICE_ID);
  }

  async function submitWithPayload(
    core: CLMSRMarketCore,
    submitter: any,
    marketId: number | bigint,
    payload: string
  ) {
    const baseData = SUBMIT_IFACE.encodeFunctionData("submitSettlement", [
      marketId,
    ]);
    const data = `${baseData}${payload.replace(/^0x/, "")}`;
    return submitter.sendTransaction({
      to: await core.getAddress(),
      data,
    });
  }

  it("reverts finalizeSettlement before T+10", async function () {
    const { core, marketId, settlementTime, alice, keeper } = await loadFixture(
      fixture
    );

    await time.increaseTo(settlementTime + 1);

    // submit once so candidate exists
    const priceTimestamp = settlementTime + 1;
    const payload = buildRedstonePayload(
      100_200, // tick encoded with 8 decimals inside payload
      priceTimestamp,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);

    await expect(core.connect(alice).finalizeSettlement(marketId, false))
      .to.be.revertedWithCustomError(core, "SettlementTooEarly")
      .withArgs(BigInt(settlementTime + SUBMIT_WINDOW), anyValue);
  });

  it("reverts finalizeSettlement after T+15", async function () {
    const { core, marketId, settlementTime, alice, keeper } = await loadFixture(
      fixture
    );

    await time.increaseTo(settlementTime + 1);

    const priceTimestamp = settlementTime + 2;
    const payload = buildRedstonePayload(
      100_200,
      priceTimestamp,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);

    await time.increaseTo(settlementTime + FINALIZE_DEADLINE + 1);

    await expect(core.connect(alice).finalizeSettlement(marketId, false))
      .to.be.revertedWithCustomError(core, "SettlementFinalizeWindowClosed")
      .withArgs(BigInt(settlementTime + FINALIZE_DEADLINE), anyValue);
  });

  it("reverts finalizeSettlement when no candidate was submitted", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );

    await time.increaseTo(settlementTime + SUBMIT_WINDOW + 1);

    await expect(
      core.connect(alice).finalizeSettlement(marketId, false)
    ).to.be.revertedWithCustomError(core, "SettlementOracleCandidateMissing");
  });

  it("confirms settlement: sets state, emits events, clears candidate", async function () {
    const { core, marketId, settlementTime, alice, keeper } = await loadFixture(
      fixture
    );

    const settlementValue = toSettlementValue(100250);
    const priceTimestamp = settlementTime + 3;

    await time.increaseTo(settlementTime + 1);

    const payload = buildRedstonePayload(
      100_250,
      priceTimestamp,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);

    await time.increaseTo(settlementTime + SUBMIT_WINDOW + 1);

    await expect(core.connect(alice).finalizeSettlement(marketId, false))
      .to.emit(core, "MarketSettled")
      .withArgs(marketId, settlementValue / 1_000_000n)
      .and.to.emit(core, "MarketSettlementValueSubmitted")
      .withArgs(marketId, settlementValue)
      .and.to.emit(core, "MarketSettlementFinalized")
      .withArgs(
        marketId,
        false,
        settlementValue,
        settlementValue / 1_000_000n,
        priceTimestamp,
        anyValue
      );

    const market = await core.getMarket(marketId);
    expect(market.settled).to.equal(true);
    expect(market.isActive).to.equal(false);
    expect(market.settlementValue).to.equal(settlementValue);
    expect(market.settlementTick).to.equal(settlementValue / 1_000_000n);

    const coreAddress = await core.getAddress();
    // candidate cleared (both slots zero)
    const baseSlot = mappingSlot(marketId);
    const valueSlot = await ethers.provider.getStorage(coreAddress, baseSlot);
    const tsSlot = await ethers.provider.getStorage(coreAddress, baseSlot + 1n);
    expect(ethers.toBigInt(valueSlot)).to.equal(0n);
    expect(ethers.toBigInt(tsSlot)).to.equal(0n);
  });

  it("fail finalize clears candidate but leaves market unsettled", async function () {
    const { core, marketId, settlementTime, alice, keeper } = await loadFixture(
      fixture
    );

    const settlementValue = toSettlementValue(100210);
    const priceTimestamp = settlementTime + 4;

    await time.increaseTo(settlementTime + 1);
    const payload = buildRedstonePayload(
      100_210,
      priceTimestamp,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);

    await time.increaseTo(settlementTime + SUBMIT_WINDOW + 2);

    await expect(core.connect(keeper).finalizeSettlement(marketId, true))
      .to.emit(core, "MarketSettlementFinalized")
      .withArgs(marketId, true, 0, 0, 0, anyValue);

    const market = await core.getMarket(marketId);
    expect(market.settled).to.equal(false);
    expect(market.isActive).to.equal(false); // stays as created state

    const coreAddress = await core.getAddress();
    const valueSlot = await ethers.provider.getStorage(
      coreAddress,
      mappingSlot(marketId)
    );
    expect(ethers.toBigInt(valueSlot)).to.equal(0n);
  });

  it("allows owner fallback settleMarket after oracle failure", async function () {
    const { core, marketId, settlementTime, alice, keeper } = await loadFixture(
      fixture
    );

    const oracleValue = toSettlementValue(100210);
    const priceTimestamp = settlementTime + 2;
    await time.increaseTo(settlementTime + 1);
    const payload = buildRedstonePayload(
      100_210,
      priceTimestamp,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);

    await time.increaseTo(settlementTime + SUBMIT_WINDOW + 1);
    await core.connect(keeper).finalizeSettlement(marketId, true);

    // manual settle by owner after failure
    const manualValue = toSettlementValue(100230);
    await expect(
      core.connect(keeper).settleMarket(marketId, manualValue)
    ).to.emit(core, "MarketSettled");

    const market = await core.getMarket(marketId);
    expect(market.settled).to.equal(true);
    expect(market.settlementValue).to.equal(manualValue);
  });

  it("requires owner to markFailed in finalize", async function () {
    const { core, marketId, settlementTime, alice, keeper } = await loadFixture(
      fixture
    );

    const settlementValue = toSettlementValue(100220);
    const priceTimestamp = settlementTime + 2;

    await time.increaseTo(settlementTime + 1);
    const payload = buildRedstonePayload(
      100_220,
      priceTimestamp,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);

    await time.increaseTo(settlementTime + SUBMIT_WINDOW + 1);

    await expect(
      core.connect(alice).finalizeSettlement(marketId, true)
    ).to.be.revertedWithCustomError(core, "UnauthorizedCaller");
  });

  it("reverts finalizeSettlement if candidate tick is out of bounds", async function () {
    const { core, marketId, settlementTime, keeper } = await loadFixture(
      fixture
    );

    await time.increaseTo(settlementTime + SUBMIT_WINDOW + 1);

    // Inject invalid candidate directly (tick below min)
    const badValue = toSettlementValue(MIN_TICK - 1000);
    await setCandidateRaw(core, marketId, badValue, settlementTime + 2);

    await expect(
      core.connect(keeper).finalizeSettlement(marketId, false)
    ).to.be.revertedWithCustomError(core, "InvalidTick");
  });
});

```


## test/integration/market/life-cycle.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  createActiveMarketFixture,
  coreFixture,
  settleMarketAtTick,
  toSettlementValue,
  setMarketActivation,
  advanceToClaimOpen,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";

describe(`${INTEGRATION_TAG} Market Lifecycle`, function () {
  const ALPHA = ethers.parseEther("1");
  const MARKET_DURATION = 7 * 24 * 60 * 60; // 7 days
  const SETTLEMENT_OFFSET = 3600;

  // ÌëúÏ§Ä Ìã± ÏãúÏä§ÌÖú ÌååÎùºÎØ∏ÌÑ∞
  const MIN_TICK = 100000;
  const MAX_TICK = 100990;
  const TICK_SPACING = 10;

  const LARGE_QUANTITY = ethers.parseUnits("0.1", 6);
  const MEDIUM_QUANTITY = ethers.parseUnits("0.05", 6);
  const LARGE_COST = ethers.parseUnits("10", 6);
  const MEDIUM_COST = ethers.parseUnits("5", 6);

  it("Should handle complete market lifecycle", async function () {
    const { core, keeper, marketId, startTime, endTime } = await loadFixture(
      createActiveMarketFixture
    );

    let market = await core.getMarket(marketId);
    expect(market.isActive).to.be.true;
    expect(market.settled).to.be.false;

    await time.increaseTo(startTime + 1000);
    market = await core.getMarket(marketId);
    expect(market.isActive).to.be.true;

    await time.increaseTo(endTime + SETTLEMENT_OFFSET + 1);
    const settlementTick = 100420;
    await settleMarketAtTick(core, keeper, marketId, settlementTick);

    market = await core.getMarket(marketId);
    expect(market.isActive).to.be.false;
    expect(market.settled).to.be.true;
    expect(market.settlementTick).to.equal(BigInt(settlementTick));
    expect(market.settlementValue).to.equal(toSettlementValue(settlementTick));
  });

  it("Should handle multiple markets in different states", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const baseStartTime = currentTime + 3600;

    const markets = [
      { start: baseStartTime, end: baseStartTime + 1000 },
      { start: baseStartTime + 2000, end: baseStartTime + 3000 },
      { start: baseStartTime + 4000, end: baseStartTime + 5000 },
    ];

    const marketIds: number[] = [];

    for (const { start, end } of markets) {
      const settlementTime = end + SETTLEMENT_OFFSET;
      const marketId = await core.connect(keeper).createMarket.staticCall(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        start,
        end,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );
      await core.connect(keeper).createMarket(
        MIN_TICK,
        MAX_TICK,
        TICK_SPACING,
        start,
        end,
        settlementTime,
        ALPHA,
        ethers.ZeroAddress
      );
      marketIds.push(Number(marketId));
    }

    for (const id of marketIds) {
      await setMarketActivation(core, keeper, id, true);
    }

    await time.increaseTo(markets[0].end + SETTLEMENT_OFFSET + 1);
    await settleMarketAtTick(core, keeper, marketIds[0], 100100);

    let market1 = await core.getMarket(marketIds[0]);
    let market2 = await core.getMarket(marketIds[1]);
    let market3 = await core.getMarket(marketIds[2]);

    expect(market1.settled).to.be.true;
    expect(market1.isActive).to.be.false;
    expect(market2.settled).to.be.false;
    expect(market2.isActive).to.be.true;
    expect(market3.settled).to.be.false;
    expect(market3.isActive).to.be.true;

    await time.increaseTo(markets[1].end + SETTLEMENT_OFFSET + 1);
    await settleMarketAtTick(core, keeper, marketIds[1], 100200);

    market2 = await core.getMarket(marketIds[1]);
    expect(market2.settled).to.be.true;
    expect(market2.isActive).to.be.false;

    market3 = await core.getMarket(marketIds[2]);
    expect(market3.settled).to.be.false;
    expect(market3.isActive).to.be.true;
  });

  it("Should handle complete position lifecycle", async function () {
    const { core, keeper, alice, mockPosition, marketId, endTime } =
      await loadFixture(createActiveMarketFixture);

    await core
      .connect(alice)
      .openPosition(marketId, 100450, 100550, LARGE_QUANTITY, LARGE_COST);

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    await core
      .connect(alice)
      .increasePosition(positionId, MEDIUM_QUANTITY, MEDIUM_COST);

    await expect(
      core.connect(alice).decreasePosition(positionId, MEDIUM_QUANTITY, 0)
    ).to.not.be.reverted;

    await core.connect(alice).closePosition(positionId, 0);
    expect(await mockPosition.balanceOf(alice.address)).to.equal(0);

    await time.increaseTo(endTime + SETTLEMENT_OFFSET + 1);
    await settleMarketAtTick(core, keeper, marketId, 100480);
  });

  it("Should handle position lifecycle with settlement", async function () {
    const { core, keeper, alice, mockPosition, marketId, endTime } =
      await loadFixture(createActiveMarketFixture);

    await core
      .connect(alice)
      .openPosition(marketId, 100450, 100550, MEDIUM_QUANTITY, MEDIUM_COST);

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    await time.increaseTo(endTime + SETTLEMENT_OFFSET + 1);
    await settleMarketAtTick(core, keeper, marketId, 100500);
    await advanceToClaimOpen(core, marketId);

    await expect(core.connect(alice).claimPayout(positionId)).to.emit(
      core,
      "PositionClaimed"
    );

    expect(await mockPosition.balanceOf(alice.address)).to.equal(0);
  });
});

```


## test/integration/market/market64.regression.spec.ts

```typescript
import fs from "fs";
import path from "path";

import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";

import {
  coreFixture,
  createMarketWithId,
  advanceToClaimOpen,
  setMarketActivation,
  toSettlementValue,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG, REPLAY_TAG } from "../../helpers/tags";

type TradeType = "OPEN" | "CLOSE" | "SETTLE";

interface TradeEntry {
  id: string;
  positionId: string;
  user: string;
  type: TradeType;
  quantity: string;
  costOrProceeds: string;
  lowerTick: string;
  upperTick: string;
}

interface SnapshotData {
  market: {
    minTick: string;
    maxTick: string;
    tickSpacing: string;
    liquidityParameter: string;
    settlementTick: string;
    numBins: string;
  };
  trades: TradeEntry[];
}

const SNAPSHOT_PATH = path.join(__dirname, "../../data/market64/snapshot.json");

const SNAPSHOT: SnapshotData = JSON.parse(
  fs.readFileSync(SNAPSHOT_PATH, "utf8")
);

const TRADES = SNAPSHOT.trades;
const COST_TOLERANCE = 1_000_000n; // 1 micro USDC
const ROOT_TOLERANCE_WAD = 1_000_000_000_000n; // 1 micro WAD tolerance for tree sums

const shouldRunReplay = process.env.RUN_REPLAY === "1";
const describeMaybe = shouldRunReplay ? describe : describe.skip;

describeMaybe(`${INTEGRATION_TAG} ${REPLAY_TAG} Market64 Regression`, function () {
  this.timeout(600000);
  this.slow(300000);

  it("keeps market loss within Œ± ln(n) bound after full replay", async function () {
    const { core, keeper, paymentToken, deployer } = await loadFixture(
      coreFixture
    );

    const allSigners = await ethers.getSigners();
    // Skip fixture-reserved signers (deployer, keeper, alice, bob, charlie)
    const traderPool = allSigners.slice(5);
    if (traderPool.length === 0) {
      throw new Error("Trader signer pool is empty");
    }

    const traderEntries = await Promise.all(
      traderPool.map(async (signer) => ({
        signer,
        address: await signer.getAddress(),
      }))
    );
    const addressToSigner = new Map(
      traderEntries.map((entry) => [entry.address, entry.signer])
    );

    const datasetPositionToAddress = new Map<string, string>();
    const datasetPositionToLocalId = new Map<string, bigint>();
    const fundedAddresses = new Set<string>();
    let assigningCursor = 0;

    const minTick = Number(SNAPSHOT.market.minTick);
    const maxTick = Number(SNAPSHOT.market.maxTick);
    const tickSpacing = Number(SNAPSHOT.market.tickSpacing);
    const alphaWad = BigInt(SNAPSHOT.market.liquidityParameter);
    const settlementTick = Number(SNAPSHOT.market.settlementTick);
    const numBins = Number(SNAPSHOT.market.numBins);

    if (!Number.isFinite(minTick) || !Number.isFinite(maxTick)) {
      throw new Error("Invalid tick configuration in snapshot");
    }
    if (!Number.isFinite(settlementTick)) {
      throw new Error("Invalid settlement tick in snapshot");
    }

    const startTime = (await time.latest()) + 180;
    const endTime = startTime + 24 * 60 * 60;
    const settlementTime = endTime + 3600;

    const marketId = await createMarketWithId(core, keeper, [
      minTick,
      maxTick,
      tickSpacing,
      startTime,
      endTime,
      settlementTime,
      alphaWad,
      ethers.ZeroAddress,
    ]);

    await setMarketActivation(core, keeper, marketId, true);
    await time.increaseTo(startTime + 1);

    const coreAddress = await core.getAddress();

    const ensureFunds = async (address: string) => {
      if (fundedAddresses.has(address)) {
        return;
      }
      const amount = ethers.parseUnits("100000000", 6); // 100M USDC buffer
      await paymentToken.connect(deployer).mint(address, amount);
      const signer = addressToSigner.get(address);
      if (!signer) {
        throw new Error(`No signer for address ${address}`);
      }
      await paymentToken
        .connect(signer)
        .approve(coreAddress, ethers.MaxUint256);
      fundedAddresses.add(address);
    };

    const assignSigner = (positionId: string) => {
      const existing = datasetPositionToAddress.get(positionId);
      if (existing) {
        const signer = addressToSigner.get(existing);
        if (!signer) {
          throw new Error(`Missing signer for assigned address ${existing}`);
        }
        return { address: existing, signer };
      }

      const entry = traderEntries[assigningCursor % traderEntries.length];
      assigningCursor += 1;
      datasetPositionToAddress.set(positionId, entry.address);
      return entry;
    };

    let totalCost = 0n;
    let totalCloseProceeds = 0n;
    let totalSettlementPayout = 0n;

    const openCostDeltas: bigint[] = [];
    const closeProceedsDeltas: bigint[] = [];
    let worstOpenRootDrop = 0n;
    let worstCloseRootIncrease = 0n;

    const consumeReceipt = async (tx: any) => {
      const response = await tx;
      const receipt = await response.wait();
      let openCost: bigint | null = null;
      let closeProceeds: bigint | null = null;
      let claimPayout: bigint | null = null;
      for (const log of receipt.logs) {
        try {
          const parsed = core.interface.parseLog(log);
          switch (parsed?.name) {
            case "PositionOpened": {
              const cost = parsed.args.cost as bigint;
              totalCost += cost;
               openCost = cost;
              break;
            }
            case "PositionClosed": {
              const proceeds = parsed.args.proceeds as bigint;
              totalCloseProceeds += proceeds;
               closeProceeds = proceeds;
              break;
            }
            case "PositionClaimed": {
              const payout = parsed.args.payout as bigint;
              totalSettlementPayout += payout;
               claimPayout = payout;
              break;
            }
            default:
              break;
          }
        } catch {
          // Ignore logs that are not from core contract
        }
      }
      return { receipt, openCost, closeProceeds, claimPayout };
    };

    const openAndCloseTrades: TradeEntry[] = [];
    const settleTrades: TradeEntry[] = [];
    for (const trade of TRADES) {
      if (trade.type === "SETTLE") {
        settleTrades.push(trade);
      } else {
        openAndCloseTrades.push(trade);
      }
    }

    for (const trade of openAndCloseTrades) {
      if (trade.type === "OPEN") {
        const { address, signer } = assignSigner(trade.positionId);
        await ensureFunds(address);

        const totalRangeBefore = await core.getRangeSum(
          marketId,
          minTick,
          maxTick
        );

        const quantity = BigInt(trade.quantity);
        const lowerTick = BigInt(trade.lowerTick);
        const upperTick = BigInt(trade.upperTick);
        const estimatedCost = await core
          .connect(signer)
          .calculateOpenCost(marketId, lowerTick, upperTick, quantity);
        const maxCost = estimatedCost + 1_000_000n; // add $1 buffer to avoid rounding drift

        const staticId = await core
          .connect(signer)
          .openPosition.staticCall(
            marketId,
            lowerTick,
            upperTick,
            quantity,
            maxCost
          );

        datasetPositionToLocalId.set(trade.positionId, staticId);

        const tx = await core
          .connect(signer)
          .openPosition(marketId, lowerTick, upperTick, quantity, maxCost);
        const { openCost } = await consumeReceipt(tx);

        if (openCost === null) {
          throw new Error(`Missing PositionOpened event for trade ${trade.id}`);
        }

        const totalRangeAfter = await core.getRangeSum(
          marketId,
          minTick,
          maxTick
        );

        if (totalRangeBefore > totalRangeAfter) {
          const drop = totalRangeBefore - totalRangeAfter;
          if (drop > worstOpenRootDrop) {
            worstOpenRootDrop = drop;
          }
        }

        expect(
          totalRangeAfter + ROOT_TOLERANCE_WAD,
          `Root sum should not decrease after OPEN trade ${trade.id}`
        ).to.be.gte(totalRangeBefore);

        const costDelta =
          openCost >= estimatedCost
            ? openCost - estimatedCost
            : estimatedCost - openCost;
        openCostDeltas.push(costDelta);
        expect(
          costDelta,
          `OPEN cost delta should stay within 1 micro USDC for trade ${trade.id}`
        ).to.be.lte(COST_TOLERANCE);
      } else if (trade.type === "CLOSE") {
        const localId = datasetPositionToLocalId.get(trade.positionId);
        if (localId === undefined) {
          throw new Error(`Missing local position id for ${trade.positionId}`);
        }
        const address = datasetPositionToAddress.get(trade.positionId);
        if (!address) {
          throw new Error(`Missing signer mapping for ${trade.positionId}`);
        }
        const signer = addressToSigner.get(address);
        if (!signer) {
          throw new Error(`Missing signer instance for address ${address}`);
        }

        const totalRangeBefore = await core.getRangeSum(
          marketId,
          minTick,
          maxTick
        );

        const estimatedProceeds = await core.calculateCloseProceeds(localId);

        const tx = await core.connect(signer).closePosition(localId, 0n);
        const { closeProceeds } = await consumeReceipt(tx);

        if (closeProceeds === null) {
          throw new Error(
            `Missing PositionClosed event for trade ${trade.id}`
          );
        }

        const totalRangeAfter = await core.getRangeSum(
          marketId,
          minTick,
          maxTick
        );

        if (totalRangeAfter > totalRangeBefore) {
          const increase = totalRangeAfter - totalRangeBefore;
          if (increase > worstCloseRootIncrease) {
            worstCloseRootIncrease = increase;
          }
        }

        expect(
          totalRangeAfter,
          `Root sum should not increase after CLOSE trade ${trade.id}`
        ).to.be.lte(totalRangeBefore + ROOT_TOLERANCE_WAD);

        const proceedsDelta =
          closeProceeds >= estimatedProceeds
            ? closeProceeds - estimatedProceeds
            : estimatedProceeds - closeProceeds;
        closeProceedsDeltas.push(proceedsDelta);
        expect(
          proceedsDelta,
          `CLOSE proceeds delta should stay within 1 micro USDC for trade ${trade.id}`
        ).to.be.lte(COST_TOLERANCE);

        datasetPositionToLocalId.delete(trade.positionId);
        datasetPositionToAddress.delete(trade.positionId);
      }
    }

    await time.increaseTo(settlementTime + 10);

    const settlementValue = toSettlementValue(settlementTick);
    await consumeReceipt(
      core.connect(keeper).settleMarket(marketId, settlementValue)
    );
    await advanceToClaimOpen(core, marketId);

    for (const trade of settleTrades) {
      const localId = datasetPositionToLocalId.get(trade.positionId);
      if (localId === undefined) {
        continue; // Some positions may have been closed before settlement
      }
      const address = datasetPositionToAddress.get(trade.positionId);
      if (!address) {
        throw new Error(`Missing signer mapping for settle ${trade.positionId}`);
      }
      const signer = addressToSigner.get(address);
      if (!signer) {
        throw new Error(`Missing signer instance for address ${address}`);
      }

      const tx = await core.connect(signer).claimPayout(localId);
      await consumeReceipt(tx);

      datasetPositionToLocalId.delete(trade.positionId);
      datasetPositionToAddress.delete(trade.positionId);
    }

    const bettingNetIncome = totalCost - totalCloseProceeds;
    const marketPnl = bettingNetIncome - totalSettlementPayout;

    const maxOpenDelta = openCostDeltas.reduce(
      (max, delta) => (delta > max ? delta : max),
      0n
    );
    const maxCloseDelta = closeProceedsDeltas.reduce(
      (max, delta) => (delta > max ? delta : max),
      0n
    );

    console.log(
      `Market64 replay summary ‚Üí max OPEN cost delta: ${maxOpenDelta} ŒºUSDC, max CLOSE proceeds delta: ${maxCloseDelta} ŒºUSDC`
    );
    console.log(
      `Market64 replay root sum deviations ‚Üí worst OPEN drop: ${worstOpenRootDrop} WAD, worst CLOSE increase: ${worstCloseRootIncrease} WAD`
    );

    const alphaFloat = Number(alphaWad / 10n ** 18n);
    const maxLossBoundMicro = BigInt(
      Math.floor(alphaFloat * Math.log(numBins) * 1_000_000)
    );

    expect(marketPnl, "market PnL should not exceed theoretical loss bound").to
      .be.gte(-maxLossBoundMicro);
  });
});

```


## test/integration/market/redstone-wrapper.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import { DataPackage, NumericDataPoint, RedstonePayload } from "@redstone-finance/protocol";
import {
  coreFixture,
  createMarketWithConfig,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";
import type { CLMSRMarketCore } from "../../../typechain-types";
import type { Wallet } from "ethers";

const MIN_TICK = 100000;
const MAX_TICK = 100500;
const DATA_FEED_ID = "BTC";
const FEED_DECIMALS = 8;
const AUTHORISED_SIGNER_KEYS = [
  "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
  "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
  "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a",
];
const authorisedWallets: Wallet[] = AUTHORISED_SIGNER_KEYS.map(
  (key) => new ethers.Wallet(key)
);
const ORACLE_STATE_SLOT = 9; // settlementOracleState mapping slot index
const SUBMIT_IFACE = new ethers.Interface([
  "function submitSettlement(uint256 marketId)",
]);

function mappingSlot(marketId: number | bigint) {
  const abi = ethers.AbiCoder.defaultAbiCoder();
  return BigInt(
    ethers.keccak256(
      abi.encode(["uint256", "uint256"], [marketId, ORACLE_STATE_SLOT])
    )
  );
}

async function readCandidateState(
  coreAddress: string,
  marketId: number | bigint
) {
  const provider = ethers.provider;
  const baseSlot = mappingSlot(marketId);

  const rawValue = await provider.getStorage(coreAddress, baseSlot);
  const rawTimestamp = await provider.getStorage(coreAddress, baseSlot + 1n);

  return {
    candidateValue: ethers.toBigInt(rawValue),
    candidatePriceTimestamp: Number(rawTimestamp),
  };
}

function buildPayload(
  valueNumeric: number,
  timestampSec: number,
  signers: Wallet[]
) {
  const signedPackages = signers.map((signer) => {
    const dataPoint = new NumericDataPoint({
      dataFeedId: DATA_FEED_ID,
      value: valueNumeric,
      decimals: FEED_DECIMALS,
    });
    const pkg = new DataPackage(
      [dataPoint],
      timestampSec * 1000,
      DATA_FEED_ID
    );
    return pkg.sign(signer.privateKey);
  });
  return RedstonePayload.prepare(signedPackages, "redstone-dev-test");
}

describe(`${INTEGRATION_TAG} Redstone wrapper end-to-end submitSettlement`, function () {
  async function fixture() {
    const contracts = await coreFixture();
    const { core, keeper } = contracts;
    const coreTyped = core as unknown as CLMSRMarketCore;

    const now = await time.latest();
    const startTime = now - 400;
    const endTime = now - 100;
    const settlementTime = now + 100;

    const marketId = await createMarketWithConfig(coreTyped, keeper, {
      minTick: MIN_TICK,
      maxTick: MAX_TICK,
      tickSpacing: 10,
      startTime,
      endTime,
      settlementTime,
      liquidityParameter: ethers.parseEther("1"),
      feePolicy: ethers.ZeroAddress,
    });

    return { ...contracts, core: coreTyped, marketId, settlementTime };
  }

  it("attaches signed payload and stores candidate", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );
    const coreAddr = await core.getAddress();

    // Move into submit window
    await time.increaseTo(settlementTime + 2);
    const priceTimestamp = settlementTime + 2;

    // Build signed payload from authorised wallets
    const payload = buildPayload(
      100_123,
      priceTimestamp,
      authorisedWallets
    );

    const baseData = SUBMIT_IFACE.encodeFunctionData("submitSettlement", [
      marketId,
    ]);
    const txData = `${baseData}${payload.replace(/^0x/, "")}`;
    await alice.sendTransaction({
      to: coreAddr,
      data: txData,
    });

    const candidate = await readCandidateState(coreAddr, marketId);
    expect(candidate.candidatePriceTimestamp).to.equal(priceTimestamp);
    expect(candidate.candidateValue).to.equal(100_123_000_000n); // 8 decimals ‚Üí scaled to 1e6
  });
});

```


## test/integration/market/settle.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  createActiveMarketFixture,
  coreFixture,
  settleMarketAtTick,
  toSettlementValue,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";

describe(`${INTEGRATION_TAG} Market Settlement`, function () {
  const ALPHA = ethers.parseEther("1");
  const MARKET_DURATION = 7 * 24 * 60 * 60; // 7 days

  // ÌëúÏ§Ä Ìã± ÏãúÏä§ÌÖú ÌååÎùºÎØ∏ÌÑ∞
  const MIN_TICK = 100000;
  const MAX_TICK = 100990;
  const TICK_SPACING = 10;

  it("Should settle market successfully", async function () {
    const { core, keeper, marketId, endTime } = await loadFixture(
      createActiveMarketFixture
    );
    const settlementTick = 100490;

    await time.increaseTo(endTime + 3601);

    await expect(settleMarketAtTick(core, keeper, marketId, settlementTick))
      .to.emit(core, "MarketSettled")
      .withArgs(marketId, BigInt(settlementTick));

    const market = await core.getMarket(marketId);
    expect(market.settled).to.be.true;
    expect(market.settlementTick).to.equal(BigInt(settlementTick));
    expect(market.settlementValue).to.equal(toSettlementValue(settlementTick));
    expect(market.isActive).to.be.false;
  });

  it("Should prevent double settlement", async function () {
    const { core, keeper, marketId, endTime } = await loadFixture(
      createActiveMarketFixture
    );

    await time.increaseTo(endTime + 3601);

    await settleMarketAtTick(core, keeper, marketId, 100490);

    await expect(settleMarketAtTick(core, keeper, marketId, 100500)).to.be
      .revertedWithCustomError(core, "MarketAlreadySettled");
  });

  it("Should validate settlement tick bounds", async function () {
    const { core, keeper, marketId, endTime } = await loadFixture(
      createActiveMarketFixture
    );

    await time.increaseTo(endTime + 3601);

    await expect(
      core
        .connect(keeper)
        .settleMarket(marketId, toSettlementValue(200000))
    ).to.be.revertedWithCustomError(core, "InvalidTick");

    await expect(
      core
        .connect(keeper)
        .settleMarket(marketId, toSettlementValue(99000))
    ).to.be.revertedWithCustomError(core, "InvalidTick");
  });

  it("Should settle with edge ticks", async function () {
    const { core, keeper, endTime } = await loadFixture(createActiveMarketFixture);

    const startTime = await time.latest();
    const newEndTime = startTime + MARKET_DURATION;
    const settlementTime = newEndTime + 3600;

    const marketId1 = await core.connect(keeper).createMarket.staticCall(
      MIN_TICK,
      MAX_TICK,
      TICK_SPACING,
      startTime,
      newEndTime,
      settlementTime,
      ALPHA,
      ethers.ZeroAddress
    );

    await core.connect(keeper).createMarket(
      MIN_TICK,
      MAX_TICK,
      TICK_SPACING,
      startTime,
      newEndTime,
      settlementTime,
      ALPHA,
      ethers.ZeroAddress
    );

    await time.increaseTo(settlementTime + 1);
    await settleMarketAtTick(core, keeper, Number(marketId1), MIN_TICK);
    let market = await core.getMarket(Number(marketId1));
    expect(market.settlementTick).to.equal(BigInt(MIN_TICK));

    const marketId2 = await core.connect(keeper).createMarket.staticCall(
      MIN_TICK,
      MAX_TICK,
      TICK_SPACING,
      startTime + 10,
      newEndTime + 10,
      settlementTime + 10,
      ALPHA,
      ethers.ZeroAddress
    );

    await core.connect(keeper).createMarket(
      MIN_TICK,
      MAX_TICK,
      TICK_SPACING,
      startTime + 10,
      newEndTime + 10,
      settlementTime + 10,
      ALPHA,
      ethers.ZeroAddress
    );

    await time.increaseTo(settlementTime + 11);
    await settleMarketAtTick(core, keeper, Number(marketId2), MAX_TICK);
    market = await core.getMarket(Number(marketId2));
    expect(market.settlementTick).to.equal(BigInt(MAX_TICK));
  });

  it("Should prevent settlement of non-existent market", async function () {
    const { core, keeper } = await loadFixture(createActiveMarketFixture);

    await expect(
      core.connect(keeper).settleMarket(999, toSettlementValue(100490))
    ).to.be.revertedWithCustomError(core, "MarketNotFound");
  });

  it("Should only allow manager to settle markets", async function () {
    const { core, alice, bob, keeper, marketId, endTime } = await loadFixture(
      createActiveMarketFixture
    );

    await time.increaseTo(endTime + 3601);

    await expect(
      core.connect(alice).settleMarket(marketId, toSettlementValue(100490))
    )
      .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
      .withArgs(alice.address);

    await expect(
      core.connect(bob).settleMarket(marketId, toSettlementValue(100490))
    )
      .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
      .withArgs(bob.address);

    await expect(
      core.connect(keeper).settleMarket(marketId, toSettlementValue(100490))
    ).to.not.be.reverted;
  });

  describe("Market Reopen", function () {
    it("Should reopen settled market successfully", async function () {
      const { core, keeper, marketId, endTime } = await loadFixture(
        createActiveMarketFixture
      );

      const settlementValue = toSettlementValue(100490);

      await time.increaseTo(endTime + 3601);
      await core.connect(keeper).settleMarket(marketId, settlementValue);

      let market = await core.getMarket(marketId);
      expect(market.settled).to.be.true;
      expect(market.isActive).to.be.false;

      await expect(core.connect(keeper).reopenMarket(marketId))
        .to.emit(core, "MarketReopened")
        .withArgs(marketId);

      market = await core.getMarket(marketId);
      expect(market.settled).to.be.false;
      expect(market.isActive).to.be.true;
      expect(market.settlementValue).to.equal(BigInt(0));
      expect(market.settlementTick).to.equal(BigInt(0));
    });

    it("Should prevent reopening unsettled market", async function () {
      const { core, keeper, marketId } = await loadFixture(
        createActiveMarketFixture
      );

      await expect(
        core.connect(keeper).reopenMarket(marketId)
      ).to.be.revertedWithCustomError(core, "MarketNotSettled");
    });

    it("Should only allow owner to reopen markets", async function () {
      const { core, keeper, alice, bob, marketId, endTime } = await loadFixture(
        createActiveMarketFixture
      );

      const settlementValue = toSettlementValue(100490);

      await time.increaseTo(endTime + 3601);
      await core.connect(keeper).settleMarket(marketId, settlementValue);

      await expect(
        core.connect(alice).reopenMarket(marketId)
      )
        .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
        .withArgs(alice.address);

      await expect(
        core.connect(bob).reopenMarket(marketId)
      )
        .to.be.revertedWithCustomError(core, "OwnableUnauthorizedAccount")
        .withArgs(bob.address);
    });

    it("Should preserve market timing after reopen", async function () {
      const { core, keeper, marketId, endTime } = await loadFixture(
        createActiveMarketFixture
      );

      const originalMarket = await core.getMarket(marketId);
      const originalStartTime = originalMarket.startTimestamp;
      const originalEndTime = originalMarket.endTimestamp;

      const settlementValue = toSettlementValue(100490);

      await time.increaseTo(endTime + 3601);
      await core.connect(keeper).settleMarket(marketId, settlementValue);
      await core.connect(keeper).reopenMarket(marketId);

      const reopenedMarket = await core.getMarket(marketId);
      expect(reopenedMarket.startTimestamp).to.equal(originalStartTime);
      expect(reopenedMarket.endTimestamp).to.equal(originalEndTime);
    });
  });
});

```


## test/integration/market/settlement-oracle.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  createMarketWithConfig,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";
import type { CLMSRMarketCore } from "../../../typechain-types";
import {
  DataPackage,
  NumericDataPoint,
  RedstonePayload,
} from "@redstone-finance/protocol";
import type { Wallet } from "ethers";

const MIN_TICK = 100000;
const MAX_TICK = 100500;
const DATA_FEED_ID = "BTC";
const DATA_SERVICE_ID = "redstone-primary-prod";
const FEED_DECIMALS = 8;
const UNIQUE_SIGNERS_THRESHOLD = 3;
const PRICE_NUMERIC = 100_250; // will be encoded with 8 decimals -> raw 10_025_000_000_000, maps to tick ~100250
const SUBMIT_IFACE = new ethers.Interface([
  "function submitSettlement(uint256 marketId)",
]);
const ORACLE_STATE_SLOT = 9; // settlementOracleState mapping slot index

const AUTHORISED_SIGNER_KEYS = [
  "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80", // hardhat default #0
  "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d", // hardhat default #1
  "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a", // hardhat default #2
];
const UNAUTHORISED_SIGNER_KEY =
  "0x8b3a350cf5c34c9194ca9f2aeabc9b3a2b0a3f3f127f6ed7d231a1e6e84d27b3"; // arbitrary test key

const authorisedWallets = AUTHORISED_SIGNER_KEYS.map(
  (key) => new ethers.Wallet(key)
);
const unauthorisedWallet = new ethers.Wallet(UNAUTHORISED_SIGNER_KEY);

function mappingSlot(marketId: number | bigint) {
  const abi = ethers.AbiCoder.defaultAbiCoder();
  return BigInt(
    ethers.keccak256(
      abi.encode(["uint256", "uint256"], [marketId, ORACLE_STATE_SLOT])
    )
  );
}

async function readCandidateState(
  coreAddress: string,
  marketId: number | bigint
) {
  const provider = ethers.provider;
  const baseSlot = mappingSlot(marketId);

  const rawValue = await provider.getStorage(coreAddress, baseSlot);
  const rawTimestamp = await provider.getStorage(coreAddress, baseSlot + 1n);

  return {
    candidateValue: ethers.toBigInt(rawValue),
    candidatePriceTimestamp: Number(rawTimestamp),
  };
}

function buildSignedDataPackage(
  valueWithDecimals: number,
  timestampSec: number,
  signer: Wallet
) {
  const dataPoint = new NumericDataPoint({
    dataFeedId: DATA_FEED_ID,
    value: valueWithDecimals,
    decimals: FEED_DECIMALS,
  });
  const pkg = new DataPackage(
    [dataPoint],
    timestampSec * 1000, // protocol uses ms
    DATA_FEED_ID
  );
  return pkg.sign(signer.privateKey);
}

function buildRedstonePayload(
  valueWithDecimals: number,
  timestampSec: number,
  signers: Wallet[]
) {
  const signedPackages = signers.map((signer) =>
    buildSignedDataPackage(valueWithDecimals, timestampSec, signer)
  );
  return RedstonePayload.prepare(signedPackages, DATA_SERVICE_ID);
}

async function submitWithPayload(
  core: CLMSRMarketCore,
  submitter: any,
  marketId: number | bigint,
  payload?: string
) {
  const baseData = SUBMIT_IFACE.encodeFunctionData("submitSettlement", [
    marketId,
  ]);
  const data =
    payload === undefined
      ? baseData
      : `${baseData}${payload.replace(/^0x/, "")}`;
  return submitter.sendTransaction({
    to: await core.getAddress(),
    data,
  });
}

describe(`${INTEGRATION_TAG} Settlement oracle submission (Redstone pull)`, function () {
  async function fixture() {
    const contracts = await coreFixture();
    const { core, keeper } = contracts;
    const coreTyped = core as unknown as CLMSRMarketCore;

    const now = await time.latest();
    const startTime = now - 400;
    const endTime = now - 100;
    const settlementTime = now + 100;

    const marketId = await createMarketWithConfig(core, keeper, {
      minTick: MIN_TICK,
      maxTick: MAX_TICK,
      tickSpacing: 10,
      startTime,
      endTime,
      settlementTime,
      liquidityParameter: ethers.parseEther("1"),
      feePolicy: ethers.ZeroAddress,
    });

    return { ...contracts, core: coreTyped, marketId, settlementTime };
  }

  it("reverts when calldata has no Redstone payload", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );

    await time.increaseTo(settlementTime + 1);

    await expect(
      submitWithPayload(core, alice, marketId)
    ).to.be.revertedWithCustomError(core, "CalldataMustHaveValidPayload");
  });

  it("reverts when payload is signed only by unauthorised signers", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );

    await time.increaseTo(settlementTime + 1);
    const payload = buildRedstonePayload(
      PRICE_NUMERIC,
      settlementTime + 2,
      [unauthorisedWallet]
    );

    await expect(
      submitWithPayload(core, alice, marketId, payload)
    )
      .to.be.revertedWithCustomError(core, "SignerNotAuthorised")
      .withArgs(unauthorisedWallet.address);
  });

  it("reverts when unique signers threshold is not met", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );

    await time.increaseTo(settlementTime + 1);
    const payload = buildRedstonePayload(
      PRICE_NUMERIC,
      settlementTime + 3,
      [authorisedWallets[0]]
    );

    await expect(
      submitWithPayload(core, alice, marketId, payload)
    )
      .to.be.revertedWithCustomError(core, "InsufficientNumberOfUniqueSigners")
      .withArgs(1, UNIQUE_SIGNERS_THRESHOLD);
  });

  it("reverts when oracle timestamp is too old", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );

    // Move near settlement; choose a timestamp far in the past (>3m)
    await time.increaseTo(settlementTime + 5);
    const staleTimestamp = settlementTime - 600; // 10 minutes earlier
    const payload = buildRedstonePayload(
      PRICE_NUMERIC,
      staleTimestamp,
      authorisedWallets
    );

    await expect(
      submitWithPayload(core, alice, marketId, payload)
    ).to.be.reverted;
  });

  it("stores scaled settlementValue and tick within bounds", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );
    const coreAddr = await core.getAddress();

    await time.increaseTo(settlementTime + 2);
    const priceTs = settlementTime + 1;
    const payload = buildRedstonePayload(
      PRICE_NUMERIC,
      priceTs,
      authorisedWallets
    );

    await submitWithPayload(core, alice, marketId, payload);

    const candidate = await readCandidateState(coreAddr, marketId);
    expect(candidate.candidatePriceTimestamp).to.equal(priceTs);
    // 8 decimals -> settlementValue scaled down by 1e2 (REDSTONE_FEED_DECIMALS - 6)
    expect(candidate.candidateValue).to.equal(100_250_000_000n);
  });

  it("reverts when scaled tick is out of bounds", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );

    await time.increaseTo(settlementTime + 3);
    const tooHighPrice = 100_800; // tick ~100800 > maxTick
    const payload = buildRedstonePayload(
      tooHighPrice,
      settlementTime + 2,
      authorisedWallets
    );

    await expect(
      submitWithPayload(core, alice, marketId, payload)
    ).to.be.revertedWithCustomError(core, "InvalidTick");
  });

  it("selects candidate closer to settlement timestamp (ties prefer earlier)", async function () {
    const { core, marketId, settlementTime, alice } = await loadFixture(
      fixture
    );
    const coreAddr = await core.getAddress();

    await time.increaseTo(settlementTime + 5);
    const farTs = settlementTime + 120; // +120s
    const closeTs = settlementTime + 10; // +10s (closer)

    const payloadFar = buildRedstonePayload(
      PRICE_NUMERIC,
      farTs,
      authorisedWallets
    );
    // move near far timestamp to satisfy Redstone future-tolerance
    await time.increaseTo(farTs + 1);
    await submitWithPayload(core, alice, marketId, payloadFar);

    const payloadClose = buildRedstonePayload(
      PRICE_NUMERIC,
      closeTs,
      authorisedWallets
    );
    await time.increase(1); // keep monotonic, still within default timestamp tolerance
    await submitWithPayload(core, alice, marketId, payloadClose);

    const candidate = await readCandidateState(coreAddr, marketId);
    expect(candidate.candidatePriceTimestamp).to.equal(closeTs);
  });
});

```


## test/integration/market/settlement-pause.spec.ts

```typescript
/// <reference types="@nomicfoundation/hardhat-chai-matchers" />
/// <reference types="@nomicfoundation/hardhat-ethers" />
/// <reference types="@nomicfoundation/hardhat-network-helpers" />

import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  createMarketWithConfig,
  toSettlementValue,
  advanceToClaimOpen,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";
import type { CLMSRMarketCore } from "../../../typechain-types";
import {
  DataPackage,
  NumericDataPoint,
  RedstonePayload,
} from "@redstone-finance/protocol";
import type { Wallet } from "ethers";

const DATA_FEED_ID = "BTC";
const DATA_SERVICE_ID = "redstone-primary-prod";
const FEED_DECIMALS = 8;
const AUTHORISED_SIGNER_KEYS = [
  "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
  "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
  "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a",
];
const authorisedWallets = AUTHORISED_SIGNER_KEYS.map(
  (key) => new ethers.Wallet(key)
);
const SUBMIT_IFACE = new ethers.Interface([
  "function submitSettlement(uint256 marketId)",
]);

describe(`${INTEGRATION_TAG} Settlement pause behavior`, function () {
  async function fixture() {
    const contracts = await coreFixture();
    const { core, keeper, alice } = contracts;
    const coreTyped = core as unknown as CLMSRMarketCore;

    const now = await time.latest();
    const startTime = now - 1000;
    const endTime = now - 500;
    const settlementTime = now + 200;

    const marketId = await createMarketWithConfig(coreTyped, keeper, {
      minTick: 100000,
      maxTick: 100500,
      tickSpacing: 10,
      startTime,
      endTime,
      settlementTime,
      liquidityParameter: ethers.parseEther("1"),
      feePolicy: ethers.ZeroAddress,
    });

    return { ...contracts, core: coreTyped, marketId, settlementTime, keeper, alice };
  }

  function buildSignedDataPackage(
    valueNumeric: number,
    timestampSec: number,
    signer: Wallet
  ) {
    const dataPoint = new NumericDataPoint({
      dataFeedId: DATA_FEED_ID,
      value: valueNumeric,
      decimals: FEED_DECIMALS,
    });
    const pkg = new DataPackage(
      [dataPoint],
      timestampSec * 1000,
      DATA_FEED_ID
    );
    return pkg.sign(signer.privateKey);
  }

  function buildRedstonePayload(
    valueNumeric: number,
    timestampSec: number,
    signers: Wallet[]
  ) {
    const signedPackages = signers.map((signer) =>
      buildSignedDataPackage(valueNumeric, timestampSec, signer)
    );
    return RedstonePayload.prepare(signedPackages, DATA_SERVICE_ID);
  }

  async function submitWithPayload(
    core: CLMSRMarketCore,
    submitter: any,
    marketId: number | bigint,
    payload: string
  ) {
    const baseData = SUBMIT_IFACE.encodeFunctionData("submitSettlement", [
      marketId,
    ]);
    const data = `${baseData}${payload.replace(/^0x/, "")}`;
    return submitter.sendTransaction({
      to: await core.getAddress(),
      data,
    });
  }

  it("submitSettlement is blocked when paused", async function () {
    const { core, marketId, settlementTime, keeper, alice } =
      await loadFixture(fixture);

    await core.connect(keeper).pause("pause for test");

    await time.increaseTo(settlementTime + 1);

    await expect(
      core
        .connect(alice)
        .submitSettlement(marketId)
    ).to.be.revertedWithCustomError(core, "EnforcedPause");
  });

  it("finalizeSettlement is blocked when paused", async function () {
    const { core, marketId, settlementTime, keeper, alice } =
      await loadFixture(fixture);

    await time.increaseTo(settlementTime + 1);
    const payload = buildRedstonePayload(
      100_200,
      settlementTime + 2,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);

    await core.connect(keeper).pause("pause for test");
    await time.increaseTo(settlementTime + 11 * 60); // within finalize window

    await expect(
      core.connect(alice).finalizeSettlement(marketId, false)
    ).to.be.revertedWithCustomError(core, "EnforcedPause");
  });

  it("claimPayout is blocked when paused", async function () {
    const { core, marketId, settlementTime, keeper, alice } =
      await loadFixture(fixture);

    await time.increaseTo(settlementTime + 1);
    const payload = buildRedstonePayload(
      100_200,
      settlementTime + 2,
      authorisedWallets
    );
    await submitWithPayload(core, alice, marketId, payload);
    await time.increaseTo(settlementTime + 11 * 60);
    await core.connect(alice).finalizeSettlement(marketId, false);

    await advanceToClaimOpen(core, marketId);
    await core.connect(keeper).pause("pause for test");

    await expect(core.connect(alice).claimPayout(1)).to.be.revertedWithCustomError(
      core,
      "EnforcedPause"
    );
  });
});

```


## test/integration/position/core_position.spec.ts

```typescript
import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";

import { activePositionMarketFixture } from "../../helpers/fixtures/position";
import { COMPONENT_TAG } from "../../helpers/tags";

describe(`${COMPONENT_TAG} Core ‚Üî Position Integration`, function () {
  this.timeout(120000);
  this.slow(60000);
  const POSITION_QUANTITY = ethers.parseUnits("10", 6);
  const POSITION_MAX_COST = ethers.parseUnits("1000", 6);
  const INCREASE_COST_BUFFER = ethers.parseUnits("500", 6);
  const COST_BUFFER = ethers.parseUnits("100", 6);

  async function quoteIncreaseCost(
    coreContract: any,
    positionId: bigint,
    amount: bigint
  ) {
    const quote = await coreContract.calculateIncreaseCost(positionId, amount);
    return quote + COST_BUFFER;
  }

  describe("Position Minting via Core", function () {
    it("should mint position when Core.openPosition is called", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      // Check initial state
      expect(await position.balanceOf(alice.address)).to.equal(0);

      // Open position through Core
      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      await expect(
        core
          .connect(alice)
          .openPosition(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          )
      )
        .to.emit(position, "PositionMinted")
        .withArgs(
          positionId,
          alice.address,
          marketId,
          100100,
          100200,
          params.quantity
        )
        .and.to.emit(core, "PositionOpened");

      // Verify position was minted
      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.ownerOf(positionId)).to.equal(alice.address);

      // Verify position data
      const positionData = await position.getPosition(positionId);
      expect(positionData.marketId).to.equal(marketId);
      expect(positionData.lowerTick).to.equal(100100);
      expect(positionData.upperTick).to.equal(100200);
      expect(positionData.quantity).to.equal(params.quantity);
    });

    it("should handle multiple position mints correctly", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Alice opens first position
      await core
        .connect(alice)
        .openPosition(
          marketId,
          100100,
          100200,
          POSITION_QUANTITY,
          POSITION_MAX_COST
        );

      // Bob opens second position
      await core
        .connect(bob)
        .openPosition(
          marketId,
          100300,
          100400,
          POSITION_QUANTITY,
          POSITION_MAX_COST
        );

      // Verify balances
      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.balanceOf(bob.address)).to.equal(1);

      // Verify ownership
      expect(await position.ownerOf(1)).to.equal(alice.address);
      expect(await position.ownerOf(2)).to.equal(bob.address);

      // Verify balances remain consistent
      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.balanceOf(bob.address)).to.equal(1);
    });

    it("should revert position mint when Core authorization fails", async function () {
      const { position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Try to mint directly (not through Core)
      await expect(
        position
          .connect(alice)
          .mintPosition(
            alice.address,
            marketId,
            100100,
            100200,
            ethers.parseUnits("1", 6)
          )
      ).to.be.revertedWithCustomError(position, "UnauthorizedCaller");
    });

    it("should handle position mint with edge case parameters", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            100500,
            100500,
            POSITION_QUANTITY,
            POSITION_MAX_COST
          )
      ).to.be.revertedWithCustomError(core, "InvalidTickRange");
    });
  });

  describe("Position Updates via Core", function () {
    it("should update position quantity when Core.increasePosition is called", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open initial position
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      const initialData = await position.getPosition(positionId);
      const initialQuantity = initialData.quantity;

      // Increase position
      const increaseAmount = ethers.parseUnits("5", 6);
      const increaseCost = await quoteIncreaseCost(
        core,
        positionId,
        increaseAmount
      );
      await expect(
        core
          .connect(alice)
          .increasePosition(
            positionId,
            increaseAmount,
            increaseCost
          )
      )
        .to.emit(position, "PositionUpdated")
        .withArgs(
          positionId,
          initialQuantity,
          initialQuantity + increaseAmount
        );

      // Verify updated quantity
      const updatedData = await position.getPosition(positionId);
      expect(updatedData.quantity).to.equal(initialQuantity + increaseAmount);
    });

    it("should update position quantity when Core.decreasePosition is called", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open initial position
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      const initialData = await position.getPosition(positionId);
      const initialQuantity = initialData.quantity;

      // Decrease position
      const decreaseAmount = ethers.parseUnits("0.5", 6);
      await expect(
        core.connect(alice).decreasePosition(positionId, decreaseAmount, 0)
      )
        .to.emit(position, "PositionUpdated")
        .withArgs(
          positionId,
          initialQuantity,
          initialQuantity - decreaseAmount
        );

      // Verify updated quantity
      const updatedData = await position.getPosition(positionId);
      expect(updatedData.quantity).to.equal(initialQuantity - decreaseAmount);
    });

    it("should revert position update when called directly", async function () {
      const { position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      await expect(
        position
          .connect(alice)
          .updateQuantity(1, POSITION_QUANTITY)
      ).to.be.revertedWithCustomError(position, "UnauthorizedCaller");
    });

    it("should handle multiple sequential updates", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open initial position
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      let currentData = await position.getPosition(positionId);
      let currentQuantity = currentData.quantity;

      // Multiple increases and decreases
      const operations = [
        async () => {
          const amount = ethers.parseUnits("5", 6);
          const cost = await quoteIncreaseCost(core, positionId, amount);
          await core
            .connect(alice)
            .increasePosition(positionId, amount, cost);
          currentQuantity += amount;
        },
        async () => {
          const amount = ethers.parseUnits("2", 6);
          await core
            .connect(alice)
            .decreasePosition(positionId, amount, 0);
          currentQuantity -= amount;
        },
        async () => {
          const amount = ethers.parseUnits("6", 6);
          const cost = await quoteIncreaseCost(core, positionId, amount);
          await core
            .connect(alice)
            .increasePosition(positionId, amount, cost);
          currentQuantity += amount;
        },
        async () => {
          const amount = ethers.parseUnits("3", 6);
          await core
            .connect(alice)
            .decreasePosition(positionId, amount, 0);
          currentQuantity -= amount;
        },
      ];

      for (const op of operations) {
        await op();
        const updatedData = await position.getPosition(positionId);
        expect(updatedData.quantity).to.equal(currentQuantity);
      }
    });
  });

  describe("Position Burning via Core", function () {
    it("should burn position when Core.closePosition is called", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open position
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      // Verify position exists
      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.ownerOf(positionId)).to.equal(alice.address);

      // Close position
      await expect(core.connect(alice).closePosition(positionId, 0))
        .to.emit(position, "PositionBurned")
        .withArgs(positionId, alice.address)
        .and.to.emit(core, "PositionClosed");

      // Verify position is burned
      expect(await position.balanceOf(alice.address)).to.equal(0);
      await expect(position.ownerOf(positionId)).to.be.revertedWithCustomError(
        position,
        "ERC721NonexistentToken"
      );
      await expect(
        position.getPosition(positionId)
      ).to.be.revertedWithCustomError(position, "PositionNotFound");
    });

    it("should burn position when decreased to zero", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open position
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      const positionData = await position.getPosition(positionId);

      // Decrease to zero (should burn)
      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, positionData.quantity, 0)
      )
        .to.emit(position, "PositionBurned")
        .withArgs(positionId, alice.address);

      // Verify position is burned
      expect(await position.balanceOf(alice.address)).to.equal(0);
      await expect(
        position.getPosition(positionId)
      ).to.be.revertedWithCustomError(position, "PositionNotFound");
    });

    it("should revert position burn when called directly", async function () {
      const { position, alice } = await loadFixture(
        activePositionMarketFixture
      );

      await expect(
        position.connect(alice).burn(1)
      ).to.be.revertedWithCustomError(position, "UnauthorizedCaller");
    });

    it("should handle burning multiple positions", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open multiple positions
      const positions = [];
      for (let i = 0; i < 3; i++) {
        const params = {
          marketId,
          lowerTick: 100100 + i * 100,
          upperTick: 100200 + i * 100,
          quantity: POSITION_QUANTITY,
          maxCost: POSITION_MAX_COST,
        };

        const positionId = await core
          .connect(alice)
          .openPosition.staticCall(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          );
        await core
          .connect(alice)
          .openPosition(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          );
        positions.push(positionId);
      }

      expect(await position.balanceOf(alice.address)).to.equal(3);

      // Close all positions
      for (const positionId of positions) {
        await core.connect(alice).closePosition(positionId, 0);
      }

      expect(await position.balanceOf(alice.address)).to.equal(0);

      // Verify all positions are burned
      for (const positionId of positions) {
        await expect(
          position.getPosition(positionId)
        ).to.be.revertedWithCustomError(position, "PositionNotFound");
      }
    });
  });

  describe("Position State Consistency", function () {
    it("should maintain consistent state across Core operations", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open position
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      // Verify initial state
      let positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(params.quantity);

      // Increase position
      const increaseAmount = ethers.parseUnits("2", 6);
      await core
        .connect(alice)
        .increasePosition(positionId, increaseAmount, INCREASE_COST_BUFFER);

      positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(params.quantity + increaseAmount);

      // Decrease position
      const decreaseAmount = ethers.parseUnits("4", 6);
      await core
        .connect(alice)
        .decreasePosition(positionId, decreaseAmount, 0);

      positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(
        params.quantity + increaseAmount - decreaseAmount
      );

      // Close position
      await core.connect(alice).closePosition(positionId, 0);

      // Verify position is completely removed
      await expect(
        position.getPosition(positionId)
      ).to.be.revertedWithCustomError(position, "PositionNotFound");
    });

    it("should handle Core operations with different users", async function () {
      const { core, position, alice, bob, charlie, marketId } =
        await loadFixture(activePositionMarketFixture);

      const users = [alice, bob, charlie];
      const positionIds = [];

      // Each user opens a position
      for (let i = 0; i < users.length; i++) {
        const params = {
          marketId,
          lowerTick: 100100 + i * 50,
          upperTick: 100200 + i * 50,
          quantity: POSITION_QUANTITY,
          maxCost: POSITION_MAX_COST,
        };

        const positionId = await core
          .connect(users[i])
          .openPosition.staticCall(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          );
        await core
          .connect(users[i])
          .openPosition(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          );
        positionIds.push(positionId);

        // Verify ownership
        expect(await position.ownerOf(positionId)).to.equal(users[i].address);
      }

      // Verify each user's balance
      for (let i = 0; i < users.length; i++) {
        expect(await position.balanceOf(users[i].address)).to.equal(1);
        expect(await position.ownerOf(positionIds[i])).to.equal(
          users[i].address
        );
      }

      // Alice increases her position
      const aliceIncreaseAmount = ethers.parseUnits("5", 6);
      const aliceIncreaseCost = await quoteIncreaseCost(
        core,
        positionIds[0],
        aliceIncreaseAmount
      );
      await core
        .connect(alice)
        .increasePosition(
          positionIds[0],
          aliceIncreaseAmount,
          aliceIncreaseCost
        );

      // Bob closes his position
      await core.connect(bob).closePosition(positionIds[1], 0);

      // Charlie decreases his position
      await core
        .connect(charlie)
        .decreasePosition(positionIds[2], ethers.parseUnits("2", 6), 0);

      // Verify final states
      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.balanceOf(bob.address)).to.equal(0);
      expect(await position.balanceOf(charlie.address)).to.equal(1);

      const alicePosition = await position.getPosition(positionIds[0]);
      expect(alicePosition.quantity).to.equal(
        POSITION_QUANTITY + aliceIncreaseAmount
      );

      await expect(
        position.getPosition(positionIds[1])
      ).to.be.revertedWithCustomError(position, "PositionNotFound");

      const charliePosition = await position.getPosition(positionIds[2]);
      expect(charliePosition.quantity).to.equal(POSITION_QUANTITY - ethers.parseUnits("2", 6));
    });
  });

  describe("Error Handling and Edge Cases", function () {
    it("should handle Core operations on non-existent positions", async function () {
      const { core, alice } = await loadFixture(activePositionMarketFixture);

      const nonExistentId = 999;

      await expect(
        core
          .connect(alice)
          .increasePosition(
            nonExistentId,
            ethers.parseUnits("1", 6),
            ethers.parseUnits("10", 6)
          )
      ).to.be.reverted;

      await expect(
        core
          .connect(alice)
          .decreasePosition(nonExistentId, ethers.parseUnits("1", 6), 0)
      ).to.be.reverted;

      await expect(core.connect(alice).closePosition(nonExistentId, 0)).to.be
        .reverted;
    });

    it("should handle position operations during market state changes", async function () {
      const { core, position, keeper, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open position
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      const increaseAmount = ethers.parseUnits("5", 6);
      const increaseCost = await quoteIncreaseCost(
        core,
        positionId,
        increaseAmount
      );

      // Pause the contract
      await core.connect(keeper).pause("Paused");

      // Operations should fail when paused
      await expect(
        core
          .connect(alice)
          .increasePosition(positionId, increaseAmount, increaseCost)
      ).to.be.revertedWithCustomError(core, "EnforcedPause");

      // Unpause and operations should work again
      await core.connect(keeper).unpause();

      await expect(
        core
          .connect(alice)
          .increasePosition(positionId, increaseAmount, increaseCost)
      ).to.emit(position, "PositionUpdated");
    });

    it("should maintain position integrity during sequential operations", async function () {
      const { core, position, alice, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Open position with realistic quantity
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: POSITION_QUANTITY,
        maxCost: POSITION_MAX_COST,
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      // Sequential operations with realistic quantities
      const operations = [
        async () => {
          const amount = ethers.parseUnits("5", 6);
          const cost = await quoteIncreaseCost(core, positionId, amount);
          await core
            .connect(alice)
            .increasePosition(positionId, amount, cost);
        },
        async () => {
          await core
            .connect(alice)
            .decreasePosition(positionId, ethers.parseUnits("2", 6), 0);
        },
        async () => {
          const amount = ethers.parseUnits("6", 6);
          const cost = await quoteIncreaseCost(core, positionId, amount);
          await core
            .connect(alice)
            .increasePosition(positionId, amount, cost);
        },
        async () => {
          await core
            .connect(alice)
            .decreasePosition(positionId, ethers.parseUnits("3", 6), 0);
        },
      ];

      // Execute all operations
      for (const operation of operations) {
        await operation();
      }

      // Verify final state is consistent
      const finalData = await position.getPosition(positionId);
      expect(finalData.quantity).to.equal(
        params.quantity + ethers.parseUnits("6", 6)
      );

      // Position should still be owned by Alice
      expect(await position.ownerOf(positionId)).to.equal(alice.address);
      expect(await position.balanceOf(alice.address)).to.equal(1);
    });
  });
});

```


## test/integration/position/position_lifecycle.spec.ts

```typescript
import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";

import { createActiveMarketFixture } from "../../helpers/fixtures/core";
import {
  listMarketPositions,
  openPositionWithQuote,
  quoteIncreaseCostWithBuffer,
} from "../../helpers/fixtures/position";
import { INTEGRATION_TAG } from "../../helpers/tags";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

const parse6 = (value: string) => ethers.parseUnits(value, 6);

async function openWithQuote(
  core: any,
  signer: any,
  params: {
    marketId: number;
    lowerTick: number;
    upperTick: number;
    quantity: bigint;
    bufferBps?: bigint;
    maxCost?: bigint;
  }
) {
  const { positionId } = await openPositionWithQuote(core, signer, params);
  return positionId;
}

async function increaseWithQuote(
  core: any,
  signer: any,
  positionId: bigint,
  amount: bigint,
  bufferBps: bigint = 1000n
) {
  const maxCost = await quoteIncreaseCostWithBuffer(
    core,
    positionId,
    amount,
    bufferBps
  );
  await core.connect(signer).increasePosition(positionId, amount, maxCost);
}

describeMaybe(`${INTEGRATION_TAG} Position Lifecycle Integration`, function () {
  describe("Complete Position Lifecycle", function () {
    it("should handle full position lifecycle: create -> modify -> transfer -> close", async function () {
      const { core, mockPosition: position, alice, bob, marketId } =
        await loadFixture(createActiveMarketFixture);

      const positionId = await openWithQuote(core, alice, {
        marketId,
        lowerTick: 100450,
        upperTick: 100550,
        quantity: parse6("20"),
      });

      expect(await position.ownerOf(positionId)).to.equal(alice.address);
      expect(await position.balanceOf(alice.address)).to.equal(1n);

      await increaseWithQuote(core, alice, positionId, parse6("8"));

      await core
        .connect(alice)
        .decreasePosition(positionId, parse6("12"), 0);

      const updatedPosition = await position.getPosition(positionId);
      expect(updatedPosition.quantity).to.equal(parse6("16"));

      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
      expect(await position.balanceOf(alice.address)).to.equal(0n);
      expect(await position.balanceOf(bob.address)).to.equal(1n);

      await core.connect(bob).closePosition(positionId, 0);

      expect(await position.balanceOf(bob.address)).to.equal(0n);
    });

    it("should handle multiple positions with complex interactions", async function () {
      const { core, mockPosition: position, alice, bob, charlie, marketId } =
        await loadFixture(createActiveMarketFixture);

      const aliceRanges = [
        { lower: 100100, upper: 100200, quantity: "20" },
        { lower: 100200, upper: 100300, quantity: "25" },
        { lower: 100300, upper: 100400, quantity: "30" },
      ];

      const bobRanges = [
        { lower: 100150, upper: 100250, quantity: "18" },
        { lower: 100250, upper: 100350, quantity: "22" },
      ];

      const alicePositionIds: bigint[] = [];
      for (const entry of aliceRanges) {
        const positionId = await openWithQuote(core, alice, {
          marketId,
          lowerTick: entry.lower,
          upperTick: entry.upper,
          quantity: parse6(entry.quantity),
        });
        alicePositionIds.push(positionId);
      }

      const bobPositionIds: bigint[] = [];
      for (const entry of bobRanges) {
        const positionId = await openWithQuote(core, bob, {
          marketId,
          lowerTick: entry.lower,
          upperTick: entry.upper,
          quantity: parse6(entry.quantity),
        });
        bobPositionIds.push(positionId);
      }

      expect(await position.balanceOf(alice.address)).to.equal(3n);
      expect(await position.balanceOf(bob.address)).to.equal(2n);

      await increaseWithQuote(core, alice, alicePositionIds[0], parse6("5"));
      await core
        .connect(bob)
        .decreasePosition(bobPositionIds[1], parse6("6"), 0);

      await position
        .connect(alice)
        .transferFrom(alice.address, charlie.address, alicePositionIds[1]);

      expect(await position.balanceOf(alice.address)).to.equal(2n);
      expect(await position.balanceOf(bob.address)).to.equal(2n);
      expect(await position.balanceOf(charlie.address)).to.equal(1n);
    });

    it("should handle position lifecycle with approval mechanisms", async function () {
      const { core, mockPosition: position, alice, bob, charlie, marketId } =
        await loadFixture(createActiveMarketFixture);

      const positionId = await openWithQuote(core, alice, {
        marketId,
        lowerTick: 100150,
        upperTick: 100250,
        quantity: parse6("24"),
      });

      await expect(position.connect(alice).approve(bob.address, positionId))
        .to.emit(position, "Approval")
        .withArgs(alice.address, bob.address, positionId);

      await expect(
        position
          .connect(bob)
          .transferFrom(alice.address, charlie.address, positionId)
      )
        .to.emit(position, "Transfer")
        .withArgs(alice.address, charlie.address, positionId);

      await expect(
        position.connect(charlie).setApprovalForAll(alice.address, true)
      )
        .to.emit(position, "ApprovalForAll")
        .withArgs(charlie.address, alice.address, true);

      const increaseAmount = parse6("6");
      const increaseCost = await quoteIncreaseCostWithBuffer(
        core,
        positionId,
        increaseAmount
      );

      await expect(
        core
          .connect(charlie)
          .increasePosition(positionId, increaseAmount, increaseCost)
      ).to.emit(position, "PositionUpdated");

      await position
        .connect(alice)
        .transferFrom(charlie.address, bob.address, positionId);
      expect(await position.ownerOf(positionId)).to.equal(bob.address);

      await core.connect(bob).closePosition(positionId, 0);
      expect(await position.balanceOf(bob.address)).to.equal(0n);
    });
  });

  describe("Position Lifecycle with Market Events", function () {
    it("should handle position operations during market state changes", async function () {
      const { core, mockPosition: position, keeper, alice, bob, marketId } =
        await loadFixture(createActiveMarketFixture);

      const positionId = await openWithQuote(core, alice, {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: parse6("15"),
      });

      await increaseWithQuote(core, alice, positionId, parse6("5"));

      await core.connect(keeper).pause("maintenance");

      const pausedCost = await quoteIncreaseCostWithBuffer(
        core,
        positionId,
        parse6("5")
      );

      await expect(
        core
          .connect(alice)
          .increasePosition(positionId, parse6("5"), pausedCost)
      ).to.be.revertedWithCustomError(core, "EnforcedPause");

      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, parse6("6"), 0)
      ).to.be.revertedWithCustomError(core, "EnforcedPause");

      await expect(
        core.connect(alice).closePosition(positionId, 0)
      ).to.be.revertedWithCustomError(core, "EnforcedPause");

      await expect(
        position
          .connect(alice)
          .transferFrom(alice.address, bob.address, positionId)
      )
        .to.emit(position, "Transfer")
        .withArgs(alice.address, bob.address, positionId);

      await core.connect(keeper).unpause();

      const resumedCost = await quoteIncreaseCostWithBuffer(
        core,
        positionId,
        parse6("4")
      );
      await core
        .connect(bob)
        .increasePosition(positionId, parse6("4"), resumedCost);

      await expect(core.connect(bob).closePosition(positionId, 0)).to.emit(
        position,
        "PositionBurned"
      );
    });

    it("should handle position operations with market resolution", async function () {
      const { core, mockPosition: position, keeper, alice, bob, marketId } =
        await loadFixture(createActiveMarketFixture);

      const positionIds: bigint[] = [];
      for (let i = 0; i < 3; i++) {
        const positionId = await openWithQuote(core, alice, {
          marketId,
          lowerTick: 100100 + i * 50,
          upperTick: 100200 + i * 50,
          quantity: parse6("18"),
        });
        positionIds.push(positionId);
      }

      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionIds[1]);

      expect(await position.balanceOf(alice.address)).to.equal(2n);
      expect(await position.balanceOf(bob.address)).to.equal(1n);

      await increaseWithQuote(core, alice, positionIds[0], parse6("6"));
      await core
        .connect(alice)
        .decreasePosition(positionIds[2], parse6("5"), 0);

      await core.connect(alice).closePosition(positionIds[0], 0);
      await core.connect(bob).closePosition(positionIds[1], 0);

      expect(await position.balanceOf(alice.address)).to.equal(1n);
      expect(await position.balanceOf(bob.address)).to.equal(0n);

      const finalPosition = await position.getPosition(positionIds[2]);
      expect(finalPosition.quantity).to.equal(parse6("13"));

      await core.connect(alice).closePosition(positionIds[2], 0);
      expect(await position.balanceOf(alice.address)).to.equal(0n);
    });
  });

  describe("Position Lifecycle Error Recovery", function () {
    it("should handle failed operations gracefully", async function () {
      const { core, mockPosition: position, alice, bob, marketId } =
        await loadFixture(createActiveMarketFixture);

      const positionId = await openWithQuote(core, alice, {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: parse6("12"),
      });

      const nonExistentId = 999n;
      const bogusCost = await quoteIncreaseCostWithBuffer(
        core,
        positionId,
        parse6("6")
      );

      await expect(
        core
          .connect(alice)
          .increasePosition(nonExistentId, parse6("6"), bogusCost)
      ).to.be.reverted;

      const positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(parse6("12"));
      expect(await position.ownerOf(positionId)).to.equal(alice.address);

      await expect(
        position
          .connect(bob)
          .transferFrom(alice.address, bob.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InsufficientApproval");

      const increaseCost = await quoteIncreaseCostWithBuffer(
        core,
        positionId,
        parse6("6")
      );
      await expect(
        core
          .connect(alice)
          .increasePosition(positionId, parse6("6"), increaseCost)
      ).to.emit(position, "PositionUpdated");

      await expect(
        position
          .connect(alice)
          .transferFrom(alice.address, bob.address, positionId)
      ).to.emit(position, "Transfer");

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
    });

    it("should handle position operations with insufficient funds gracefully", async function () {
      const { core, mockPosition: position, alice, marketId } =
        await loadFixture(createActiveMarketFixture);

      const positionId = await openWithQuote(core, alice, {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: parse6("12"),
      });

      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, parse6("20"), 0)
      ).to.be.reverted;

      const positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(parse6("12"));

      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, parse6("6"), 0)
      ).to.emit(position, "PositionUpdated");

      const finalState = await position.getPosition(positionId);
      expect(finalState.quantity).to.equal(parse6("6"));
    });

    it("should handle sequential position operations", async function () {
      const { core, mockPosition: position, alice, bob, charlie, marketId } =
        await loadFixture(createActiveMarketFixture);

      const positionId = await openWithQuote(core, alice, {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: parse6("20"),
      });

      const operations: Array<() => Promise<void>> = [
        async () => {
          const cost = await quoteIncreaseCostWithBuffer(
            core,
            positionId,
            parse6("5")
          );
          await core
            .connect(alice)
            .increasePosition(positionId, parse6("5"), cost);
        },
        async () => {
          await core
            .connect(alice)
            .decreasePosition(positionId, parse6("4"), 0);
        },
        async () => {
          const cost = await quoteIncreaseCostWithBuffer(
            core,
            positionId,
            parse6("8")
          );
          await core
            .connect(alice)
            .increasePosition(positionId, parse6("8"), cost);
        },
        async () => {
          await position
            .connect(alice)
            .transferFrom(alice.address, bob.address, positionId);
        },
        async () => {
          const cost = await quoteIncreaseCostWithBuffer(
            core,
            positionId,
            parse6("6")
          );
          await core
            .connect(bob)
            .increasePosition(positionId, parse6("6"), cost);
        },
        async () => {
          await position
            .connect(bob)
            .transferFrom(bob.address, charlie.address, positionId);
        },
        async () => {
          const cost = await quoteIncreaseCostWithBuffer(
            core,
            positionId,
            parse6("4")
          );
          await core
            .connect(charlie)
            .increasePosition(positionId, parse6("4"), cost);
        },
        async () => {
          await core
            .connect(charlie)
            .decreasePosition(positionId, parse6("9"), 0);
        },
      ];

      for (const operation of operations) {
        await operation();
      }

      const finalPosition = await position.getPosition(positionId);
      expect(finalPosition.quantity).to.equal(parse6("30"));

      await position
        .connect(charlie)
        .transferFrom(charlie.address, bob.address, positionId);
      expect(await position.ownerOf(positionId)).to.equal(bob.address);

      await core.connect(bob).closePosition(positionId, 0);
      expect(await position.balanceOf(bob.address)).to.equal(0n);
    });
  });

  describe("Position Lifecycle with Complex Scenarios", function () {
    it("should handle position lifecycle with multiple markets", async function () {
      const { core, mockPosition: position, alice, bob, marketId } =
        await loadFixture(createActiveMarketFixture);

      const tickRanges = [
        { lower: 100100, upper: 100200, quantity: "18" },
        { lower: 100300, upper: 100400, quantity: "28" },
        { lower: 100500, upper: 100600, quantity: "35" },
      ];

      const positionIds: bigint[] = [];
      for (const range of tickRanges) {
        const positionId = await openWithQuote(core, alice, {
          marketId,
          lowerTick: range.lower,
          upperTick: range.upper,
          quantity: parse6(range.quantity),
        });
        positionIds.push(positionId);
      }

      expect(await position.balanceOf(alice.address)).to.equal(3n);

      const marketPositions = await listMarketPositions(position, marketId);
      expect(marketPositions.length).to.equal(3);
      for (const id of positionIds) {
        expect(marketPositions).to.include(id);
      }

      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionIds[0]);
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionIds[2]);

      expect(await position.balanceOf(alice.address)).to.equal(1n);
      expect(await position.balanceOf(bob.address)).to.equal(2n);

      const alicePositions = await position.getPositionsByOwner(alice.address);
      const bobPositions = await position.getPositionsByOwner(bob.address);

      expect(alicePositions.length).to.equal(1);
      expect(alicePositions[0]).to.equal(positionIds[1]);

      expect(bobPositions.length).to.equal(2);
      expect(bobPositions).to.include(positionIds[0]);
      expect(bobPositions).to.include(positionIds[2]);

      await core.connect(alice).closePosition(positionIds[1], 0);
      await core.connect(bob).closePosition(positionIds[0], 0);
      await core.connect(bob).closePosition(positionIds[2], 0);

      expect(await position.balanceOf(alice.address)).to.equal(0n);
      expect(await position.balanceOf(bob.address)).to.equal(0n);

      const finalMarketPositions = await listMarketPositions(position, marketId);
      expect(finalMarketPositions.length).to.equal(0);
    });

    it("should handle position lifecycle with edge case quantities", async function () {
      const { core, mockPosition: position, alice, bob, marketId } =
        await loadFixture(createActiveMarketFixture);

      const smallPositionId = await openWithQuote(core, alice, {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: 1n,
      });

      expect((await position.getPosition(smallPositionId)).quantity).to.equal(1n);

      await increaseWithQuote(core, alice, smallPositionId, 1n, 2000n);
      expect((await position.getPosition(smallPositionId)).quantity).to.equal(2n);

      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, smallPositionId);
      expect(await position.ownerOf(smallPositionId)).to.equal(bob.address);

      await core.connect(bob).decreasePosition(smallPositionId, 1n, 0);
      expect((await position.getPosition(smallPositionId)).quantity).to.equal(1n);

      await core.connect(bob).closePosition(smallPositionId, 0);
      expect(await position.balanceOf(bob.address)).to.equal(0n);

      const largePositionId = await openWithQuote(core, alice, {
        marketId,
        lowerTick: 100300,
        upperTick: 100400,
        quantity: parse6("10"),
      });

      await increaseWithQuote(core, alice, largePositionId, parse6("5"));
      await core
        .connect(alice)
        .decreasePosition(largePositionId, parse6("7.5"), 0);

      expect((await position.getPosition(largePositionId)).quantity).to.equal(
        parse6("7.5")
      );

      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, largePositionId);
      await core.connect(bob).closePosition(largePositionId, 0);

      expect(await position.balanceOf(bob.address)).to.equal(0n);
    });
  });
});

```


## test/integration/position/position_market_interactions.spec.ts

```typescript
import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";
import { time } from "@nomicfoundation/hardhat-network-helpers";

import {
  activePositionMarketFixture,
  listMarketPositions,
  openPositionWithQuote,
  quoteIncreaseCostWithBuffer,
} from "../../helpers/fixtures/position";
import { INTEGRATION_TAG } from "../../helpers/tags";

async function getOwnerPositions(
  positionContract: any,
  marketId: number,
  owner: string
) {
  const marketPositions = await listMarketPositions(positionContract, marketId);
  const owned: bigint[] = [];
  for (const posId of marketPositions) {
    const posOwner = await positionContract.ownerOf(posId);
    if (posOwner === owner) {
      owned.push(posId);
    }
  }
  return owned;
}

describe(`${INTEGRATION_TAG} Position-Market Interactions`, function () {
  describe("Position Operations Across Market States", function () {
    it("should handle position operations during market lifecycle", async function () {
      const { core, position, keeper, alice, bob, marketId } =
        await loadFixture(activePositionMarketFixture);

      const aliceQuantity = ethers.parseUnits("2", 6);
      const bobQuantity = ethers.parseUnits("3", 6);

      const alicePosition = await openPositionWithQuote(core, alice, {
        marketId,
        lowerTick: 100100,
        upperTick: 100300,
        quantity: aliceQuantity,
      });

      const bobPosition = await openPositionWithQuote(core, bob, {
        marketId,
        lowerTick: 100300,
        upperTick: 100500,
        quantity: bobQuantity,
      });

      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.balanceOf(bob.address)).to.equal(1);

      const marketPositions = await listMarketPositions(position, marketId);
      expect(marketPositions.length).to.equal(2);

      const increaseAmount = ethers.parseUnits("0.5", 6);
      const aliceIncreaseCost = await quoteIncreaseCostWithBuffer(
        core,
        alicePosition.positionId,
        increaseAmount
      );

      await core
        .connect(alice)
        .increasePosition(alicePosition.positionId, increaseAmount, aliceIncreaseCost);

      const bobDecreaseAmount = ethers.parseUnits("0.5", 6);
      await core
        .connect(bob)
        .decreasePosition(bobPosition.positionId, bobDecreaseAmount, 0);

      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, alicePosition.positionId);
      expect(await position.balanceOf(bob.address)).to.equal(2);

      await core.connect(keeper).pause("maintenance");

      await expect(
        core
          .connect(alice)
          .increasePosition(bobPosition.positionId, increaseAmount, aliceIncreaseCost)
      ).to.be.revertedWithCustomError(core, "EnforcedPause");

      await core.connect(keeper).unpause();

      await position
        .connect(bob)
        .transferFrom(bob.address, alice.address, alicePosition.positionId);

      const bobIncreaseCost = await quoteIncreaseCostWithBuffer(
        core,
        bobPosition.positionId,
        increaseAmount
      );

      await core
        .connect(bob)
        .increasePosition(bobPosition.positionId, increaseAmount, bobIncreaseCost);

      await core.connect(alice).closePosition(alicePosition.positionId, 0);
      await core.connect(bob).closePosition(bobPosition.positionId, 0);

      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(0);

      const finalMarketPositions = await listMarketPositions(position, marketId);
      expect(finalMarketPositions.length).to.equal(0);
    });

    it("should handle position operations with overlapping tick ranges", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      const scenarios = [
        { user: alice, lower: 100100, upper: 100300, quantity: "0.6" },
        { user: bob, lower: 100200, upper: 100400, quantity: "0.5" },
        { user: alice, lower: 100250, upper: 100350, quantity: "0.4" },
        { user: bob, lower: 100150, upper: 100250, quantity: "0.3" },
      ];

      const references = [] as { id: bigint; owner: typeof alice }[];

      for (const scenario of scenarios) {
        const quantity = ethers.parseUnits(scenario.quantity, 6);
        const { positionId } = await openPositionWithQuote(core, scenario.user, {
          marketId,
          lowerTick: scenario.lower,
          upperTick: scenario.upper,
          quantity,
        });
        references.push({ id: positionId, owner: scenario.user });
      }

      expect(await position.balanceOf(alice.address)).to.equal(2);
      expect(await position.balanceOf(bob.address)).to.equal(2);

      const increaseAmount = ethers.parseUnits("0.2", 6);
      const increaseCost = await quoteIncreaseCostWithBuffer(
        core,
        references[0].id,
        increaseAmount
      );
      await core
        .connect(references[0].owner)
        .increasePosition(references[0].id, increaseAmount, increaseCost);

      const decreaseAmount = ethers.parseUnits("0.1", 6);
      await core
        .connect(references[1].owner)
        .decreasePosition(references[1].id, decreaseAmount, 0);

      await position
        .connect(references[2].owner)
        .transferFrom(
          references[2].owner.address,
          bob.address,
          references[2].id
        );
      references[2].owner = bob;

      await position
        .connect(references[3].owner)
        .transferFrom(
          references[3].owner.address,
          alice.address,
          references[3].id
        );
      references[3].owner = alice;

      expect(await position.balanceOf(alice.address)).to.equal(2);
      expect(await position.balanceOf(bob.address)).to.equal(2);

      for (const ref of references) {
        await core.connect(ref.owner).closePosition(ref.id, 0);
      }

      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(0);
    });

    it("should handle position operations with reasonable tick ranges", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Test with reasonable tick ranges for normal usage
      const reasonablePositions = [
        { lower: 100100, upper: 100500, quantity: "0.005" }, // Moderate wide range
        { lower: 100300, upper: 100350, quantity: "0.003" }, // Narrow range
        { lower: 100600, upper: 100750, quantity: "0.002" }, // Normal range
      ];

      const positionRefs: { id: bigint; owner: typeof alice | typeof bob }[] = [];

      for (const pos of reasonablePositions) {
        const params = {
          marketId,
          lowerTick: pos.lower,
          upperTick: pos.upper,
          quantity: ethers.parseUnits(pos.quantity, 6),
          maxCost: ethers.parseUnits("10", 6), // Reduced max cost for smaller quantities
        };

        const positionId = await core
          .connect(alice)
          .openPosition.staticCall(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          );
        await core
          .connect(alice)
          .openPosition(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          );
        positionRefs.push({ id: positionId, owner: alice });
      }

      expect(await position.balanceOf(alice.address)).to.equal(3);

      // Verify reasonable positions work correctly
      for (let i = 0; i < positionRefs.length; i++) {
        const posData = await position.getPosition(positionRefs[i].id);
        expect(posData.lowerTick).to.equal(reasonablePositions[i].lower);
        expect(posData.upperTick).to.equal(reasonablePositions[i].upper);
        expect(posData.quantity).to.equal(
          ethers.parseUnits(reasonablePositions[i].quantity, 6)
        );
      }

      // Operations should work on reasonable positions
      const increaseAmount = ethers.parseUnits("0.002", 6); // Small increase
      const increaseCost = await quoteIncreaseCostWithBuffer(
        core,
        positionRefs[0].id,
        increaseAmount
      );
      await core
        .connect(positionRefs[0].owner)
        .increasePosition(positionRefs[0].id, increaseAmount, increaseCost);

      await core.connect(positionRefs[1].owner).decreasePosition(
        positionRefs[1].id,
        ethers.parseUnits("0.001", 6),
        0
      ); // Small decrease within position quantity

      // Transfer extreme positions
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionRefs[0].id);
      positionRefs[0].owner = bob;
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionRefs[2].id);
      positionRefs[2].owner = bob;

      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.balanceOf(bob.address)).to.equal(2);

      // Close all positions
      for (const ref of positionRefs) {
        await core.connect(ref.owner).closePosition(ref.id, 0);
      }

      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(0);
    });
  });

  describe("Position Batch Operations", function () {
    it("should handle reasonable batch position creation and management", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      const batchSize = 5; // Reduced batch size for realistic usage
      const positionRefs: { id: bigint; owner: typeof alice | typeof bob }[] = [];
      const users = [alice, bob];

      // Create batch of positions with reasonable quantities
      for (let i = 0; i < batchSize; i++) {
        const user = users[i % users.length];
        const params = {
          marketId,
          lowerTick: 100100 + i * 40,
          upperTick: 100140 + i * 40,
          quantity: ethers.parseUnits((0.001 * (i + 1)).toString(), 6), // Much smaller quantities
          maxCost: ethers.parseUnits("5", 6), // Reduced max cost
        };

        const { positionId } = await openPositionWithQuote(core, user, {
          marketId,
          lowerTick: params.lowerTick,
          upperTick: params.upperTick,
          quantity: params.quantity,
        });
        positionRefs.push({ id: positionId, owner: user });
      }

      // Verify batch creation
      const aliceCount = positionRefs.filter((p) => p.owner === alice).length;
      const bobCount = positionRefs.filter((p) => p.owner === bob).length;

      expect(await position.balanceOf(alice.address)).to.equal(aliceCount);
      expect(await position.balanceOf(bob.address)).to.equal(bobCount);

      const marketPositions = await listMarketPositions(position, marketId);
      expect(marketPositions.length).to.equal(batchSize);

      // Batch operations
      const increaseAmount = ethers.parseUnits("0.0005", 6);
      for (let i = 0; i < positionRefs.length; i += 2) {
        const ref = positionRefs[i];
        const cost = await quoteIncreaseCostWithBuffer(core, ref.id, increaseAmount);
        await core
          .connect(ref.owner)
          .increasePosition(ref.id, increaseAmount, cost);
      }

      const decreaseAmount = ethers.parseUnits("0.0002", 6);
      for (let i = 1; i < positionRefs.length; i += 2) {
        const ref = positionRefs[i];
        await core
          .connect(ref.owner)
          .decreasePosition(ref.id, decreaseAmount, 0);
      }

      // Batch transfers - Alice transfers all her positions to Bob
      const alicePositions = await getOwnerPositions(
        position,
        marketId,
        alice.address
      );
      for (const posId of alicePositions) {
        await position
          .connect(alice)
          .transferFrom(alice.address, bob.address, posId);
        const ref = positionRefs.find((p) => p.id === posId);
        if (ref) {
          ref.owner = bob;
        }
      }

      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(
        aliceCount + bobCount
      );

      // Batch closure - close all positions
      for (const ref of positionRefs) {
        await core.connect(ref.owner).closePosition(ref.id, 0);
      }

      // Verify all cleaned up
      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(0);

      const finalMarketPositions = await listMarketPositions(position, marketId);
      expect(finalMarketPositions.length).to.equal(0);
    });

    it("should handle rapid position operations", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Create position for rapid operations
      const params = {
        marketId,
        lowerTick: 100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100100)
        upperTick: 100130, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100130)
        quantity: ethers.parseUnits("0.01", 6), // Reduced from 100 to 0.01
        maxCost: ethers.parseUnits("10", 6), // Reduced from 1000 to 10
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      let currentQuantity = params.quantity;

      // Rapid sequence of operations
      const operations = [
        { type: "increase", amount: ethers.parseUnits("0.001", 6) }, // Reduced from 10 to 0.001
        { type: "decrease", amount: ethers.parseUnits("0.0005", 6) }, // Reduced from 5 to 0.0005
        { type: "increase", amount: ethers.parseUnits("0.002", 6) }, // Reduced from 20 to 0.002
        { type: "decrease", amount: ethers.parseUnits("0.0015", 6) }, // Reduced from 15 to 0.0015
        { type: "increase", amount: ethers.parseUnits("0.0008", 6) }, // Reduced from 8 to 0.0008
        { type: "decrease", amount: ethers.parseUnits("0.0012", 6) }, // Reduced from 12 to 0.0012
        { type: "increase", amount: ethers.parseUnits("0.0025", 6) }, // Reduced from 25 to 0.0025
        { type: "decrease", amount: ethers.parseUnits("0.0018", 6) }, // Reduced from 18 to 0.0018
      ];

      for (const op of operations) {
        if (op.type === "increase") {
          const cost = await quoteIncreaseCostWithBuffer(
            core,
            positionId,
            op.amount
          );
          await core
            .connect(alice)
            .increasePosition(positionId, op.amount, cost);
          currentQuantity += op.amount;
        } else {
          await core.connect(alice).decreasePosition(positionId, op.amount, 0);
          currentQuantity -= op.amount;
        }

        // Verify state after each operation
        const posData = await position.getPosition(positionId);
        expect(posData.quantity).to.equal(currentQuantity);
      }

      // Transfer during rapid operations
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);
      expect(await position.ownerOf(positionId)).to.equal(bob.address);

      // Continue operations with new owner
      const bobIncreaseAmount = ethers.parseUnits("0.003", 6); // Reduced from 30 to 0.003
      const bobIncreaseCost = await quoteIncreaseCostWithBuffer(
        core,
        positionId,
        bobIncreaseAmount
      );
      await core
        .connect(bob)
        .increasePosition(positionId, bobIncreaseAmount, bobIncreaseCost);
      currentQuantity += bobIncreaseAmount;

      const finalData = await position.getPosition(positionId);
      expect(finalData.quantity).to.equal(currentQuantity);

      // Close position
      await core.connect(bob).closePosition(positionId, 0);
      expect(await position.balanceOf(bob.address)).to.equal(0);
    });
  });

  describe("Position Error Recovery and Edge Cases", function () {
    it("should handle position operations with market edge cases", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Create position with minimal quantity

      const minPositionId = await core.connect(alice).openPosition.staticCall(
        marketId,
        100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100100)
        100120, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100120)
        1,
        ethers.parseUnits("1", 6)
      );
      await core.connect(alice).openPosition(
        marketId,
        100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100100)
        100120, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100120)
        1,
        ethers.parseUnits("1", 6)
      );

      // Operations on minimal position
      await core
        .connect(alice)
        .increasePosition(minPositionId, 1, ethers.parseUnits("1", 6));

      let posData = await position.getPosition(minPositionId);
      expect(posData.quantity).to.equal(2);

      // Transfer minimal position
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, minPositionId);
      expect(await position.ownerOf(minPositionId)).to.equal(bob.address);

      // Decrease to 1
      await core.connect(bob).decreasePosition(minPositionId, 1, 0);
      posData = await position.getPosition(minPositionId);
      expect(posData.quantity).to.equal(1);

      // Close minimal position
      await core.connect(bob).closePosition(minPositionId, 0);
      expect(await position.balanceOf(bob.address)).to.equal(0);

      const maxPositionId = await core.connect(alice).openPosition.staticCall(
        marketId,
        100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100100)
        100120, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100120)
        1,
        ethers.parseUnits("1", 6)
      );
      await core.connect(alice).openPosition(
        marketId,
        100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100100)
        100120, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100120)
        1,
        ethers.parseUnits("1", 6)
      );

      // Operations on maximum position
      await core.connect(alice).increasePosition(
        maxPositionId,
        ethers.parseUnits("0.5", 6), // Reduced from 500000 to 0.5
        ethers.parseUnits("10", 6) // Reduced from 5000000 to 10
      );

      posData = await position.getPosition(maxPositionId);
      expect(posData.quantity).to.equal(ethers.parseUnits("0.500001", 6)); // 1 + 0.5 = 0.500001

      // Large decrease
      await core
        .connect(alice)
        .decreasePosition(maxPositionId, ethers.parseUnits("0.1", 6), 0); // Reduced from 1000000 to 0.1

      posData = await position.getPosition(maxPositionId);
      expect(posData.quantity).to.equal(ethers.parseUnits("0.400001", 6)); // 0.500001 - 0.1 = 0.400001

      // Transfer and close
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, maxPositionId);
      await core.connect(bob).closePosition(maxPositionId, 0);

      expect(await position.balanceOf(bob.address)).to.equal(0);
    });

    it("should handle position operations with failed transactions", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Create position
      const params = {
        marketId,
        lowerTick: 100100, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100100)
        upperTick: 100120, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100120)
        quantity: ethers.parseUnits("5", 6),
        maxCost: ethers.parseUnits("50", 6),
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      // Try invalid operations that should fail
      const nonExistentId = 999;

      await expect(
        core
          .connect(alice)
          .increasePosition(
            nonExistentId,
            ethers.parseUnits("1", 6),
            ethers.parseUnits("10", 6)
          )
      ).to.be.reverted;

      await expect(
        core
          .connect(alice)
          .decreasePosition(nonExistentId, ethers.parseUnits("1", 6), 0)
      ).to.be.reverted;

      await expect(core.connect(alice).closePosition(nonExistentId, 0)).to.be
        .reverted;

      // Original position should be unaffected
      const posData = await position.getPosition(positionId);
      expect(posData.quantity).to.equal(params.quantity);
      expect(await position.ownerOf(positionId)).to.equal(alice.address);

      // Try to decrease more than available
      await expect(
        core
          .connect(alice)
          .decreasePosition(positionId, ethers.parseUnits("10", 6), 0)
      ).to.be.reverted;

      // Position should still be intact
      const posDataAfter = await position.getPosition(positionId);
      expect(posDataAfter.quantity).to.equal(params.quantity);

      // Valid operations should still work
      await core
        .connect(alice)
        .increasePosition(
          positionId,
          ethers.parseUnits("2", 6),
          ethers.parseUnits("20", 6)
        );

      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);
      await core.connect(bob).closePosition(positionId, 0);

      expect(await position.balanceOf(bob.address)).to.equal(0);
    });

    it("should maintain data integrity across complex operation sequences", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      const positionIds = [];
      const expectedStates = [];

      // Create multiple positions with different parameters
      for (let i = 0; i < 5; i++) {
        const params = {
          marketId,
          lowerTick: 100100 + i * 80, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100100, 100180, ...)
          upperTick: 100180 + i * 80, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© (100180, 100260, ...)
          quantity: ethers.parseUnits((0.05 * (i + 1)).toFixed(3), 6),
          maxCost: ethers.parseUnits("100", 6),
        };

        const user = [alice, bob][i % 2];
        const positionId = await core
          .connect(user)
          .openPosition.staticCall(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          );
        await core
          .connect(user)
          .openPosition(
            params.marketId,
            params.lowerTick,
            params.upperTick,
            params.quantity,
            params.maxCost
          );

        positionIds.push(positionId);
        expectedStates.push({
          id: positionId,
          owner: user.address,
          marketId,
          lowerTick: params.lowerTick,
          upperTick: params.upperTick,
          quantity: params.quantity,
        });
      }

      // Complex sequence of operations
      const operations = [
        {
          type: "decrease" as const,
          posIndex: 0,
          amount: ethers.parseUnits("0.02", 6),
        },
        { type: "transfer" as const, posIndex: 1, to: alice },
        {
          type: "decrease" as const,
          posIndex: 3,
          amount: ethers.parseUnits("0.05", 6),
        },
        { type: "transfer" as const, posIndex: 0, to: bob },
        {
          type: "decrease" as const,
          posIndex: 4,
          amount: ethers.parseUnits("0.06", 6),
        },
        { type: "transfer" as const, posIndex: 2, to: alice },
      ];

      for (const op of operations) {
        const posId = positionIds[op.posIndex];
        const ownerAddress = expectedStates[op.posIndex].owner;
        const ownerSigner = ownerAddress === alice.address ? alice : bob;

        if (op.type === "decrease") {
          await core
            .connect(ownerSigner)
            .decreasePosition(posId, op.amount!, 0);
          expectedStates[op.posIndex].quantity -= op.amount!;
        } else if (op.type === "transfer") {
          await position
            .connect(ownerSigner)
            .transferFrom(
              ownerSigner.address,
              op.to!.address,
              posId
            );
          expectedStates[op.posIndex].owner = op.to!.address;
        }

        // Verify state after each operation
        const posData = await position.getPosition(posId);
        expect(posData.quantity).to.equal(expectedStates[op.posIndex].quantity);
        expect(await position.ownerOf(posId)).to.equal(
          expectedStates[op.posIndex].owner
        );
        expect(posData.marketId).to.equal(expectedStates[op.posIndex].marketId);
        expect(posData.lowerTick).to.equal(
          expectedStates[op.posIndex].lowerTick
        );
        expect(posData.upperTick).to.equal(
          expectedStates[op.posIndex].upperTick
        );
      }

      // Verify final balances
      const alicePositions = await getOwnerPositions(
        position,
        marketId,
        alice.address
      );
      const bobPositions = await getOwnerPositions(
        position,
        marketId,
        bob.address
      );

      const aliceCount = expectedStates.filter(
        (s) => s.owner === alice.address
      ).length;
      const bobCount = expectedStates.filter(
        (s) => s.owner === bob.address
      ).length;

      expect(alicePositions.length).to.equal(aliceCount);
      expect(bobPositions.length).to.equal(bobCount);

      // Close all positions
      for (let i = 0; i < positionIds.length; i++) {
        const ownerAddress = expectedStates[i].owner;
        const ownerSigner = ownerAddress === alice.address ? alice : bob;
        await core.connect(ownerSigner).closePosition(positionIds[i], 0);
      }

      // Verify complete cleanup
      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(0);

      const finalMarketPositions = await listMarketPositions(position, marketId);
      expect(finalMarketPositions.length).to.equal(0);
    });
  });
});

```


## test/integration/position/position_transfers.spec.ts

```typescript
import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { ethers } from "hardhat";

import {
  activePositionMarketFixture,
  createRealTestPosition,
} from "../../helpers/fixtures/position";
import { COMPONENT_TAG } from "../../helpers/tags";

describe(`${COMPONENT_TAG} Position NFT Transfers`, function () {
  const POSITION_QUANTITY = ethers.parseUnits("10", 6);
  const COST_BUFFER = ethers.parseUnits("100", 6);

  async function quoteIncreaseCost(
    coreContract: any,
    positionId: bigint,
    amount: bigint
  ) {
    const quote = await coreContract.calculateIncreaseCost(positionId, amount);
    return quote + COST_BUFFER;
  }

  describe("Position Transfer Mechanics", function () {
    it("should transfer position NFT between users", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Verify initial ownership
      expect(await position.ownerOf(positionId)).to.equal(alice.address);
      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.balanceOf(bob.address)).to.equal(0);

      // Transfer position
      await expect(
        position
          .connect(alice)
          .transferFrom(alice.address, bob.address, positionId)
      )
        .to.emit(position, "Transfer")
        .withArgs(alice.address, bob.address, positionId);

      // Verify transfer
      expect(await position.ownerOf(positionId)).to.equal(bob.address);
      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(1);
    });

    it("should handle safeTransferFrom correctly", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Safe transfer
      await expect(
        position
          .connect(alice)
          ["safeTransferFrom(address,address,uint256)"](
            alice.address,
            bob.address,
            positionId
          )
      )
        .to.emit(position, "Transfer")
        .withArgs(alice.address, bob.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
    });

    it("should handle safeTransferFrom with data", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );
      const data = ethers.toUtf8Bytes("test data");

      // Safe transfer with data
      await expect(
        position
          .connect(alice)
          ["safeTransferFrom(address,address,uint256,bytes)"](
            alice.address,
            bob.address,
            positionId,
            data
          )
      )
        .to.emit(position, "Transfer")
        .withArgs(alice.address, bob.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
    });

    it("should update position tracking correctly on multiple transfers", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Alice -> Bob
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(1);
      expect(await position.balanceOf(charlie.address)).to.equal(0);

      // Bob -> Charlie
      await position
        .connect(bob)
        .transferFrom(bob.address, charlie.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(charlie.address);
      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(0);
      expect(await position.balanceOf(charlie.address)).to.equal(1);

      // Charlie -> Alice (back to original)
      await position
        .connect(charlie)
        .transferFrom(charlie.address, alice.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(alice.address);
      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.balanceOf(bob.address)).to.equal(0);
      expect(await position.balanceOf(charlie.address)).to.equal(0);
    });

    it("should handle transfers of multiple positions", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { core, position, alice, bob, marketId } = contracts;

      // Create multiple positions for Alice
      const positionIds = [];
      for (let i = 0; i < 3; i++) {
        const { positionId } = await createRealTestPosition(
          contracts,
          alice,
          marketId,
          100100 + i * 50,
          100200 + i * 50,
          POSITION_QUANTITY
        );
        positionIds.push(positionId);
      }

      expect(await position.balanceOf(alice.address)).to.equal(3);
      expect(await position.balanceOf(bob.address)).to.equal(0);

      // Transfer first two positions to Bob
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionIds[0]);
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionIds[1]);

      // Verify balances
      expect(await position.balanceOf(alice.address)).to.equal(1);
      expect(await position.balanceOf(bob.address)).to.equal(2);

      expect(await position.ownerOf(positionIds[2])).to.equal(alice.address);
      expect(await position.ownerOf(positionIds[0])).to.equal(bob.address);
      expect(await position.ownerOf(positionIds[1])).to.equal(bob.address);
    });
  });

  describe("Transfer Authorization", function () {
    it("should allow approved address to transfer position", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Alice approves Bob to transfer her position
      await expect(position.connect(alice).approve(bob.address, positionId))
        .to.emit(position, "Approval")
        .withArgs(alice.address, bob.address, positionId);

      expect(await position.getApproved(positionId)).to.equal(bob.address);

      // Bob transfers Alice's position to Charlie
      await expect(
        position
          .connect(bob)
          .transferFrom(alice.address, charlie.address, positionId)
      )
        .to.emit(position, "Transfer")
        .withArgs(alice.address, charlie.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(charlie.address);
      expect(await position.getApproved(positionId)).to.equal(
        ethers.ZeroAddress
      );
    });

    it("should allow operator to transfer all positions", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId: positionId1 } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );
      const { positionId: positionId2 } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Alice sets Bob as operator for all her tokens
      await expect(position.connect(alice).setApprovalForAll(bob.address, true))
        .to.emit(position, "ApprovalForAll")
        .withArgs(alice.address, bob.address, true);

      expect(await position.isApprovedForAll(alice.address, bob.address)).to.be
        .true;

      // Bob can transfer both positions
      await position
        .connect(bob)
        .transferFrom(alice.address, charlie.address, positionId1);
      await position
        .connect(bob)
        .transferFrom(alice.address, charlie.address, positionId2);

      expect(await position.ownerOf(positionId1)).to.equal(charlie.address);
      expect(await position.ownerOf(positionId2)).to.equal(charlie.address);
      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(charlie.address)).to.equal(2);
    });

    it("should revoke approval after transfer", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Approve and transfer
      await position.connect(alice).approve(bob.address, positionId);
      await position
        .connect(bob)
        .transferFrom(alice.address, charlie.address, positionId);

      // Approval should be cleared
      expect(await position.getApproved(positionId)).to.equal(
        ethers.ZeroAddress
      );
    });

    it("should prevent unauthorized transfers", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Bob tries to transfer Alice's position without approval
      await expect(
        position
          .connect(bob)
          .transferFrom(alice.address, charlie.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InsufficientApproval");

      // Charlie tries to transfer Alice's position without approval
      await expect(
        position
          .connect(charlie)
          .transferFrom(alice.address, bob.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InsufficientApproval");
    });

    it("should handle approval revocation", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Approve Bob
      await position.connect(alice).approve(bob.address, positionId);
      expect(await position.getApproved(positionId)).to.equal(bob.address);

      // Revoke approval by approving zero address
      await position.connect(alice).approve(ethers.ZeroAddress, positionId);
      expect(await position.getApproved(positionId)).to.equal(
        ethers.ZeroAddress
      );

      // Bob can no longer transfer
      await expect(
        position
          .connect(bob)
          .transferFrom(alice.address, charlie.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InsufficientApproval");
    });

    it("should handle operator revocation", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Set Bob as operator
      await position.connect(alice).setApprovalForAll(bob.address, true);
      expect(await position.isApprovedForAll(alice.address, bob.address)).to.be
        .true;

      // Revoke operator status
      await position.connect(alice).setApprovalForAll(bob.address, false);
      expect(await position.isApprovedForAll(alice.address, bob.address)).to.be
        .false;

      // Bob can no longer transfer
      await expect(
        position
          .connect(bob)
          .transferFrom(alice.address, charlie.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InsufficientApproval");
    });
  });

  describe("Transfer Edge Cases", function () {
    it("should prevent transfer to zero address", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      await expect(
        position
          .connect(alice)
          .transferFrom(alice.address, ethers.ZeroAddress, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InvalidReceiver");
    });

    it("should prevent transfer of non-existent token", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, marketId } = contracts;

      const nonExistentId = 999;

      await expect(
        position
          .connect(alice)
          .transferFrom(alice.address, bob.address, nonExistentId)
      ).to.be.revertedWithCustomError(position, "ERC721NonexistentToken");
    });

    it("should prevent transfer from wrong owner", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Bob tries to transfer from Charlie (who doesn't own the token)
      // This should fail with ERC721InsufficientApproval because Bob is not approved
      await expect(
        position
          .connect(bob)
          .transferFrom(charlie.address, bob.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InsufficientApproval");
    });

    it("should handle self-transfer", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Self-transfer should work but be a no-op
      await expect(
        position
          .connect(alice)
          .transferFrom(alice.address, alice.address, positionId)
      )
        .to.emit(position, "Transfer")
        .withArgs(alice.address, alice.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(alice.address);
      expect(await position.balanceOf(alice.address)).to.equal(1);
    });

    it("should handle rapid transfers", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { position, alice, bob, charlie, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId
      );

      // Rapid back-and-forth transfers
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);
      await position
        .connect(bob)
        .transferFrom(bob.address, charlie.address, positionId);
      await position
        .connect(charlie)
        .transferFrom(charlie.address, alice.address, positionId);
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
      expect(await position.balanceOf(alice.address)).to.equal(0);
      expect(await position.balanceOf(bob.address)).to.equal(1);
      expect(await position.balanceOf(charlie.address)).to.equal(0);

      expect(await position.ownerOf(positionId)).to.equal(bob.address);
    });
  });

  describe("Transfer Impact on Position Operations", function () {
    it("should allow new owner to manage transferred position", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { core, position, alice, bob, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId,
        100100,
        100200,
        POSITION_QUANTITY
      );

      // Transfer to Bob
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      // Bob should be able to manage the position
      const increaseAmount = ethers.parseUnits("5", 6);
      const increaseCost = await quoteIncreaseCost(
        core,
        positionId,
        increaseAmount
      );
      await expect(
        core
          .connect(bob)
          .increasePosition(positionId, increaseAmount, increaseCost)
      ).to.emit(position, "PositionUpdated");

      await expect(
        core
          .connect(bob)
          .decreasePosition(positionId, ethers.parseUnits("2", 6), 0)
      ).to.emit(position, "PositionUpdated");

      await expect(core.connect(bob).closePosition(positionId, 0)).to.emit(
        position,
        "PositionBurned"
      );

      // Position should be burned and Bob's balance should be 0
      expect(await position.balanceOf(bob.address)).to.equal(0);
    });

    it("should prevent original owner from managing transferred position", async function () {
      const { core, position, alice, bob, marketId } = await loadFixture(
        activePositionMarketFixture
      );

      // Alice opens position
      const params = {
        marketId,
        lowerTick: 100100,
        upperTick: 100200,
        quantity: ethers.parseUnits("2", 6),
        maxCost: ethers.parseUnits("20", 6),
      };

      const positionId = await core
        .connect(alice)
        .openPosition.staticCall(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );
      await core
        .connect(alice)
        .openPosition(
          params.marketId,
          params.lowerTick,
          params.upperTick,
          params.quantity,
          params.maxCost
        );

      // Transfer to Bob
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      // Alice should no longer be able to approve transfers
      await expect(
        position.connect(alice).approve(alice.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InvalidApprover");

      // Alice should not be able to transfer it back
      await expect(
        position
          .connect(alice)
          .transferFrom(bob.address, alice.address, positionId)
      ).to.be.revertedWithCustomError(position, "ERC721InsufficientApproval");
    });

    it("should handle position transfer during active operations", async function () {
      const contracts = await loadFixture(activePositionMarketFixture);
      const { core, position, alice, bob, marketId } = contracts;

      const { positionId } = await createRealTestPosition(
        contracts,
        alice,
        marketId,
        100100,
        100200,
        POSITION_QUANTITY
      );

      const increaseAmount = ethers.parseUnits("5", 6);
      const increaseCost = await quoteIncreaseCost(
        core,
        positionId,
        increaseAmount
      );
      await core
        .connect(alice)
        .increasePosition(positionId, increaseAmount, increaseCost);

      let positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(
        POSITION_QUANTITY + increaseAmount
      );

      // Transfer to Bob
      await position
        .connect(alice)
        .transferFrom(alice.address, bob.address, positionId);

      // Position data should remain the same
      positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(
        POSITION_QUANTITY + increaseAmount
      );
      expect(positionData.marketId).to.equal(marketId);
      expect(positionData.lowerTick).to.equal(100100);
      expect(positionData.upperTick).to.equal(100200);

      // Bob can continue operations
      const decreaseAmount = ethers.parseUnits("3", 6);
      await core
        .connect(bob)
        .decreasePosition(positionId, decreaseAmount, 0);

      positionData = await position.getPosition(positionId);
      expect(positionData.quantity).to.equal(
        POSITION_QUANTITY + increaseAmount - decreaseAmount
      );
    });
  });
});

```


## test/integration/trading/claim.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { createActiveMarketFixture, settleMarketUsingRange, advanceToClaimOpen } from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";

describe(`${INTEGRATION_TAG} Position Claiming`, function () {
  const SMALL_QUANTITY = ethers.parseUnits("0.01", 6); // 0.01 USDC
  const MEDIUM_QUANTITY = ethers.parseUnits("0.05", 6); // 0.05 USDC
  const MEDIUM_COST = ethers.parseUnits("5", 6); // 5 USDC

  it("Should claim winning position", async function () {
    const { core, alice, bob, paymentToken, mockPosition, marketId, keeper } =
      await loadFixture(createActiveMarketFixture);

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    // Create position that will win
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Settle market with winning tick
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500);
    await advanceToClaimOpen(core, marketId);
    await advanceToClaimOpen(core, marketId);

    // Claim position
    await expect(core.connect(alice).claimPayout(positionId)).to.emit(
      core,
      "PositionClaimed"
    );

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.gt(balanceBefore);
  });

  it("Should handle claiming losing position", async function () {
    const { core, alice, bob, paymentToken, mockPosition, marketId, keeper } =
      await loadFixture(createActiveMarketFixture);

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    // Create position that will lose
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100010,
        100020,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Settle market with winning tick outside position range
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500);
    await advanceToClaimOpen(core, marketId);

    // Claim should emit event with zero payout
    await expect(core.connect(alice).claimPayout(positionId))
      .to.emit(core, "PositionClaimed")
      .withArgs(positionId, alice.address, 0);

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.lte(balanceBefore); // No payout (balance may decrease due to gas costs)
  });

  it("Should revert claim of non-existent position", async function () {
    const { core, alice, mockPosition } = await loadFixture(
      createActiveMarketFixture
    );
    await expect(
      core.connect(alice).claimPayout(999) // Non-existent position
    ).to.be.revertedWithCustomError(mockPosition, "PositionNotFound");
  });

  it("Should revert claim before market settlement", async function () {
    const { core, alice, bob, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Try to claim before settlement
    await expect(
      core.connect(alice).claimPayout(positionId)
    ).to.be.revertedWithCustomError(core, "MarketNotSettled");
  });

  it("Should handle claiming already claimed position", async function () {
    const { core, alice, bob, mockPosition, marketId, keeper } = await loadFixture(
      createActiveMarketFixture
    );

    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Settle market and advance to claim window
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500);
    const market = await core.getMarket(marketId);
    const claimOpen =
      Number(
        market.settlementTimestamp === 0n
          ? market.endTimestamp
          : market.settlementTimestamp
      ) + 15 * 60;
    await time.increaseTo(claimOpen + 1);
    await advanceToClaimOpen(core, marketId);
    await time.increase(15 * 60 + 1);
    await advanceToClaimOpen(core, marketId);
    await time.increase(15 * 60 + 1);
    await advanceToClaimOpen(core, marketId);
    await advanceToClaimOpen(core, marketId);
    await advanceToClaimOpen(core, marketId);
    await advanceToClaimOpen(core, marketId);
    await advanceToClaimOpen(core, marketId);

    // First claim should succeed
    await core.connect(alice).claimPayout(positionId);

    // Second claim should fail
    await expect(
      core.connect(alice).claimPayout(positionId)
    ).to.be.revertedWithCustomError(mockPosition, "PositionNotFound");
  });

  it("Should calculate claim payout correctly", async function () {
    const { core, alice, mockPosition, marketId, keeper } = await loadFixture(
      createActiveMarketFixture
    );

    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Settle market
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500);
    await advanceToClaimOpen(core, marketId);
    await time.increase(15 * 60 + 1);
    await advanceToClaimOpen(core, marketId);
    await time.increase(15 * 60 + 1);
    await advanceToClaimOpen(core, marketId);
    await advanceToClaimOpen(core, marketId);
    await advanceToClaimOpen(core, marketId);
    await advanceToClaimOpen(core, marketId);

    const payout = await core.calculateClaimAmount(positionId);
    expect(payout).to.be.gt(0);

    await expect(core.connect(alice).claimPayout(positionId)).to.not.be
      .reverted;
  });

  it("Should handle partial winning positions", async function () {
    const { core, alice, mockPosition, marketId, keeper } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position that partially covers winning outcome
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100480,
        100520,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Settle market
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500);
    await advanceToClaimOpen(core, marketId);

    const payout = await core.calculateClaimAmount(positionId);
    expect(payout).to.be.gt(0);

    await expect(core.connect(alice).claimPayout(positionId)).to.not.be
      .reverted;
  });

  it("Should handle multiple positions claiming", async function () {
    const { core, alice, bob, mockPosition, marketId, keeper } =
      await loadFixture(createActiveMarketFixture);

    // Alice creates winning position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    // Bob creates losing position
    await core
      .connect(bob)
      .openPosition(
        marketId,
        100010,
        100020,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    // Settle market
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500);

    const alicePositions = await mockPosition.getPositionsByOwner(
      alice.address
    );
    const bobPositions = await mockPosition.getPositionsByOwner(bob.address);

    // Both should be able to claim
    await time.increase(3600);
    await expect(core.connect(alice).claimPayout(alicePositions[0])).to.not.be
      .reverted;

    await expect(core.connect(bob).claimPayout(bobPositions[0])).to.not.be
      .reverted;
  });

  it("Should emit correct events on claim", async function () {
    const { core, alice, mockPosition, marketId, keeper } = await loadFixture(
      createActiveMarketFixture
    );

    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Settle market
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500);
    await advanceToClaimOpen(core, marketId);
    await time.increase(15 * 60 + 1);

    // Claim should emit PositionClaimed event
    await expect(core.connect(alice).claimPayout(positionId))
      .to.emit(core, "PositionClaimed")
      .withArgs(positionId, alice.address, anyValue);
  });

  it("Should handle double claim attempts", async function () {
    const { core, keeper, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        SMALL_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Settle market with winning tick
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500);
    await advanceToClaimOpen(core, marketId);

    // First claim should succeed
    await expect(core.connect(alice).claimPayout(positionId)).to.not.be
      .reverted;

    // Second claim should fail (position burned)
    await expect(
      core.connect(alice).claimPayout(positionId)
    ).to.be.revertedWithCustomError(mockPosition, "PositionNotFound");
  });

  it("Should handle losing position claims", async function () {
    const { core, keeper, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        SMALL_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Settle market with losing tick (outside position range)
    await settleMarketUsingRange(core, keeper, marketId, 100790, 100800);
    await advanceToClaimOpen(core, marketId);

    // Claim should succeed with zero payout
    await expect(core.connect(alice).claimPayout(positionId))
      .to.emit(core, "PositionClaimed")
      .withArgs(positionId, alice.address, 0);
  });
});

```


## test/integration/trading/close.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { createActiveMarketFixture, settleMarketUsingRange, advanceToClaimOpen } from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";

describe(`${INTEGRATION_TAG} Position Closing`, function () {
  const SMALL_QUANTITY = ethers.parseUnits("0.01", 6); // 0.01 USDC
  const MEDIUM_QUANTITY = ethers.parseUnits("0.05", 6); // 0.05 USDC
  const MEDIUM_COST = ethers.parseUnits("5", 6); // 5 USDC
  const TICK_COUNT = 100;

  it("Should close position completely", async function () {
    const { core, alice, paymentToken, mockPosition, marketId } =
      await loadFixture(createActiveMarketFixture);

    // Create initial position
    const tradeParams = {
      marketId: marketId,
      lowerTick: 100450,
      upperTick: 100550,
      quantity: MEDIUM_QUANTITY,
      maxCost: MEDIUM_COST,
    };

    await core
      .connect(alice)
      .openPosition(
        tradeParams.marketId,
        tradeParams.lowerTick,
        tradeParams.upperTick,
        tradeParams.quantity,
        tradeParams.maxCost
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    // Close position
    await expect(
      core.connect(alice).closePosition(
        positionId,
        0 // Min payout
      )
    ).to.emit(core, "PositionClosed");

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.gt(balanceBefore); // Received payout

    // Position should be burned/deleted
    await expect(
      mockPosition.getPosition(positionId)
    ).to.be.revertedWithCustomError(mockPosition, "PositionNotFound");
  });

  it("Should handle multiple position closures", async function () {
    const { core, alice, bob, paymentToken, mockPosition, marketId } =
      await loadFixture(createActiveMarketFixture);

    // Create multiple positions
    const positions = [];
    const users = [alice, bob];

    for (const user of users) {
      await core
        .connect(user)
        .openPosition(
          marketId,
          100040,
          100060,
          SMALL_QUANTITY,
          MEDIUM_COST
        );
      const userPositions = await mockPosition.getPositionsByOwner(
        user.address
      );
      positions.push(userPositions[userPositions.length - 1]);
    }

    // Close all positions
    for (let i = 0; i < positions.length; i++) {
      const user = users[i];
      const positionId = positions[i];
      const balanceBefore = await paymentToken.balanceOf(user.address);

      await expect(core.connect(user).closePosition(positionId, 0)).to.emit(
        core,
        "PositionClosed"
      );

      const balanceAfter = await paymentToken.balanceOf(user.address);
      expect(balanceAfter).to.be.gte(balanceBefore); // Received payout (could be 0)
    }

    // All positions should be cleaned up
    for (const user of users) {
      const userPositions = await mockPosition.getPositionsByOwner(
        user.address
      );
      expect(userPositions.length).to.equal(0);
    }
  });

  it("Should handle position closure with settled market", async function () {
    const { core, alice, paymentToken, mockPosition, marketId, keeper } =
      await loadFixture(createActiveMarketFixture);

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Move to market end and settle
    const market = await core.getMarket(marketId);
    await time.increaseTo(Number(market.endTimestamp) + 1);
    await settleMarketUsingRange(core, keeper, marketId, 100490, 100500); // Settle using midpoint tick
    await advanceToClaimOpen(core, marketId);

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    // Claim position after settlement (not close)
    await expect(core.connect(alice).claimPayout(positionId)).to.emit(
      core,
      "PositionClaimed"
    );

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.gt(balanceBefore); // Should receive settlement payout
  });

  it("Should handle edge case: close position with minimal payout", async function () {
    const { core, alice, paymentToken, mockPosition, marketId } =
      await loadFixture(createActiveMarketFixture);

    // Create very small position
    await core.connect(alice).openPosition(
      marketId,
      100850,
      100950,
      1, // Very small quantity
      ethers.parseUnits("1", 6)
    );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    // Close position
    await expect(core.connect(alice).closePosition(positionId, 0)).to.emit(
      core,
      "PositionClosed"
    );

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.gte(balanceBefore); // At least no loss
  });

  it("Should revert on invalid position closure", async function () {
    const { core, alice, mockPosition } = await loadFixture(
      createActiveMarketFixture
    );

    // Try to close non-existent position
    await expect(
      core.connect(alice).closePosition(999, 0)
    ).to.be.revertedWithCustomError(mockPosition, "PositionNotFound");
  });

  it("Should handle position closure with minimum payout requirement", async function () {
    const { core, alice, paymentToken, mockPosition, marketId } =
      await loadFixture(createActiveMarketFixture);

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Try to close with unreasonably high minimum payout
    const highMinPayout = ethers.parseUnits("1000", 6);
    await expect(
      core.connect(alice).closePosition(positionId, highMinPayout)
    ).to.be.revertedWithCustomError(core, "ProceedsBelowMinimum");
  });

  it("Should handle partial closure through decrease", async function () {
    const { core, alice, paymentToken, mockPosition, marketId } =
      await loadFixture(createActiveMarketFixture);

    // Create larger position
    const quantity = ethers.parseUnits("0.1", 6);
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        quantity,
        ethers.parseUnits("50", 6)
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    // Partially close position (decrease by half)
    const decreaseAmount = quantity / 2n;
    await expect(
      core.connect(alice).decreasePosition(positionId, decreaseAmount, 0)
    ).to.emit(core, "PositionDecreased");

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.gt(balanceBefore);

    // Position should still exist with reduced quantity
    const positionData = await mockPosition.getPosition(positionId);
   expect(positionData.quantity).to.be.lt(quantity);
   expect(positionData.quantity).to.be.gt(0);
  });

  it("Uses nearest rounding for close proceeds and keeps tree sums non-increasing", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const market = await core.getMarket(marketId);
    const minTick = market.minTick;
    const maxTick = market.maxTick;

    const estimatedProceeds = await core.calculateCloseProceeds(positionId);
    const totalBefore = await core.getRangeSum(marketId, minTick, maxTick);

    const tx = await core.connect(alice).closePosition(positionId, 0);
    const receipt = await tx.wait();

    const closedLog = receipt.logs
      .map((log) => {
        try {
          return core.interface.parseLog(log);
        } catch {
          return undefined;
        }
      })
      .find((parsed) => parsed && parsed.name === "PositionClosed");

    expect(closedLog, "PositionClosed event not found").to.not.be.undefined;
    const actualProceeds = (closedLog!.args.proceeds as bigint) ?? 0n;

    const delta =
      actualProceeds >= estimatedProceeds
        ? actualProceeds - estimatedProceeds
        : estimatedProceeds - actualProceeds;
    expect(delta).to.be.lte(1n);

    const totalAfter = await core.getRangeSum(marketId, minTick, maxTick);
    expect(totalAfter).to.be.lte(totalBefore);
  });
});

```


## test/integration/trading/decrease.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { createActiveMarketFixture } from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";

describe(`${INTEGRATION_TAG} Position Decrease`, function () {
  const SMALL_QUANTITY = ethers.parseUnits("0.01", 6); // 0.01 USDC
  const MEDIUM_QUANTITY = ethers.parseUnits("0.05", 6); // 0.05 USDC
  const MEDIUM_COST = ethers.parseUnits("5", 6); // 5 USDC

  it("Should decrease position quantity", async function () {
    const { core, alice, paymentToken, mockPosition, marketId } =
      await loadFixture(createActiveMarketFixture);

    // Create initial position
    const tradeParams = {
      marketId: marketId,
      lowerTick: 100450,
      upperTick: 100550,
      quantity: MEDIUM_QUANTITY,
      maxCost: MEDIUM_COST,
    };

    await core
      .connect(alice)
      .openPosition(
        tradeParams.marketId,
        tradeParams.lowerTick,
        tradeParams.upperTick,
        tradeParams.quantity,
        tradeParams.maxCost
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    // Decrease position
    await expect(
      core.connect(alice).decreasePosition(
        positionId,
        SMALL_QUANTITY, // Remove part
        0 // Min payout
      )
    ).to.emit(core, "PositionDecreased");

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.gt(balanceBefore); // Received payout

    const position = await mockPosition.getPosition(positionId);
    expect(position.quantity).to.equal(MEDIUM_QUANTITY - SMALL_QUANTITY);
  });

  it("Should revert decrease of non-existent position", async function () {
    const { core, alice, mockPosition } = await loadFixture(
      createActiveMarketFixture
    );

    await expect(
      core.connect(alice).decreasePosition(
        999, // Non-existent position
        SMALL_QUANTITY,
        0
      )
    ).to.be.revertedWithCustomError(mockPosition, "PositionNotFound");
  });

  it("Should handle zero quantity decrease", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    await expect(
      core.connect(alice).decreasePosition(positionId, 0, 0)
    ).to.be.revertedWithCustomError(core, "InvalidQuantity");
  });

  it("Should handle decrease quantity larger than position", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        SMALL_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    await expect(
      core.connect(alice).decreasePosition(
        positionId,
        MEDIUM_QUANTITY, // Larger than position
        0
      )
    ).to.be.revertedWithCustomError(core, "InsufficientPositionQuantity");
  });

  it("Should handle payout below minimum", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Calculate payout to set unrealistic minimum
    const payout = await core.calculateDecreaseProceeds(
      positionId,
      SMALL_QUANTITY
    );

    await expect(
      core.connect(alice).decreasePosition(
        positionId,
        SMALL_QUANTITY,
        payout + 1n // Set min payout higher than actual
      )
    ).to.be.revertedWithCustomError(core, "ProceedsBelowMinimum");
  });

  it("Should handle paused contract for decrease", async function () {
    const { core, keeper, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position first
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Pause the contract
    await core.connect(keeper).pause("Testing pause");

    await expect(
      core.connect(alice).decreasePosition(positionId, SMALL_QUANTITY, 0)
    ).to.be.revertedWithCustomError(core, "EnforcedPause");
  });

  it("Should calculate decrease payout correctly", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position first
    const tradeParams = {
      marketId: marketId,
      lowerTick: 100450,
      upperTick: 100550,
      quantity: MEDIUM_QUANTITY,
      maxCost: MEDIUM_COST,
    };

    await core
      .connect(alice)
      .openPosition(
        tradeParams.marketId,
        tradeParams.lowerTick,
        tradeParams.upperTick,
        tradeParams.quantity,
        tradeParams.maxCost
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const payout = await core.calculateDecreaseProceeds(
      positionId,
      SMALL_QUANTITY
    );
    expect(payout).to.be.gt(0);
  });

  it("Should handle small partial decreases efficiently", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        ethers.parseUnits("0.1", 6),
        ethers.parseUnits("10", 6)
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Small decrease
    await expect(core.connect(alice).decreasePosition(positionId, 1, 0)).to.not
      .be.reverted;
  });

  it("Should handle sequential decreases", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        ethers.parseUnits("0.1", 6),
        ethers.parseUnits("10", 6)
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // First decrease
    await core.connect(alice).decreasePosition(positionId, SMALL_QUANTITY, 0);

    // Second decrease
    await expect(
      core.connect(alice).decreasePosition(positionId, SMALL_QUANTITY, 0)
    ).to.not.be.reverted;

    const position = await mockPosition.getPosition(positionId);
    expect(position.quantity).to.equal(
      ethers.parseUnits("0.1", 6) - SMALL_QUANTITY - SMALL_QUANTITY
    );
  });

  it("Should handle excessive decrease quantity", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        SMALL_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const excessiveSell = SMALL_QUANTITY + 1n;

    await expect(
      core.connect(alice).decreasePosition(positionId, excessiveSell, 0)
    ).to.be.revertedWithCustomError(core, "InsufficientPositionQuantity");
  });

  it("Uses nearest rounding for decrease proceeds and keeps tree sums non-increasing", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const market = await core.getMarket(marketId);
    const minTick = market.minTick;
    const maxTick = market.maxTick;

    const sellQuantity = 1n;
    const estimatedProceeds = await core.calculateDecreaseProceeds(
      positionId,
      sellQuantity
    );

    const totalBefore = await core.getRangeSum(marketId, minTick, maxTick);

    const tx = await core
      .connect(alice)
      .decreasePosition(positionId, sellQuantity, 0);
    const receipt = await tx.wait();

    const decreasedLog = receipt.logs
      .map((log) => {
        try {
          return core.interface.parseLog(log);
        } catch {
          return undefined;
        }
      })
      .find((parsed) => parsed && parsed.name === "PositionDecreased");

    expect(decreasedLog, "PositionDecreased event not found").to.not.be
      .undefined;
    const actualProceeds = (decreasedLog!.args.proceeds as bigint) ?? 0n;

    const delta =
      actualProceeds >= estimatedProceeds
        ? actualProceeds - estimatedProceeds
        : estimatedProceeds - actualProceeds;
    expect(delta).to.be.lte(1n);

    const totalAfter = await core.getRangeSum(marketId, minTick, maxTick);
    expect(totalAfter).to.be.lte(totalBefore);
  });
});

```


## test/integration/trading/increase.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { createActiveMarketFixture } from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";

describe(`${INTEGRATION_TAG} Position Increase`, function () {
  const SMALL_QUANTITY = ethers.parseUnits("0.01", 6); // 0.01 USDC
  const MEDIUM_QUANTITY = ethers.parseUnits("0.05", 6); // 0.05 USDC
  const MEDIUM_COST = ethers.parseUnits("5", 6); // 5 USDC
  const COST_BUFFER = ethers.parseUnits("100", 6);

  async function quoteIncreaseCost(
    coreContract: any,
    positionId: bigint,
    amount: bigint
  ) {
    const quote = await coreContract.calculateIncreaseCost(positionId, amount);
    return quote + COST_BUFFER;
  }

  it("Should increase position quantity successfully", async function () {
    const { core, alice, paymentToken, mockPosition, marketId } =
      await loadFixture(createActiveMarketFixture);

    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    // Increase position
    await expect(
      core.connect(alice).increasePosition(
        positionId,
        SMALL_QUANTITY, // Add more
        MEDIUM_COST
      )
    ).to.emit(core, "PositionIncreased");

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.lt(balanceBefore); // Paid more

    const position = await mockPosition.getPosition(positionId);
    expect(position.quantity).to.equal(MEDIUM_QUANTITY + SMALL_QUANTITY);
  });

  it("Should revert increase of non-existent position", async function () {
    const { core, alice, mockPosition } = await loadFixture(
      createActiveMarketFixture
    );

    await expect(
      core.connect(alice).increasePosition(
        999, // Non-existent position
        SMALL_QUANTITY,
        MEDIUM_COST
      )
    ).to.be.revertedWithCustomError(mockPosition, "PositionNotFound");
  });

  it("Should handle zero quantity increase", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    await expect(
      core.connect(alice).increasePosition(positionId, 0, 0)
    ).to.be.revertedWithCustomError(core, "InvalidQuantity");
  });

  it("Should handle insufficient max cost for increase", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    await expect(
      core.connect(alice).increasePosition(
        positionId,
        MEDIUM_QUANTITY,
        ethers.parseUnits("0.001", 6) // Very small max cost
      )
    ).to.be.revertedWithCustomError(core, "CostExceedsMaximum");
  });

  // Note: Authorization test removed - Router was removed, positions are now publicly accessible
  // Position operations are allowed from any caller since Router layer was eliminated

  it("Should handle paused contract for increase", async function () {
    const { core, keeper, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position first
    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const increaseAmount = SMALL_QUANTITY;
    const increaseCost = await quoteIncreaseCost(
      core,
      positionId,
      increaseAmount
    );

    // Pause the contract
    await core.connect(keeper).pause("Testing pause");

    await expect(
      core
        .connect(alice)
        .increasePosition(positionId, increaseAmount, increaseCost)
    ).to.be.revertedWithCustomError(core, "EnforcedPause");
  });

  it("Should handle gas-efficient small adjustments", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position
    await core.connect(alice).openPosition(
      marketId,
      100450,
      100550,
      ethers.parseUnits("0.1", 6), // Large quantity
      ethers.parseUnits("10", 6) // Large cost
    );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    // Small increase
    await expect(
      core.connect(alice).increasePosition(positionId, 1, MEDIUM_COST)
    ).to.not.be.reverted;
  });

  it("Should calculate increase cost correctly", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Create position first
    const tradeParams = {
      marketId: marketId,
      lowerTick: 100450, // ÏÉà Ìã± ÏãúÏä§ÌÖú (45Î≤àÏß∏ ‚Üí 100450)
      upperTick: 100550, // ÏÉà Ìã± ÏãúÏä§ÌÖú (55Î≤àÏß∏ ‚Üí 100550)
      quantity: MEDIUM_QUANTITY,
      maxCost: MEDIUM_COST,
    };

    await core
      .connect(alice)
      .openPosition(
        tradeParams.marketId,
        tradeParams.lowerTick,
        tradeParams.upperTick,
        tradeParams.quantity,
        tradeParams.maxCost
      );
    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const cost = await core.calculateIncreaseCost(positionId, SMALL_QUANTITY);
    expect(cost).to.be.gt(0);
  });

  it("Uses nearest rounding with min-one guard and keeps tree sums monotonic when increasing", async function () {
    const { core, alice, mockPosition, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    await core
      .connect(alice)
      .openPosition(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY,
        MEDIUM_COST
      );

    const positions = await mockPosition.getPositionsByOwner(alice.address);
    const positionId = positions[0];

    const market = await core.getMarket(marketId);
    const minTick = market.minTick;
    const maxTick = market.maxTick;

    const additionalQuantity = 1n;
    const estimatedCost = await core.calculateIncreaseCost(
      positionId,
      additionalQuantity
    );
    expect(estimatedCost).to.equal(1n);

    const totalBefore = await core.getRangeSum(marketId, minTick, maxTick);

    const maxCost = estimatedCost + 1n;
    const tx = await core
      .connect(alice)
      .increasePosition(positionId, additionalQuantity, maxCost);
    const receipt = await tx.wait();

    const increasedLog = receipt.logs
      .map((log) => {
        try {
          return core.interface.parseLog(log);
        } catch {
          return undefined;
        }
      })
      .find((parsed) => parsed && parsed.name === "PositionIncreased");

    expect(increasedLog, "PositionIncreased event not found").to.not.be
      .undefined;
    const actualCost = (increasedLog!.args.cost as bigint) ?? 0n;

    expect(actualCost).to.be.gte(1n);
    const delta =
      actualCost >= estimatedCost
        ? actualCost - estimatedCost
        : estimatedCost - actualCost;
    expect(delta).to.be.lte(1n);

    const totalAfter = await core.getRangeSum(marketId, minTick, maxTick);
    expect(totalAfter).to.be.gte(totalBefore);
  });
});

```


## test/integration/trading/open.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  createActiveMarketFixture,
  coreFixture,
  createMarketWithConfig,
  setMarketActivation,
  settleMarketAtTick,
} from "../../helpers/fixtures/core";
import { INTEGRATION_TAG } from "../../helpers/tags";

describe(`${INTEGRATION_TAG} Position Opening`, function () {
  const SMALL_QUANTITY = ethers.parseUnits("0.01", 6); // 0.01 USDC
  const MEDIUM_QUANTITY = ethers.parseUnits("0.05", 6); // 0.05 USDC
  const LARGE_QUANTITY = ethers.parseUnits("0.1", 6); // 0.1 USDC
  const MEDIUM_COST = ethers.parseUnits("5", 6); // 5 USDC
  const TICK_COUNT = 100;

  it("Should reject trading before explicit activation", async function () {
    const contracts = await loadFixture(coreFixture);
    const { core, keeper, alice } = contracts;

    const currentTime = await time.latest();
    const startTime = currentTime + 500;
    const endTime = startTime + 7 * 24 * 60 * 60;
    const marketId = await createMarketWithConfig(core, keeper, {
      minTick: 100000,
      maxTick: 100990,
      tickSpacing: 10,
      startTime,
      endTime,
      liquidityParameter: ethers.parseEther("1"),
    });

    const target = startTime + 1;
    const latestTs = await time.latest();
    await time.increaseTo(target > latestTs ? target : latestTs + 1);

    const quantity = MEDIUM_QUANTITY;
    const cost = await core.calculateOpenCost(marketId, 100450, 100550, quantity);
    const maxCost = cost + ethers.parseUnits("1", 6);

    await expect(
      core
        .connect(alice)
        .openPosition(marketId, 100450, 100550, quantity, maxCost)
    ).to.be.revertedWithCustomError(core, "MarketNotActive");

    await setMarketActivation(core, keeper, marketId, true);

    await expect(
      core
        .connect(alice)
        .openPosition(marketId, 100450, 100550, quantity, maxCost)
    ).to.emit(core, "PositionOpened");
  });

  it("Should open position successfully", async function () {
    const { core, alice, paymentToken, mockPosition, marketId } =
      await loadFixture(createActiveMarketFixture);

    const tradeParams = {
      marketId: marketId,
      lowerTick: 100450, // ÏÉà Ìã± ÏãúÏä§ÌÖú (45Î≤àÏß∏ ‚Üí 100450)
      upperTick: 100550, // ÏÉà Ìã± ÏãúÏä§ÌÖú (55Î≤àÏß∏ ‚Üí 100550)
      quantity: MEDIUM_QUANTITY,
      maxCost: MEDIUM_COST,
    };

    const balanceBefore = await paymentToken.balanceOf(alice.address);

    await expect(
      core
        .connect(alice)
        .openPosition(tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity,
          tradeParams.maxCost
        )
    ).to.emit(core, "PositionOpened");

    expect(await mockPosition.balanceOf(alice.address)).to.equal(1);

    const balanceAfter = await paymentToken.balanceOf(alice.address);
    expect(balanceAfter).to.be.lt(balanceBefore);
  });

  it("Should revert trade with insufficient max cost", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    const tradeParams = {
      marketId: marketId,
      lowerTick: 100450,
      upperTick: 100550,
      quantity: LARGE_QUANTITY, // Large quantity
      maxCost: ethers.parseUnits("0.01", 6), // Very small max cost (6 decimals)
    };

    await expect(
      core
        .connect(alice)
        .openPosition(tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity,
          tradeParams.maxCost
        )
    ).to.be.revertedWithCustomError(core, "CostExceedsMaximum");
  });

  it("Should handle invalid tick range", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    const tradeParams = {
      marketId: marketId,
      lowerTick: 100550, // Upper > Lower
      upperTick: 100450,
      quantity: SMALL_QUANTITY,
      maxCost: MEDIUM_COST,
    };

    await expect(
      core
        .connect(alice)
        .openPosition(tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity,
          tradeParams.maxCost
        )
    ).to.be.revertedWithCustomError(core, "InvalidTickRange");
  });

  it("Should handle zero quantity", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    await expect(
      core
        .connect(alice)
        .openPosition(marketId, 100450, 100550, 0, MEDIUM_COST)
    ).to.be.revertedWithCustomError(core, "InvalidQuantity");
  });

  it("Should handle tick out of bounds", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    await expect(
      core.connect(alice).openPosition(marketId,
        101000, // Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇú Ìã±Í∞í
        101100, // Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇú Ìã±Í∞í
        SMALL_QUANTITY,
        MEDIUM_COST
      )
    ).to.be.revertedWithCustomError(core, "InvalidTick");
  });

  it("Should reject single tick positions", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    await expect(
      core.connect(alice).openPosition(marketId,
        100500, // Ïã§Ï†ú Ìã±Í∞í
        100500, // ÎèôÏùºÌïú Ìã±Í∞í (single tick)
        SMALL_QUANTITY,
        MEDIUM_COST
      )
    ).to.be.revertedWithCustomError(core, "InvalidTickRange");
  });

  it("Should handle boundary tick ranges", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // First tick
    await expect(
      core.connect(alice).openPosition(marketId,
        100000, // Ï≤´ Î≤àÏß∏ Ìã±
        100010,
        SMALL_QUANTITY,
        MEDIUM_COST
      )
    ).to.not.be.reverted;

    // Last tick
    await expect(
      core.connect(alice).openPosition(marketId,
        100980, // ÎßàÏßÄÎßâ Ìã±ÏóêÏÑú ÏµúÏÜå Î≤îÏúÑ ÌôïÎ≥¥
        100990,
        SMALL_QUANTITY,
        MEDIUM_COST
      )
    ).to.not.be.reverted;
  });

  it("Uses nearest rounding with min-one safeguard and keeps tree sums monotonic", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    const market = await core.getMarket(marketId);
    const minTick = market.minTick;
    const maxTick = market.maxTick;

    const quantity = 1n; // 1 micro USDC
    const lowerTick = 100450;
    const upperTick = 100550;

    const estimatedCost = await core.calculateOpenCost(
      marketId,
      lowerTick,
      upperTick,
      quantity
    );
    expect(estimatedCost).to.equal(1n);

    const totalBefore = await core.getRangeSum(marketId, minTick, maxTick);

    const maxCost = estimatedCost + 1n;
    const tx = await core
      .connect(alice)
      .openPosition(marketId, lowerTick, upperTick, quantity, maxCost);
    const receipt = await tx.wait();

    const openedLog = receipt.logs
      .map((log) => {
        try {
          return core.interface.parseLog(log);
        } catch {
          return undefined;
        }
      })
      .find((parsed) => parsed && parsed.name === "PositionOpened");

    expect(openedLog, "PositionOpened event not found").to.not.be.undefined;
    const actualCost = (openedLog!.args.cost as bigint) ?? 0n;

    expect(actualCost).to.be.gte(1n);
    const delta =
      actualCost >= estimatedCost
        ? actualCost - estimatedCost
        : estimatedCost - actualCost;
    expect(delta).to.be.lte(1n);

    const totalAfter = await core.getRangeSum(marketId, minTick, maxTick);
    expect(totalAfter).to.be.gte(totalBefore);
  });

  // Note: Authorization test removed - Router was removed, all users can now directly access Core
  // openPosition is now public since Router authorization layer was eliminated

  it("Should handle paused contract", async function () {
    const { core, keeper, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Pause contract
    await core.connect(keeper).pause("Test pause");

    await expect(
      core
        .connect(alice)
        .openPosition(marketId,
          100450,
          100550,
          MEDIUM_QUANTITY,
          MEDIUM_COST
        )
    ).to.be.revertedWithCustomError(core, "EnforcedPause");
  });

  it("Should handle invalid market ID", async function () {
    const { core, alice } = await loadFixture(createActiveMarketFixture);

    await expect(
      core
        .connect(alice)
        .openPosition(999, 45, 55, MEDIUM_QUANTITY, MEDIUM_COST)
    ).to.be.revertedWithCustomError(core, "MarketNotFound");
  });

  it("Should test 1 wei precision slippage protection", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Calculate exact cost
    const exactCost = await core.calculateOpenCost(
      marketId,
      100450,
      100550,
      SMALL_QUANTITY
    );

    // Test with maxCost exactly 1 wei less than needed

    await expect(
      core
        .connect(alice)
        .openPosition(marketId,
          100450,
          100550,
          SMALL_QUANTITY,
          exactCost - 1n
        )
    ).to.be.revertedWithCustomError(core, "CostExceedsMaximum");

    // Test with exact cost should succeed

    await expect(
      core
        .connect(alice)
        .openPosition(marketId,
          100450,
          100550,
          SMALL_QUANTITY,
          exactCost
        )
    ).to.not.be.reverted;
  });

  it("Should handle large quantity trades with chunking", async function () {
    const { core, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    const largeQuantity = ethers.parseUnits("10", 6);
    const quotedCost = await core.calculateOpenCost(
      marketId,
      100000,
      100990,
      largeQuantity
    );
    const largeCost = quotedCost + ethers.parseUnits("1000", 6);

    await expect(
      core
        .connect(alice)
        .openPosition(marketId,
          100000,
          100990,
          largeQuantity,
          largeCost
        )
    ).to.emit(core, "PositionOpened");
  });

  it("Should handle settled market trades", async function () {
    const { core, keeper, alice, marketId } = await loadFixture(
      createActiveMarketFixture
    );

    // Settle market first
    await settleMarketAtTick(core, keeper, marketId, 100490);

    await expect(
      core
        .connect(alice)
        .openPosition(marketId,
          100450,
          100550,
          ethers.parseUnits("0.05", 6),
          ethers.parseUnits("5", 6)
        )
    ).to.be.revertedWithCustomError(core, "MarketNotActive");
  });
});

```


## test/e2e/scenarios/high-liquidity.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  setupHighLiquidityMarket,
  settleMarketAtTick,
  advanceToClaimOpen,
} from "../../helpers/fixtures/core";
import { E2E_TAG } from "../../helpers/tags";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

describeMaybe(`${E2E_TAG} High Liquidity Market Scenarios`, function () {
  const HIGH_ALPHA = ethers.parseEther("10"); // High liquidity parameter
  const TICK_COUNT = 100;
  const MARKET_DURATION = 7 * 24 * 60 * 60; // 7 days
  const USDC_DECIMALS = 6;

  // Large trading amounts for high liquidity scenarios
  // With alpha=10, max safe chunk = 1.3 ETH ‚âà $130, and MAX_CHUNKS_PER_TX=100
  // So max quantity = 130 * 100 = $13,000, but we use much smaller for efficiency
  const LARGE_QUANTITY = ethers.parseUnits("5", USDC_DECIMALS); // $5 - sizable chunk post-updates
  const HUGE_QUANTITY = ethers.parseUnits("10", USDC_DECIMALS); // $10 - larger chunk
  const EXTREME_QUANTITY = ethers.parseUnits("15", USDC_DECIMALS); // $15 - stress edge
  const COST_BUFFER_BPS = 50n; // 0.5%
  const BPS_DENOMINATOR = 10000n;

  const applyBuffer = (amount: bigint, buffer: bigint = COST_BUFFER_BPS) =>
    (amount * (BPS_DENOMINATOR + buffer)) / BPS_DENOMINATOR + 1n;

  const openWithBuffer = async (
    core: any,
    signer: any,
    marketId: number,
    lowerTick: number,
    upperTick: number,
    quantity: bigint,
    buffer: bigint = COST_BUFFER_BPS
  ) => {
    const cost = await core.calculateOpenCost(
      marketId,
      lowerTick,
      upperTick,
      quantity
    );
    return core
      .connect(signer)
      .openPosition(
        marketId,
        lowerTick,
        upperTick,
        quantity,
        applyBuffer(cost, buffer)
      );
  };

  async function createHighLiquidityMarket() {
    const contracts = await loadFixture(coreFixture);
    const { marketId, startTime, endTime } = await setupHighLiquidityMarket(
      contracts
    );
    return {
      ...contracts,
      marketId,
      startTime,
      endTime,
      mockPosition: contracts.mockPosition,
    };
  }

  describe("Large Volume Trading", function () {
    it("Should handle institutional-size trades efficiently", async function () {
      const { core, alice, marketId } = await loadFixture(
        createHighLiquidityMarket
      );

      // Simulate institutional trade near chunk boundary ($120)
      const tradeParams = {
        marketId,
        lowerTick: 100200, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        upperTick: 100800, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        quantity: EXTREME_QUANTITY,
      };

      const costBefore = await core.calculateOpenCost(
        marketId,
        tradeParams.lowerTick,
        tradeParams.upperTick,
        tradeParams.quantity
      );
      const maxCost = applyBuffer(costBefore);

      const tx = await core
        .connect(alice)
        .openPosition(
          tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity,
          maxCost
        );
      const receipt = await tx.wait();

      console.log(`Institutional trade gas: ${receipt!.gasUsed}`);
      console.log(
        `Trade cost: $${ethers.formatUnits(costBefore, USDC_DECIMALS)}`
      );

      // High liquidity should keep slippage reasonable even for large trades
      const slippage = (costBefore * 100n) / tradeParams.quantity;
      console.log(`Effective slippage: ${ethers.formatEther(slippage)}%`);

      // With high alpha, slippage should be minimal
      expect(slippage).to.be.lt(ethers.parseEther("5")); // Less than 5% slippage

      // Should complete without reverting
      expect(receipt!.status).to.equal(1);
    });

    it("Should support multiple large concurrent positions", async function () {
      const { core, alice, bob, charlie, marketId, mockPosition } =
        await loadFixture(createHighLiquidityMarket);

      const traders = [alice, bob, charlie];
      const ranges = [
        { lower: 100100, upper: 100900 },
        { lower: 100200, upper: 100800 },
        { lower: 100300, upper: 100700 },
      ];
      const positions: number[] = [];

      // Each trader opens a large position
      for (let i = 0; i < traders.length; i++) {
        const trader = traders[i];
        const { lower, upper } = ranges[i % ranges.length];

        const tradeParams = {
          marketId,
          lowerTick: lower,
          upperTick: upper,
          quantity: LARGE_QUANTITY,
        };

        const quotedCost = await core.calculateOpenCost(
          tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity
        );

        await core
          .connect(trader)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            applyBuffer(quotedCost)
          );

        const traderPositions = await mockPosition.getPositionsByOwner(
          trader.address
        );
        positions.push(Number(traderPositions[traderPositions.length - 1]));

        console.log(
          `Trader ${i + 1} opened position ${i + 1} with $${ethers.formatUnits(
            LARGE_QUANTITY,
            USDC_DECIMALS
          )}`
        );
      }

      // Verify all positions exist and are profitable
      for (let i = 0; i < positions.length; i++) {
        const position = await mockPosition.getPosition(positions[i]);
        expect(position.quantity).to.be.gt(0);

        console.log(
          `Position ${i + 1} quantity: ${ethers.formatUnits(
            position.quantity,
            USDC_DECIMALS
          )}`
        );
      }

      // Market should remain stable
      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;
    });

    it("Should maintain price stability under high volume", async function () {
      const { core, alice, bob, marketId } = await loadFixture(
        createHighLiquidityMarket
      );

      // Record initial prices
      const reducedQuantity = ethers.parseUnits("5", USDC_DECIMALS); // Smaller volume aligning with new curve
      const initialBuyCost = await core.calculateOpenCost(
        marketId,
        100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        reducedQuantity
      );

      // Execute multiple trades - reduced volume to prevent LazyFactorOverflow
      const trades = [];
      for (let i = 0; i < 5; i++) {
        // Reduced from 10 to 5 trades
        const tradeParams = {
          marketId,
          lowerTick: 100400 + (i % 3) * 10,
          upperTick: 100600 - (i % 3) * 10,
          quantity: reducedQuantity,
        };

        const quotedCost = await core.calculateOpenCost(
          tradeParams.marketId,
          tradeParams.lowerTick,
          tradeParams.upperTick,
          tradeParams.quantity
        );

        await core
          .connect(alice)
          .openPosition(
            tradeParams.marketId,
            tradeParams.lowerTick,
            tradeParams.upperTick,
            tradeParams.quantity,
            applyBuffer(quotedCost)
          );
        trades.push(i + 1);
      }

      // Check price after high volume
      const finalBuyCost = await core.calculateOpenCost(
        marketId,
        100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        reducedQuantity
      );

      const priceImpact =
        finalBuyCost > initialBuyCost
          ? ((finalBuyCost - initialBuyCost) * 100n) / initialBuyCost
          : ((initialBuyCost - finalBuyCost) * 100n) / initialBuyCost;

      console.log(
        `Price impact after high volume: ${ethers.formatEther(priceImpact)}%`
      );

      // High liquidity should limit price impact
      expect(priceImpact).to.be.lt(ethers.parseEther("20")); // Less than 20% price impact
    });
  });

  describe("Market Maker Activity", function () {
    it("Should support high-frequency market making", async function () {
      const { core, alice, bob, marketId } = await loadFixture(
        createHighLiquidityMarket
      );

      const marketMakerTrades = 20; // Reduced from 50 to prevent LazyFactorOverflow
      const tradeSize = ethers.parseUnits("5", USDC_DECIMALS); // $5 per trade - reduced

      let totalGasUsed = 0n;

      // Simulate market maker placing many small trades
      for (let i = 0; i < marketMakerTrades; i++) {
        const spread = 2; // 2 tick spread
        const midTick = 100500; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©

        // Place bid
        const bidCost = await core.calculateOpenCost(
          marketId,
          midTick - spread * 10 - 10,
          midTick - 10,
          tradeSize
        );
        const bidTx = await core.connect(alice).openPosition(
          marketId,
          midTick - spread * 10 - 10,
          midTick - 10,
          tradeSize,
          applyBuffer(bidCost)
        );
        totalGasUsed += (await bidTx.wait())!.gasUsed;

        // Place ask (counter-trade)
        const askCost = await core.calculateOpenCost(
          marketId,
          midTick + 10,
          midTick + spread * 10 + 10,
          tradeSize
        );
        const askTx = await core.connect(bob).openPosition(
          marketId,
          midTick + 10,
          midTick + spread * 10 + 10,
          tradeSize,
          applyBuffer(askCost)
        );
        totalGasUsed += (await askTx.wait())!.gasUsed;
      }

      const avgGasPerTrade = totalGasUsed / BigInt(marketMakerTrades * 2);
      console.log(`Market maker average gas per trade: ${avgGasPerTrade}`);

      // High-frequency trading should be gas efficient
      expect(avgGasPerTrade).to.be.lt(1300000); // Less than 300k gas per trade

      // Market should remain stable
      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;
    });

    it("Should handle rapid position adjustments", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(
        createHighLiquidityMarket
      );

      // Open initial large position
      const baseOpenCost = await core.calculateOpenCost(
        marketId,
        100300,
        100700,
        LARGE_QUANTITY
      );

      await core.connect(alice).openPosition(
        marketId,
        100300,
        100700,
        LARGE_QUANTITY,
        applyBuffer(baseOpenCost)
      );

      // Get actual position ID from MockPosition
      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);
      const adjustmentSize = ethers.parseUnits("1", USDC_DECIMALS);

      // Rapidly increase and decrease position
      for (let i = 0; i < 10; i++) {
        if (i % 2 === 0) {
          // Increase position
          const increaseCost = await core.calculateIncreaseCost(
            positionId,
            adjustmentSize
          );

          await core
            .connect(alice)
            .increasePosition(
              positionId,
              adjustmentSize,
              applyBuffer(increaseCost)
            );
        } else {
          // Decrease position
          await core
            .connect(alice)
            .decreasePosition(positionId, adjustmentSize, 0);
        }
      }

      // Position should still exist and be manageable
      const position = await mockPosition.getPosition(positionId);
      expect(position.quantity).to.be.gt(LARGE_QUANTITY / 2n); // Still substantial

      console.log(
        `Final position size: $${ethers.formatUnits(
          position.quantity,
          USDC_DECIMALS
        )}`
      );
    });
  });

  describe("Stress Testing Under Load", function () {
    it("Should maintain performance under concurrent high-volume trades", async function () {
      const { core, alice, bob, charlie, marketId } = await loadFixture(
        createHighLiquidityMarket
      );

      const traders = [alice, bob, charlie];
      const concurrentTrades = 5; // Reduced from potentially higher number
      const tradeSize = ethers.parseUnits("15", USDC_DECIMALS); // $15 - small for parallel execution
      const tradePromises: Promise<any>[] = [];

      console.log(`Starting ${concurrentTrades} concurrent trades...`);
      const startTime = Date.now();

      const tradeRanges = [
        { lower: 100300, upper: 100700 },
        { lower: 100250, upper: 100650 },
        { lower: 100200, upper: 100600 },
        { lower: 100150, upper: 100550 },
        { lower: 100100, upper: 100500 },
      ];

      for (let i = 0; i < concurrentTrades; i++) {
        const trader = traders[i % traders.length];
        const range = tradeRanges[i % tradeRanges.length];
        tradePromises.push(
          openWithBuffer(
            core,
            trader,
            marketId,
            range.lower,
            range.upper,
            tradeSize,
            10000n // 100% buffer to absorb concurrent slippage
          )
        );
      }

      // Wait for all trades to complete
      const results = await Promise.all(tradePromises);
      const endTime = Date.now();

      console.log(
        `${concurrentTrades} trades completed in ${endTime - startTime}ms`
      );

      // All trades should succeed
      for (const tx of results) {
        const receipt = await tx.wait();
        expect(receipt!.status).to.equal(1);
      }

      // Market should remain stable
      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;
    });

    it("Should handle whale trade followed by many small trades", async function () {
      const { core, alice, bob, marketId } = await loadFixture(
        createHighLiquidityMarket
      );

      // Whale trade: $15 position (reduced for updated curve)
      const whaleQuantity = EXTREME_QUANTITY;
      const whaleCost = await core.calculateOpenCost(
        marketId,
        100100,
        100900,
        whaleQuantity
      );
      await core.connect(alice).openPosition(
        marketId,
        100100,
        100900,
        whaleQuantity,
        applyBuffer(whaleCost)
      );

      console.log(
        `Whale position opened: $${ethers.formatUnits(
          whaleQuantity,
          USDC_DECIMALS
        )}`
      );

      // Many small trades after whale trade
      const smallTradeSize = ethers.parseUnits("1", USDC_DECIMALS); // $1
      const smallTrades = 100;

      for (let i = 0; i < smallTrades; i++) {
        const lowerTick = 100400 + (i % 10) * 10;
        const upperTick = 100600 - (i % 10) * 10;
        const smallCost = await core.calculateOpenCost(
          marketId,
          lowerTick,
          upperTick,
          smallTradeSize
        );

        await core.connect(bob).openPosition(
          marketId,
          lowerTick,
          upperTick,
          smallTradeSize,
          applyBuffer(smallCost)
        );
      }

      console.log(`${smallTrades} small trades completed after whale trade`);

      // Market should still be functional
      const finalCost = await core.calculateOpenCost(
        marketId,
        100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        smallTradeSize
      );
      expect(finalCost).to.be.gt(0);

      console.log(
        `Final trade cost: $${ethers.formatUnits(finalCost, USDC_DECIMALS)}`
      );
    });
  });

  describe("High Liquidity Market Settlement", function () {
    it("Should settle high-volume market efficiently", async function () {
      const { core, keeper, alice, bob, charlie, marketId } = await loadFixture(
        createHighLiquidityMarket
      );

      // Create moderate volume before settlement - reduced to prevent LazyFactorOverflow
      const traders = [alice, bob, charlie];
      const positionsPerTrader = 3; // Reduced from 10 to 3
      const settlementQuantity = ethers.parseUnits("5", USDC_DECIMALS); // $5 - reduced for stability

      for (let i = 0; i < traders.length; i++) {
        const trader = traders[i];
        for (let j = 0; j < positionsPerTrader; j++) {
          const lowerTick = 100100 + j * 100;
          const upperTick = 100900 - j * 100;
          await openWithBuffer(
            core,
            trader,
            marketId,
            lowerTick,
            upperTick,
            settlementQuantity
          );
        }
      }

      console.log(
        `Created ${
          traders.length * positionsPerTrader
        } moderate-value positions`
      );

      // Fast forward to settlement time
      const market = await core.getMarket(marketId);
      await time.increaseTo(Number(market.endTimestamp) + 1);

      // Settle market
      const settlementTx = await settleMarketAtTick(core, keeper, marketId, 100415); // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© Ï§ëÍ∞Ñ Ìã±
      const settlementReceipt = await settlementTx.wait();

      console.log(`Settlement gas used: ${settlementReceipt!.gasUsed}`);

      // Settlement should complete efficiently even with high volume
      expect(settlementReceipt!.gasUsed).to.be.lt(1500000); // Less than 1500k gas
      expect(settlementReceipt!.status).to.equal(1);

      // Verify settlement
      const settledMarket = await core.getMarket(marketId);
      expect(settledMarket.settled).to.be.true;
    });

    it("Should handle mass claiming after high-volume settlement", async function () {
      const { core, keeper, alice, bob, charlie, marketId, mockPosition } =
        await loadFixture(createHighLiquidityMarket);

      // Create many positions
      const traders = [alice, bob, charlie];
      const positionsToClaim: { owner: any; positionId: number }[] = [];

      const claimingQuantity = ethers.parseUnits("5", USDC_DECIMALS);
      for (let i = 0; i < 9; i++) {
        // Reduced from 15 to 9
        const trader = traders[i % traders.length];
        await openWithBuffer(
          core,
          trader,
          marketId,
          100100 + i * 30,
          100500 + i * 30,
          claimingQuantity,
          500n
        );
        // Get position ID from MockPosition - use trader's position list
        const traderPositions = await mockPosition.getPositionsByOwner(
          trader.address
        );
        if (traderPositions.length > 0) {
          const positionId = Number(
            traderPositions[traderPositions.length - 1]
          );
          positionsToClaim.push({ owner: trader, positionId });
        }
      }

      // Settle market
      const market = await core.getMarket(marketId);
      await time.increaseTo(Number(market.endTimestamp) + 1);
      await settleMarketAtTick(core, keeper, marketId, 100495); // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö© Ï§ëÍ∞Ñ Ìã±
      await advanceToClaimOpen(core, marketId);

      // Mass claiming
      let totalClaimGas = 0n;
      const claimResults: bigint[] = [];

      for (const { owner, positionId } of positionsToClaim) {
        try {
          const expectedPayout = await core.calculateClaimAmount(positionId);
          const claimTx = await core.connect(owner).claimPayout(positionId);
          const claimReceipt = await claimTx.wait();
          totalClaimGas += claimReceipt!.gasUsed;

          claimResults.push(expectedPayout);
        } catch (error: any) {
          if (error.message.includes("PositionNotFound")) {
            console.log(
              `Position ${positionId} not found (may have been closed)`
            );
            continue;
          }
          throw error;
        }
      }

      if (claimResults.length > 0) {
        const avgClaimGas = totalClaimGas / BigInt(claimResults.length);
        console.log(`Average claim gas: ${avgClaimGas}`);
        console.log(
          `Total payouts: $${ethers.formatUnits(
            claimResults.reduce((a, b) => a + b, 0n),
            USDC_DECIMALS
          )}`
        );

        // Claims should be efficient
        expect(avgClaimGas).to.be.lt(500000); // Less than 500k gas per claim

        // All positions should have payouts
        for (const payout of claimResults) {
          expect(payout).to.be.gt(0);
        }
      } else {
        console.log("No positions available for claiming");
        // Test still passes - this is acceptable behavior
        expect(true).to.be.true;
      }
    });
  });

  describe("High Liquidity Edge Cases", function () {
    it("Should handle maximum position sizes gracefully", async function () {
      const { core, alice, marketId } = await loadFixture(
        createHighLiquidityMarket
      );

      // Try to open large position within chunk limits
      const maxQuantity = ethers.parseUnits("400", USDC_DECIMALS); // $400 - large but manageable

      try {
        const costEstimate = await core.calculateOpenCost(
          marketId,
          100000, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100990, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          maxQuantity
        );
        console.log(
          `$400 position would cost: $${ethers.formatUnits(
            costEstimate,
            USDC_DECIMALS
          )}`
        );

        // If it doesn't revert, the high liquidity is working
        await core.connect(alice).openPosition(
          marketId,
          100000, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100990, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          maxQuantity,
          costEstimate
        );

        console.log("Large position opened successfully");
      } catch (error) {
        // This might revert due to practical limits, which is acceptable
        console.log("Large position hit practical limits (expected)");
        expect(error).to.be.ok;
      }
    });

    it("Should maintain precision under extreme volumes", async function () {
      const { core, alice, bob, marketId } = await loadFixture(
        createHighLiquidityMarket
      );

      // Create moderate volume through medium trades - reduced to prevent LazyFactorOverflow
      const extremeTrades = 20; // Reduced from 50 to 20
      const tradeSize = ethers.parseUnits("2", USDC_DECIMALS); // $2 each for stability

      let totalVolume = 0n;

      for (let i = 0; i < extremeTrades; i++) {
        const lowerTick = 100300 + (i % 20) * 10;
        const upperTick = 100700 - (i % 20) * 10;
        await openWithBuffer(
          core,
          alice,
          marketId,
          lowerTick,
          upperTick,
          tradeSize,
          500n
        );
        totalVolume += tradeSize;
      }

      console.log(
        `Total volume: $${ethers.formatUnits(totalVolume, USDC_DECIMALS)}`
      );

      // Check precision is maintained
      const smallTradeCost = await core.calculateOpenCost(
        marketId,
        100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        ethers.parseUnits("1", USDC_DECIMALS)
      );

      // Should still be able to calculate small trades precisely
      expect(smallTradeCost).to.be.gt(0);
      expect(smallTradeCost).to.be.lt(ethers.parseUnits("100", USDC_DECIMALS)); // Reasonable cost

      console.log(
        `Small trade cost after extreme volume: $${ethers.formatUnits(
          smallTradeCost,
          USDC_DECIMALS
        )}`
      );
    });
  });
});

```


## test/e2e/scenarios/low-liquidity.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import { coreFixture, setupCustomMarket, settleMarketAtTick, advanceToClaimOpen } from "../../helpers/fixtures/core";
import { E2E_TAG } from "../../helpers/tags";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

const USDC_DECIMALS = 6;
const SCALE_DIFF = 1_000_000_000_000n; // 1e12 for 6 -> 18 decimal conversions
const WAD = 1_000_000_000_000_000_000n;
const MAX_EXP_INPUT_WAD = 1_000_000_000_000_000_000n;
const COST_BUFFER_BPS = 2_000n; // 20% buffer
const BPS_DENOMINATOR = 10_000n;
const LOW_ALPHA = ethers.parseEther("0.05"); // Very thin liquidity (~$15 depth)

const MARKET_MIN_TICK = 100000;
const TICK_SPACING = 10;
const NARROW_RANGE = {
  lower: MARKET_MIN_TICK + 20,
  upper: MARKET_MIN_TICK + 40,
};
const WIDE_RANGE = {
  lower: MARKET_MIN_TICK + 10,
  upper: MARKET_MIN_TICK + 90,
};
const SETTLEMENT_TICK = MARKET_MIN_TICK + 10;

const applyBuffer = (amount: bigint, buffer: bigint = COST_BUFFER_BPS) =>
  ((amount * (BPS_DENOMINATOR + buffer)) / BPS_DENOMINATOR) + 1n;

function maxSafeChunkQuantity(alpha: bigint): bigint {
  const raw = ((alpha * MAX_EXP_INPUT_WAD) / WAD) - 1n;
  if (raw <= 0) {
    return 0n;
  }
  const quantized = raw - (raw % SCALE_DIFF);
  return quantized !== 0n ? quantized : raw;
}

async function createLowLiquidityMarket() {
  const contracts = await loadFixture(coreFixture);
  const { marketId } = await setupCustomMarket(contracts, {
    alpha: LOW_ALPHA,
  });

  return {
    ...contracts,
    marketId,
  };
}

describeMaybe(`${E2E_TAG} Low Liquidity Market Scenarios`, function () {
  this.timeout(120_000);

  describe("Trading behaviour under thin depth", function () {
    it("exhibits superlinear price impact as size increases", async function () {
      const { core, marketId, alice } = await loadFixture(createLowLiquidityMarket);

      const lowerTick = NARROW_RANGE.lower;
      const upperTick = NARROW_RANGE.upper;
      const smallQty = ethers.parseUnits("0.1", USDC_DECIMALS);
      const mediumQty = ethers.parseUnits("0.5", USDC_DECIMALS);
      const largeQty = ethers.parseUnits("1", USDC_DECIMALS);

      const smallCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        smallQty
      );
      const mediumCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        mediumQty
      );
      const largeCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        largeQty
      );

      // Average price should increase with trade size (slippage)
      expect(mediumCost * smallQty).to.be.gt(smallCost * mediumQty);
      expect(largeCost * mediumQty).to.be.gt(mediumCost * largeQty);

      await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          mediumQty,
          applyBuffer(mediumCost)
        );
    });

    it("rejects jumbo orders via chunk limit guardrails", async function () {
      const { core, marketId, alice } = await loadFixture(createLowLiquidityMarket);

      const lowerTick = WIDE_RANGE.lower;
      const upperTick = WIDE_RANGE.upper;
      const extremeQuantity = ethers.parseUnits("50000000", USDC_DECIMALS); // $50m notional

      const chunkSize = maxSafeChunkQuantity(LOW_ALPHA);
      const quantityWad = extremeQuantity * SCALE_DIFF;
      const requiredChunks = (quantityWad + chunkSize - 1n) / chunkSize;

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            lowerTick,
            upperTick,
            extremeQuantity,
            ethers.MaxUint256
          )
      )
        .to.be.revertedWithCustomError(core, "ChunkLimitExceeded")
        .withArgs(requiredChunks, 1000n);
    });

    it("protects traders when maxCost is underestimated", async function () {
      const { core, marketId, alice } = await loadFixture(createLowLiquidityMarket);

      const lowerTick = NARROW_RANGE.lower;
      const upperTick = NARROW_RANGE.upper;
      const quantity = ethers.parseUnits("0.5", USDC_DECIMALS);

      const quotedCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );

      const underQuotedMaxCost = quotedCost - quotedCost / 5n; // 20% shortfall

      await expect(
        core
          .connect(alice)
          .openPosition(
            marketId,
            lowerTick,
            upperTick,
            quantity,
            underQuotedMaxCost
          )
      ).to.be.revertedWithCustomError(core, "CostExceedsMaximum");
    });
  });

  describe("Lifecycle resilience", function () {
    it("settles markets and allows claims despite thin liquidity", async function () {
      const { core, mockPosition, keeper, alice, bob, marketId } =
        await loadFixture(createLowLiquidityMarket);

      const lowerTick = WIDE_RANGE.lower;
      const upperTick = WIDE_RANGE.upper;

      const aliceQty = ethers.parseUnits("0.2", USDC_DECIMALS);
      const bobQty = ethers.parseUnits("0.3", USDC_DECIMALS);

      const aliceCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        aliceQty
      );
      const bobCost = await core.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        bobQty
      );

      const aliceTx = await core
        .connect(alice)
        .openPosition(
          marketId,
          lowerTick,
          upperTick,
          aliceQty,
          applyBuffer(aliceCost, 5_000n) // 50% buffer for stability
        );
      await aliceTx.wait();

      const bobTx = await core
        .connect(bob)
        .openPosition(
          marketId,
          lowerTick + 20,
          upperTick - 20,
          bobQty,
          applyBuffer(bobCost, 5_000n)
        );
      await bobTx.wait();

      const alicePositions = await mockPosition.getPositionsByOwner(alice.address);
      expect(alicePositions.length).to.be.gte(1);
      const alicePositionId = alicePositions[0];

      await time.increase(7 * 24 * 60 * 60 + 3600);
      await settleMarketAtTick(core, keeper, marketId, SETTLEMENT_TICK);
      await advanceToClaimOpen(core, marketId);

      const market = await core.getMarket(marketId);
      expect(market.settled).to.be.true;

      const previewPayout = await core
        .connect(alice)
        .claimPayout.staticCall(alicePositionId);
      expect(previewPayout).to.be.gte(0n);

      await expect(
        core.connect(alice).claimPayout(alicePositionId)
      ).to.emit(core, "PositionClaimed");

      expect(await mockPosition.exists(alicePositionId)).to.be.false;

      const bobPositions = await mockPosition.getPositionsByOwner(bob.address);
      for (const positionId of bobPositions) {
        expect(await mockPosition.exists(positionId)).to.be.true;
      }
    });
  });
});

```


## test/e2e/scenarios/normal-lifecycle.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { E2E_TAG } from "../../helpers/tags";
const describeMaybe = process.env.COVERAGE ? describe.skip : describe;
import {
  createActiveMarketFixture,
  settleMarketAtTick,
  advanceToClaimOpen,
} from "../../helpers/fixtures/core";

describeMaybe(`${E2E_TAG} Normal Market Lifecycle`, function () {
  const SMALL_QUANTITY = ethers.parseUnits("0.01", 6); // 0.01 USDC
  const MEDIUM_QUANTITY = ethers.parseUnits("0.1", 6); // 0.1 USDC
  const LARGE_QUANTITY = ethers.parseUnits("0.5", 6); // 0.5 USDC
  const COST_BUFFER_BPS = 50n;
  const BPS_DENOMINATOR = 10000n;

  const applyBuffer = (amount: bigint, buffer: bigint = COST_BUFFER_BPS) =>
    (amount * (BPS_DENOMINATOR + buffer)) / BPS_DENOMINATOR + 1n;

  const openWithBuffer = async (
    core: any,
    signer: any,
    marketId: number,
    lowerTick: number,
    upperTick: number,
    quantity: bigint,
    buffer: bigint = COST_BUFFER_BPS
  ) => {
    const cost = await core.calculateOpenCost(
      marketId,
      lowerTick,
      upperTick,
      quantity
    );
    return core
      .connect(signer)
      .openPosition(
        marketId,
        lowerTick,
        upperTick,
        quantity,
        applyBuffer(cost, buffer)
      );
  };
  const TICK_COUNT = 100;

  async function createMarketLifecycleFixture() {
    const contracts = await loadFixture(createActiveMarketFixture);
    const { marketId, startTime, endTime } = contracts;
    return {
      ...contracts,
      marketId,
      startTime,
      endTime,
      mockPosition: contracts.mockPosition,
    };
  }

  describe("Complete Market Lifecycle", function () {
    it("Should handle complete market lifecycle with multiple participants", async function () {
      const {
        core,
        keeper,
        alice,
        bob,
        charlie,
        paymentToken,
        mockPosition,
        marketId,
        startTime,
        endTime,
      } = await loadFixture(createMarketLifecycleFixture);

      // Phase 1: Market is already active since we use setupActiveMarket
      let market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;

      // Can calculate costs
      const premarketCost = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        MEDIUM_QUANTITY
      );
      expect(premarketCost).to.be.gt(0);

      // Phase 2: Early trading phase - Alice opens positions
      const alicePositions = [];

      // Alice creates multiple positions
      for (let i = 0; i < 3; i++) {
        await openWithBuffer(
          core,
          alice,
          marketId,
          100200 + i * 100,
          100250 + i * 100,
          MEDIUM_QUANTITY
        );
      }

      const alicePositionList = await mockPosition.getPositionsByOwner(
        alice.address
      );
      expect(alicePositionList.length).to.equal(3);

      // Phase 3: Mid-market activity - Bob and Charlie join
      await time.increaseTo(startTime + 2 * 24 * 60 * 60); // 2 days later

      // Bob creates overlapping positions
      await openWithBuffer(
        core,
        bob,
        marketId,
        100250,
        100750,
        LARGE_QUANTITY,
        2000n
      );

      // Charlie creates focused position
      await openWithBuffer(
        core,
        charlie,
        marketId,
        100480,
        100520,
        MEDIUM_QUANTITY
      );

      // Phase 4: Position adjustments
      const bobPositions = await mockPosition.getPositionsByOwner(bob.address);
      const bobPositionId = bobPositions[0];

      // Bob increases his position
      const bobIncreaseCost = await core.calculateIncreaseCost(
        bobPositionId,
        MEDIUM_QUANTITY
      );

      await core
        .connect(bob)
        .increasePosition(
          bobPositionId,
          MEDIUM_QUANTITY,
          applyBuffer(bobIncreaseCost, 2000n)
        );

      // Alice decreases one of her positions
      const alicePositionId = alicePositionList[0];
      await core
        .connect(alice)
        .decreasePosition(alicePositionId, SMALL_QUANTITY, 0);

      // Phase 6: Some users exit early
      await time.increaseTo(startTime + 5 * 24 * 60 * 60); // 5 days later

      // Charlie closes his position
      const charliePositions = await mockPosition.getPositionsByOwner(
        charlie.address
      );
      const charlieInitialBalance = await paymentToken.balanceOf(
        charlie.address
      );

      await core.connect(charlie).closePosition(charliePositions[0], 0);

      const charlieFinalBalance = await paymentToken.balanceOf(charlie.address);
      expect(charlieFinalBalance).to.be.gt(charlieInitialBalance);

      // Phase 6: Market ends
      await time.increaseTo(endTime + 1);
      market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true; // Market remains active until settlement

      // Phase 7: Settlement
      const settlementTick = 100495; // Midpoint around Charlie's position
      await settleMarketAtTick(core, keeper, marketId, settlementTick);
      await advanceToClaimOpen(core, marketId);

      // Phase 8: Claims phase
      // Bob should win since his range included tick 100500
      const bobFinalPositions = await mockPosition.getPositionsByOwner(
        bob.address
      );
      const bobBalanceBefore = await paymentToken.balanceOf(bob.address);

      await core.connect(bob).claimPayout(bobFinalPositions[0]);

      const bobBalanceAfter = await paymentToken.balanceOf(bob.address);
      expect(bobBalanceAfter).to.be.gt(bobBalanceBefore);

      // Alice should get partial payouts (some positions may include winning tick)
      const aliceFinalPositions = await mockPosition.getPositionsByOwner(
        alice.address
      );
      let aliceClaimedAny = false;

      for (const positionId of aliceFinalPositions) {
        try {
          const balanceBefore = await paymentToken.balanceOf(alice.address);
          await core.connect(alice).claimPayout(positionId);
          const balanceAfter = await paymentToken.balanceOf(alice.address);
          if (balanceAfter > balanceBefore) {
            aliceClaimedAny = true;
          }
        } catch (error) {
          // Some positions may have no payout
        }
      }

      // Verify market integrity
      const finalMarket = await core.getMarket(marketId);
      expect(finalMarket.isActive).to.be.false;
    });

    it("Should handle market with no trading activity", async function () {
      const { core, keeper, marketId, startTime, endTime } = await loadFixture(
        createMarketLifecycleFixture
      );

      // Go through entire lifecycle without trading
      await time.increaseTo(startTime + 10);
      await time.increaseTo(endTime + 10);

      // Should still be able to settle
      await settleMarketAtTick(core, keeper, marketId, 100490);

      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.false;
    });

    it("Should handle single participant market", async function () {
      const {
        core,
        keeper,
        alice,
        paymentToken,
        mockPosition,
        marketId,
        startTime,
        endTime,
      } = await loadFixture(createMarketLifecycleFixture);

      await time.increaseTo(startTime + 10);

      // Alice is the only participant
      await openWithBuffer(
        core,
        alice,
        marketId,
        100400,
        100600,
        MEDIUM_QUANTITY
      );

      await time.increaseTo(endTime + 1);
      await settleMarketAtTick(core, keeper, marketId, 100490);
      await advanceToClaimOpen(core, marketId);

      // Alice should be able to claim her winnings
      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const balanceBefore = await paymentToken.balanceOf(alice.address);

      await core.connect(alice).claimPayout(positions[0]);

      const balanceAfter = await paymentToken.balanceOf(alice.address);
      expect(balanceAfter).to.be.gt(balanceBefore);
    });
  });

  describe("Market Edge Cases", function () {
    it("Should handle last-minute trading rush", async function () {
      const { core, alice, bob, charlie, marketId, startTime, endTime } =
        await loadFixture(createMarketLifecycleFixture);

      await time.increaseTo(startTime + 10);

      // Wait until near market end
      await time.increaseTo(endTime - 3600); // 1 hour before end

      // Sudden burst of activity
      const participants = [alice, bob, charlie];
      const rushRanges = [
        { lower: 100400, upper: 100600 },
        { lower: 100420, upper: 100580 },
        { lower: 100440, upper: 100560 },
      ];

      const promises = participants.map((participant, i) => {
        const { lower, upper } = rushRanges[i % rushRanges.length];
        return openWithBuffer(
          core,
          participant,
          marketId,
          lower,
          upper,
          MEDIUM_QUANTITY,
          3000n
        );
      });

      // All should succeed
      await Promise.all(promises);
    });

    it("Should handle market with extreme tick concentration", async function () {
      const { core, alice, bob, charlie, marketId, startTime } =
        await loadFixture(createMarketLifecycleFixture);

      await time.increaseTo(startTime + 10);

      // Everyone bets on the same narrow range
      const participants = [alice, bob, charlie];

      for (const participant of participants) {
        await openWithBuffer(
          core,
          participant,
          marketId,
          100490,
          100510,
          MEDIUM_QUANTITY,
          1000n
        );
      }

      // Market should still function normally
      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;
    });

    it("Should handle mixed trading strategies", async function () {
      const { core, alice, bob, charlie, marketId, startTime, mockPosition } =
        await loadFixture(createMarketLifecycleFixture);

      await time.increaseTo(startTime + 10);

      // Alice: Wide range strategy
      await openWithBuffer(
        core,
        alice,
        marketId,
        100100,
        100900,
        SMALL_QUANTITY
      );

      // Bob: Focused strategy
      await openWithBuffer(
        core,
        bob,
        marketId,
        100480,
        100520,
        LARGE_QUANTITY,
        1000n
      );

      // Charlie: Edge strategy
      await openWithBuffer(
        core,
        charlie,
        marketId,
        100000,
        100050,
        MEDIUM_QUANTITY
      );

      // All strategies should coexist
      const alicePositions = await mockPosition.getPositionsByOwner(
        alice.address
      );
      const bobPositions = await mockPosition.getPositionsByOwner(bob.address);
      const charliePositions = await mockPosition.getPositionsByOwner(
        charlie.address
      );

      expect(alicePositions.length).to.equal(1);
      expect(bobPositions.length).to.equal(1);
      expect(charliePositions.length).to.equal(1);
    });
  });

  describe("Market Stress Scenarios", function () {
    it("Should handle high-frequency position adjustments", async function () {
      const { core, alice, mockPosition, marketId, startTime } =
        await loadFixture(createMarketLifecycleFixture);

      await time.increaseTo(startTime + 10);

      // Create initial position
      await openWithBuffer(
        core,
        alice,
        marketId,
        100400,
        100600,
        LARGE_QUANTITY,
        1000n
      );

      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = positions[0];

      // Rapidly adjust position multiple times
      for (let i = 0; i < 5; i++) {
        const adjustCost = await core.calculateIncreaseCost(
          positionId,
          SMALL_QUANTITY
        );

        await core
          .connect(alice)
          .increasePosition(
            positionId,
            SMALL_QUANTITY,
            applyBuffer(adjustCost)
          );
        await core
          .connect(alice)
          .decreasePosition(positionId, SMALL_QUANTITY / 2n, 0);
      }

      // Position should still be valid
      const finalPosition = await mockPosition.getPosition(positionId);
      expect(finalPosition.quantity).to.be.gt(0);
    });

    it("Should maintain system integrity under maximum load", async function () {
      const { core, alice, bob, charlie, marketId, startTime } =
        await loadFixture(createMarketLifecycleFixture);

      await time.increaseTo(startTime + 10);

      // Create maximum reasonable number of positions
      const participants = [alice, bob, charlie];

      for (let i = 0; i < 10; i++) {
        const participant = participants[i % 3];
        await openWithBuffer(
          core,
          participant,
          marketId,
          100000 + i * 50,
          100000 + i * 50 + 100,
          SMALL_QUANTITY
        );
      }

      // System should still be responsive
      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;

      // Should still be able to calculate costs
      const cost = await core.calculateOpenCost(
        marketId,
        100450,
        100550,
        SMALL_QUANTITY
      );
      expect(cost).to.be.gt(0);
    });
  });
});

```


## test/e2e/scenarios/stress-day-trading.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  setupCustomMarket,
  settleMarketAtTick,
} from "../../helpers/fixtures/core";
import { E2E_TAG } from "../../helpers/tags";
import {
  SAFE_DAY_TRADE_SIZE,
  SAFE_SCALP_SIZE,
  SAFE_SWING_SIZE,
  CONSERVATIVE_TRADE_SIZE,
  safeMaxCost,
  safeMaxCostFixed,
} from "../../helpers/limits";
import { createDeterministicRandom } from "../../helpers/utils/random";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

describeMaybe(`${E2E_TAG} Stress Day Trading Scenarios`, function () {
  const ALPHA = ethers.parseEther("0.5"); // Medium liquidity for day trading
  const TICK_COUNT = 100;
  const MARKET_DURATION = 24 * 60 * 60; // 1 day for day trading
  const USDC_DECIMALS = 6;

  // Safe trading sizes based on mathematical analysis:
  // Using helper constants that automatically calculate safe limits based on alpha
  // These are 30% of theoretical max to allow for multiple trades and market state changes
  const DAY_TRADE_SIZE = SAFE_DAY_TRADE_SIZE; // ~2 USDC - safe day trade size
  const SCALP_SIZE = SAFE_SCALP_SIZE; // ~0.8 USDC - safe scalp size
  const SWING_SIZE = SAFE_SWING_SIZE; // ~3.5 USDC - safe swing size

  async function createDayTradingMarket() {
    const contracts = await loadFixture(coreFixture);
    const { marketId, startTime, endTime } = await setupCustomMarket(
      contracts,
      {
        alpha: ALPHA,
        duration: MARKET_DURATION,
      }
    );
    return {
      ...contracts,
      marketId,
      startTime,
      endTime,
      mockPosition: contracts.mockPosition,
    };
  }

  describe("High Frequency Trading", function () {
    it("Should handle rapid fire trading", async function () {
      const { core, alice, marketId } = await loadFixture(
        createDayTradingMarket
      );

      // Mathematical analysis: with auto-flush mechanism, we can handle more trades
      // Using 15 trades to test high frequency while staying safe with auto-flush
      const rapidTrades = 15;
      const tradeInterval = 60; // 1 minute between trades
      let totalGasUsed = 0n;

      console.log(`Starting ${rapidTrades} rapid trades...`);

      for (let i = 0; i < rapidTrades; i++) {
        // Vary the trade parameters to simulate real trading
        const tickOffset = i % 10; // 0 to +9 tick variation to ensure valid ranges
        const lowerTick = 100400 + tickOffset * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        const upperTick = 100500 + tickOffset * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        const quantity =
          SCALP_SIZE + ethers.parseUnits((i % 5).toString(), USDC_DECIMALS - 3); // Add some variation

        const cost = await core.calculateOpenCost(
          marketId,
          lowerTick,
          upperTick,
          quantity
        );

        const tx = await core.connect(alice).openPosition(
          marketId,
          lowerTick,
          upperTick,
          quantity,
          safeMaxCost(cost, 1.5) // 1.5x buffer for rapid trading
        );

        const receipt = await tx.wait();
        totalGasUsed += receipt!.gasUsed;

        // Advance time slightly
        if (i % 10 === 0 && i > 0) {
          await time.increase(tradeInterval + 1); // Add 1 second buffer
          console.log(
            `Completed ${i + 1} trades, avg gas: ${
              totalGasUsed / BigInt(i + 1)
            }`
          );
        }
      }

      const avgGasPerTrade = totalGasUsed / BigInt(rapidTrades);
      console.log(
        `Rapid trading completed: ${rapidTrades} trades, avg gas: ${avgGasPerTrade}`
      );

      // Should maintain reasonable gas efficiency
      // With auto-flush mechanism, gas usage may be higher but should be stable
      expect(avgGasPerTrade).to.be.lt(3000000); // Realistic limit considering auto-flush overhead

      // Market should still be stable
      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;
    });

    it("Should handle scalping strategy", async function () {
      const { core, alice, marketId } = await loadFixture(
        createDayTradingMarket
      );
      const random = createDeterministicRandom(101);

      // Scalping: with auto-flush mechanism, we can handle reasonable scalping
      // Scalping with 20 trades - realistic stress test with auto-flush protection
      const scalpTrades = 20;
      const positions: number[] = [];

      // Open many small positions
      for (let i = 0; i < scalpTrades; i++) {
        const spread = 2; // 2 tick spread for scalping
        const midTick = 100500 + (i % 10) * 10 - 50; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©

        const cost = await core.calculateOpenCost(
          marketId,
          midTick - 10,
          midTick + 10,
          SCALP_SIZE
        );

        await core
          .connect(alice)
          .openPosition(
            marketId,
            midTick - 10,
            midTick + 10,
            SCALP_SIZE,
            cost
          );

        positions.push(i + 1);

        // Occasionally close some positions (scalping)
        if (i > 10 && i % 5 === 0) {
          const positionToClose =
            positions[Math.floor(random() * (positions.length - 5))];
          await core.connect(alice).closePosition(positionToClose, 0);
        }
      }

      console.log(`Scalping completed: ${scalpTrades} positions opened`);

      // Check remaining open positions
      const { mockPosition } = await loadFixture(createDayTradingMarket);
      let openPositions = 0;
      for (const positionId of positions) {
        try {
          const position = await mockPosition.getPosition(positionId);
          if (position.quantity > 0) {
            openPositions++;
          }
        } catch {
          // Position was closed
        }
      }

      console.log(`Open positions remaining: ${openPositions}`);
      expect(openPositions).to.be.gte(0); // Just verify no crash, positions may be closed
    });

    it("Should handle algorithmic trading patterns", async function () {
      const { core, alice, bob, charlie, marketId } = await loadFixture(
        createDayTradingMarket
      );

      const algos = [
        { trader: alice, name: "Momentum", tickRange: 10 },
        { trader: bob, name: "MeanReversion", tickRange: 10 },
        { trader: charlie, name: "Arbitrage", tickRange: 10 },
      ];

      // Algorithmic trading: 5 runs per algo (3 algos = 15 total trades)
      const algoRuns = 5;
      const algoStats: { [key: string]: bigint[] } = {};

      // Initialize stats
      algos.forEach((algo) => {
        algoStats[algo.name] = [];
      });

      // Run algorithms concurrently
      for (let round = 0; round < algoRuns; round++) {
        const promises = algos.map(async (algo, index) => {
          const baseRange = algo.tickRange;
          const tickCenter = 100500 + (round % 10) * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          const lowerTick = tickCenter - baseRange * 5; // Ïù¥ÎØ∏ 10Ïùò Î∞∞ÏàòÏù¥ÎØÄÎ°ú OK
          const upperTick = tickCenter + baseRange * 5; // Ïù¥ÎØ∏ 10Ïùò Î∞∞ÏàòÏù¥ÎØÄÎ°ú OK

          const cost = await core.calculateOpenCost(
            marketId,
            lowerTick,
            upperTick,
            DAY_TRADE_SIZE
          );

          const tx = await core
            .connect(alice)
            .openPosition(
              marketId,
              lowerTick,
              upperTick,
              DAY_TRADE_SIZE,
              safeMaxCost(cost, 1.8)
            ); // 1.8x buffer for cost fluctuations

          const receipt = await tx.wait();
          algoStats[algo.name].push(receipt!.gasUsed);

          return receipt;
        });

        await Promise.all(promises);

        if (round % 10 === 0) {
          console.log(`Algo round ${round + 1} completed`);
        }
      }

      // Analyze algorithm performance
      Object.entries(algoStats).forEach(([name, gasResults]) => {
        const avgGas =
          gasResults.reduce((a, b) => a + b, 0n) / BigInt(gasResults.length);
        const maxGas = gasResults.reduce((a, b) => (a > b ? a : b), 0n);
        const minGas = gasResults.reduce(
          (a, b) => (a < b ? a : b),
          gasResults[0]
        );

        console.log(`${name}: avg=${avgGas}, min=${minGas}, max=${maxGas}`);

        // All algorithms should be reasonably efficient
        // With auto-flush mechanism, gas usage can be higher but should be stable
        expect(avgGas).to.be.lt(4000000); // Realistic limit considering auto-flush overhead
      });
    });
  });

  describe("Day Trading Position Management", function () {
    it("Should handle rapid position adjustments", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(
        createDayTradingMarket
      );

      // Open initial position
      const initialCost = await core.calculateOpenCost(
        marketId,
        100300, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100700, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        SWING_SIZE
      );
      await core
        .connect(alice)
        .openPosition(
          marketId,
          100300,
          100700,
          SWING_SIZE,
          initialCost
        );

      // Get actual position ID from MockPosition
      const positions = await mockPosition.getPositionsByOwner(alice.address);
      const positionId = Number(positions[0]);
      const adjustmentSize = ethers.parseUnits("1", USDC_DECIMALS); // $1 adjustments - reduced
      const adjustments = 20;

      // Rapidly adjust position size
      for (let i = 0; i < adjustments; i++) {
        try {
          if (i % 2 === 0) {
            // Increase position
            const increaseCost = await core.calculateIncreaseCost(
              positionId,
              adjustmentSize
            );
            await core
              .connect(alice)
              .increasePosition(positionId, adjustmentSize, increaseCost);
          } else {
            // Decrease position
            await core
              .connect(alice)
              .decreasePosition(positionId, adjustmentSize, 0);
          }
        } catch (error: any) {
          // Handle InvalidQuantity gracefully - this is expected behavior for extreme sizes
          if (error.message.includes("InvalidQuantity")) {
            console.log(
              `Adjustment ${i}: Hit quantity limit (expected behavior)`
            );
            break; // Stop adjustments when hitting mathematical limits
          } else {
            throw error; // Re-throw unexpected errors
          }
        }

        if (i % 5 === 0) {
          const position = await mockPosition.getPosition(positionId);
          console.log(
            `Adjustment ${i}: position size $${ethers.formatUnits(
              position.quantity,
              USDC_DECIMALS
            )}`
          );
        }
      }

      // Position should still exist and be substantial
      const finalPosition = await mockPosition.getPosition(positionId);
      expect(finalPosition.quantity).to.be.gt(SWING_SIZE / 2n);

      console.log(
        `Final position: $${ethers.formatUnits(
          finalPosition.quantity,
          USDC_DECIMALS
        )}`
      );
    });

    it("Should handle stop-loss and take-profit patterns", async function () {
      const { core, alice, marketId } = await loadFixture(
        createDayTradingMarket
      );

      const trades = 8; // Reduced from 15 to prevent LazyFactorOverflow
      const stopLossThreshold = ethers.parseUnits("0.5", USDC_DECIMALS); // $0.5 stop loss - reduced
      const takeProfitThreshold = ethers.parseUnits("1", USDC_DECIMALS); // $1 take profit - reduced

      let stoppedOut = 0;
      let tookProfit = 0;

      for (let i = 0; i < trades; i++) {
        // Open position
        const tickOffset = (i % 40) - 20;
        const lowerTick = 100400 + tickOffset * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        const upperTick = 100600 + tickOffset * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©

        const openCost = await core.calculateOpenCost(
          marketId,
          lowerTick,
          upperTick,
          DAY_TRADE_SIZE
        );
        await core
          .connect(alice)
          .openPosition(
            marketId,
            lowerTick,
            upperTick,
            DAY_TRADE_SIZE,
            openCost * 3n
          ); // 3x buffer for cost fluctuations

        const positionId = i + 1;

        // Simulate some market movement (other trades)
        if (i % 3 === 0) {
          // Add some noise to market
          await core.connect(alice).openPosition(
            marketId,
            100200, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
            100800, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
            ethers.parseUnits("1", USDC_DECIMALS),
            ethers.parseUnits("50", USDC_DECIMALS)
          );
        }

        // Check if we should close (simplified stop/take logic)
        const closeProceeds = await core.calculateCloseProceeds(positionId);
        const pnl =
          closeProceeds > openCost
            ? closeProceeds - openCost
            : openCost - closeProceeds;

        if (
          closeProceeds < openCost &&
          openCost - closeProceeds > stopLossThreshold
        ) {
          // Stop loss
          await core.connect(alice).closePosition(positionId, 0);
          stoppedOut++;
        } else if (
          closeProceeds > openCost &&
          closeProceeds - openCost > takeProfitThreshold
        ) {
          // Take profit
          await core.connect(alice).closePosition(positionId, 0);
          tookProfit++;
        }

        console.log(
          `Trade ${i + 1}: P&L $${ethers.formatUnits(pnl, USDC_DECIMALS)}`
        );
      }

      console.log(
        `Stop losses: ${stoppedOut}, Take profits: ${tookProfit}, Still open: ${
          trades - stoppedOut - tookProfit
        }`
      );

      // Should have executed some risk management
      expect(stoppedOut + tookProfit).to.be.gte(0);
    });

    it("Should handle portfolio rebalancing", async function () {
      const { core, alice, marketId, mockPosition } = await loadFixture(
        createDayTradingMarket
      );

      // Create diversified portfolio
      const portfolioRanges = [
        { lower: 100100, upper: 100300, weight: 30 }, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        { lower: 100350, upper: 100500, weight: 40 }, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        { lower: 100550, upper: 100750, weight: 20 }, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        { lower: 100800, upper: 100950, weight: 10 }, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
      ];

      // Portfolio size: $20 total (individual positions will be $2-8, well under chunk limits)
      const totalPortfolio = ethers.parseUnits("20", USDC_DECIMALS);
      const positionIds: number[] = [];

      // Initial allocation
      for (let i = 0; i < portfolioRanges.length; i++) {
        const range = portfolioRanges[i];
        const allocation = (totalPortfolio * BigInt(range.weight)) / 100n;

        try {
          const cost = await core.calculateOpenCost(
            marketId,
            range.lower,
            range.upper,
            allocation
          );
          await core
            .connect(alice)
            .openPosition(
              marketId,
              range.lower,
              range.upper,
              allocation,
              cost
            );
        } catch (error: any) {
          // Handle InvalidQuantity gracefully
          if (error.message.includes("InvalidQuantity")) {
            console.log(`Position ${i + 1}: Hit quantity limit, skipping`);
            continue;
          } else {
            throw error;
          }
        }

        // Get actual position ID from MockPosition
        const positions = await mockPosition.getPositionsByOwner(alice.address);
        positionIds.push(Number(positions[positions.length - 1]));
        console.log(
          `Position ${i + 1}: $${ethers.formatUnits(
            allocation,
            USDC_DECIMALS
          )} in ticks ${range.lower}-${range.upper}`
        );
      }

      // Simulate rebalancing (reduce position 1, increase position 2)
      // Rebalance amount: $1.5 (7.5% of portfolio) - realistic rebalancing
      const rebalanceAmount = ethers.parseUnits("1.5", USDC_DECIMALS);

      // Reduce position 1
      await core
        .connect(alice)
        .decreasePosition(positionIds[0], rebalanceAmount, 0);

      // Increase position 2
      const increaseCost = await core.calculateIncreaseCost(
        positionIds[1],
        rebalanceAmount
      );
      await core
        .connect(alice)
        .increasePosition(positionIds[1], rebalanceAmount, increaseCost);

      console.log("Portfolio rebalanced");

      // Check final allocation
      for (let i = 0; i < positionIds.length; i++) {
        const position = await mockPosition.getPosition(positionIds[i]);
        console.log(
          `Final position ${i + 1}: $${ethers.formatUnits(
            position.quantity,
            USDC_DECIMALS
          )}`
        );
      }
    });
  });

  describe("Market Stress Under Day Trading", function () {
    it("Should handle overlapping ranges with high activity", async function () {
      const { core, alice, bob, charlie, marketId } = await loadFixture(
        createDayTradingMarket
      );

      const traders = [alice, bob, charlie];
      const hotRange = { lower: 100450, upper: 100550 }; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
      // Hot range trading: 8 trades per trader (3 traders = 24 total) to prevent overflow
      const tradesPerTrader = 8;

      let totalTradesInRange = 0;

      // All traders focus on the same hot range
      for (let round = 0; round < tradesPerTrader; round++) {
        const promises = traders.map(async (trader, index) => {
          const spread = 2 + (round % 3); // Varying spreads
          const offset = (index - 1) * 10; // -10, 0, 10 (Ìã± Í∞ÑÍ≤©Ïóê ÎßûÏ∂§)

          const lowerTick = hotRange.lower + offset;
          const upperTick = hotRange.upper + offset;

          const cost = await core.calculateOpenCost(
            marketId,
            lowerTick,
            upperTick,
            CONSERVATIVE_TRADE_SIZE
          );

          const tx = await core
            .connect(alice)
            .openPosition(
              marketId,
              lowerTick,
              upperTick,
              CONSERVATIVE_TRADE_SIZE,
              safeMaxCost(cost, 1.8)
            ); // 1.8x buffer for cost fluctuations

          totalTradesInRange++;
          return tx;
        });

        await Promise.all(promises);

        if (round % 5 === 0) {
          console.log(
            `Hot range round ${
              round + 1
            } completed, ${totalTradesInRange} total trades`
          );
        }
      }

      console.log(
        `Hot range stress test completed: ${totalTradesInRange} trades in overlapping range`
      );

      // Check that market is still functional
      const testCost = await core.calculateOpenCost(
        marketId,
        100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        CONSERVATIVE_TRADE_SIZE
      );
      expect(testCost).to.be.gt(0);

      // Price should have moved significantly due to concentration
      console.log(
        `Final cost in hot range: $${ethers.formatUnits(
          testCost,
          USDC_DECIMALS
        )}`
      );
    });

    it("Should maintain performance under sustained high volume", async function () {
      const { core, alice, bob, charlie, marketId } = await loadFixture(
        createDayTradingMarket
      );

      const traders = [alice, bob, charlie];
      // Sustained trading: 100 total trades (30% of limit) to test sustained performance
      const sustainedTrades = 100;
      const batchSize = 5; // Process in batches of 5

      let totalGasUsed = 0n;
      const gasPerBatch: bigint[] = [];

      // Sustained trading over time
      for (let batch = 0; batch < sustainedTrades / batchSize; batch++) {
        let batchGas = 0n;

        // Execute batch of trades
        for (let i = 0; i < batchSize; i++) {
          const trader = traders[(batch * batchSize + i) % traders.length];
          const variation = (batch * batchSize + i) % 30;

          const lowerTick = 100300 + (variation % 15) * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          const upperTick = 100500 + (variation % 15) * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          const quantity =
            DAY_TRADE_SIZE +
            ethers.parseUnits((variation % 5).toString(), USDC_DECIMALS - 1);

          const cost = await core.calculateOpenCost(
            marketId,
            lowerTick,
            upperTick,
            quantity
          );

          const tx = await core
            .connect(alice)
            .openPosition(
              marketId,
              lowerTick,
              upperTick,
              quantity,
              cost
            );

          const receipt = await tx.wait();
          batchGas += receipt!.gasUsed;
        }

        totalGasUsed += batchGas;
        gasPerBatch.push(batchGas);

        // Advance time between batches
        await time.increase(300); // 5 minutes

        if (batch % 5 === 0) {
          console.log(
            `Batch ${batch + 1}: ${batchGas} gas, avg per trade: ${
              batchGas / BigInt(batchSize)
            }`
          );
        }
      }

      const avgGasPerBatch = totalGasUsed / BigInt(gasPerBatch.length);
      const avgGasPerTrade = totalGasUsed / BigInt(sustainedTrades);

      console.log(`Sustained trading completed: ${sustainedTrades} trades`);
      console.log(`Average gas per trade: ${avgGasPerTrade}`);
      console.log(`Average gas per batch: ${avgGasPerBatch}`);

      // Gas usage should remain reasonable (considering auto-flush overhead)
      expect(avgGasPerTrade).to.be.lt(710000); // ÏïΩÍ∞Ñ Ï¶ùÍ∞ÄÎêú ÌïúÍ≥Ñ

      // Performance should be consistent across batches
      const gasVariance = gasPerBatch.map(
        (gas) =>
          Number(
            gas > avgGasPerBatch ? gas - avgGasPerBatch : avgGasPerBatch - gas
          ) / Number(avgGasPerBatch)
      );
      const maxVariance = Math.max(...gasVariance);

      console.log(`Maximum gas variance: ${(maxVariance * 100).toFixed(2)}%`);
      expect(maxVariance).to.be.lt(0.5); // Less than 50% variance
    });

    it("Should handle end-of-day settlement rush", async function () {
      const { core, keeper, alice, bob, charlie, marketId, mockPosition } =
        await loadFixture(createDayTradingMarket);
      const random = createDeterministicRandom(202);

      const traders = [alice, bob, charlie];
      const dayTradingPositions = 20; // Reduced from 50 to prevent LazyFactorOverflow

      // Create many day trading positions throughout the day
      for (let i = 0; i < dayTradingPositions; i++) {
        const trader = traders[i % traders.length];
        const timeOffset = Math.floor(
          (i * MARKET_DURATION) / dayTradingPositions
        );

        if (timeOffset > 0) {
          await time.increase(
            Math.max(1, Math.floor(timeOffset / dayTradingPositions))
          ); // Ensure at least 1 second
        }

        const tickOffset = (i % 60) - 30;
        const cost = await core.calculateOpenCost(
          marketId,
          100400 + tickOffset * 10, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100600 + tickOffset * 10, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          DAY_TRADE_SIZE
        );

        await core.connect(alice).openPosition(
          marketId,
          100400 + tickOffset * 10, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100600 + tickOffset * 10, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          DAY_TRADE_SIZE,
          cost
        );
      }

      console.log(`Created ${dayTradingPositions} day trading positions`);

      // Fast forward to near market close
      const market = await core.getMarket(marketId);
      await time.increaseTo(Number(market.endTimestamp) - 3600); // 1 hour before close

      // End-of-day settlement rush: many traders close positions
      // Settlement rush: 25 trades (7% of limit) - realistic end-of-day activity
      const rushTrades = 25;
      let rushGasUsed = 0n;

      for (let i = 0; i < rushTrades; i++) {
        const positionId = Math.floor(random() * dayTradingPositions) + 1;

        try {
          const position = await mockPosition.getPosition(positionId);
          if (position.quantity > 0) {
            const tx = await core.connect(alice).closePosition(positionId, 0);
            const receipt = await tx.wait();
            rushGasUsed += receipt!.gasUsed;
          }
        } catch {
          // Position might already be closed
        }
      }

      const avgRushGas = rushGasUsed / BigInt(rushTrades);
      console.log(
        `End-of-day rush: ${rushTrades} closes, avg gas: ${avgRushGas}`
      );

      // Should handle rush efficiently
      // With auto-flush mechanism, gas usage can be higher during rush periods
      expect(avgRushGas).to.be.lt(2000000);

      // Fast forward to settlement
      const latestMarket = await core.getMarket(marketId);
      const settlementGate =
        Number(
          latestMarket.settlementTimestamp === 0n
            ? latestMarket.endTimestamp
            : latestMarket.settlementTimestamp
        ) + 1;
      await time.increaseTo(settlementGate);

      // Market settlement should work despite heavy activity
      const settlementTx = await settleMarketAtTick(
        core,
        keeper,
        marketId,
        100495
      );
      const settlementReceipt = await settlementTx.wait();

      console.log(
        `Settlement after day trading: ${settlementReceipt!.gasUsed} gas`
      );
      expect(settlementReceipt!.status).to.equal(1);
    });
  });

  describe("Day Trading Error Recovery", function () {
    it("Should handle failed trades gracefully during high activity", async function () {
      const { core, alice, bob, marketId } = await loadFixture(
        createDayTradingMarket
      );

      let successfulTrades = 0;
      let failedTrades = 0;
      const totalAttempts = 50;

      // Attempt many trades, some designed to fail
      for (let i = 0; i < totalAttempts; i++) {
        try {
          const quantity = DAY_TRADE_SIZE;
          const lowerTick = 100400 + (i % 20) * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          const upperTick = 100600 - (i % 20) * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©

          // Intentionally use insufficient maxCost for some trades
          const actualCost = await core.calculateOpenCost(
            marketId,
            lowerTick,
            upperTick,
            quantity
          );
          const maxCost =
            i % 5 === 0
              ? actualCost / 2n // Insufficient cost (should fail)
              : actualCost; // Correct cost (should succeed)

          await core
            .connect(alice)
            .openPosition(
              marketId,
              lowerTick,
              upperTick,
              quantity,
              maxCost
            );

          successfulTrades++;
        } catch (error: any) {
          failedTrades++;
          console.log(
            `Trade ${i + 1} failed: ${error.message.substring(0, 50)}...`
          );
        }
      }

      console.log(
        `Trade results: ${successfulTrades} successful, ${failedTrades} failed`
      );

      // Should have both successes and controlled failures
      expect(successfulTrades).to.be.gt(totalAttempts * 0.15); // At least 15% success (realistic with intentional failures)
      expect(failedTrades).to.be.gt(0); // Some failures expected

      // Market should still be functional after failed trades
      const testCost = await core.calculateOpenCost(
        marketId,
        100450, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        100550, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
        DAY_TRADE_SIZE
      );
      expect(testCost).to.be.gt(0);
    });

    it("Should maintain state consistency during concurrent operations", async function () {
      const { core, alice, bob, charlie, marketId, mockPosition } =
        await loadFixture(createDayTradingMarket);

      // Create initial positions
      const traders = [alice, bob, charlie];
      const initialPositions: number[] = [];

      for (let i = 0; i < traders.length; i++) {
        const cost = await core.calculateOpenCost(
          marketId,
          100300 + i * 10, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100700 - i * 10, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          SWING_SIZE
        );
        await core.connect(alice).openPosition(
          traders[i].address,
          marketId,
          100300 + i * 10, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          100700 - i * 10, // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          SWING_SIZE,
          cost
        );
        initialPositions.push(i + 1);
      }

      // Concurrent operations: increases, decreases, and new positions
      const concurrentOps = 20;
      const operations = [];

      for (let i = 0; i < concurrentOps; i++) {
        const trader = traders[i % traders.length];
        const opType = i % 3;

        if (opType === 0 && i < initialPositions.length) {
          // Increase existing position
          const positionId = initialPositions[i % initialPositions.length];
          const increaseCost = await core.calculateIncreaseCost(
            positionId,
            DAY_TRADE_SIZE
          );
          operations.push(
            core
              .connect(alice)
              .increasePosition(positionId, DAY_TRADE_SIZE, increaseCost)
          );
        } else if (opType === 1 && i < initialPositions.length) {
          // Decrease existing position
          const positionId = initialPositions[i % initialPositions.length];
          operations.push(
            core
              .connect(alice)
              .decreasePosition(positionId, DAY_TRADE_SIZE / 2n, 0)
          );
        } else {
          // Create new position - ensure lower < upper and handle InvalidQuantity
          const tickOffset = i % 15; // Reduced range to avoid overlap
          const lowerTick = 100350 + tickOffset * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          const upperTick = 100550 + tickOffset * 10; // Ïã§Ï†ú Ìã±Í∞í ÏÇ¨Ïö©
          try {
            const cost = await core.calculateOpenCost(
              marketId,
              lowerTick,
              upperTick,
              DAY_TRADE_SIZE
            );
            operations.push(
              core
                .connect(alice)
                .openPosition(
                  marketId,
                  lowerTick,
                  upperTick,
                  DAY_TRADE_SIZE,
                  cost
                )
            );
          } catch (error: any) {
            // Handle InvalidQuantity gracefully
            if (error.message.includes("InvalidQuantity")) {
              // Skip this operation - it's expected behavior
              continue;
            } else {
              throw error;
            }
          }
        }
      }

      // Execute all operations concurrently
      const results = await Promise.allSettled(operations);

      let successful = 0;
      let failed = 0;

      results.forEach((result, index) => {
        if (result.status === "fulfilled") {
          successful++;
        } else {
          failed++;
          console.log(
            `Operation ${index + 1} failed: ${result.reason.message.substring(
              0,
              50
            )}...`
          );
        }
      });

      console.log(
        `Concurrent operations: ${successful} successful, ${failed} failed`
      );

      // Most operations should succeed despite overflow protection
      expect(successful).to.be.gte(concurrentOps * 0.3); // Realistic with overflow protection

      // Verify market state is still consistent
      const market = await core.getMarket(marketId);
      expect(market.isActive).to.be.true;

      // All original positions should still be valid
      for (const positionId of initialPositions) {
        const position = await mockPosition.getPosition(positionId);
        expect(position.quantity).to.be.gt(0);
      }
    });
  });
});

```


## test/e2e/scenarios/stress-market-limits.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  getTickValue,
  settleMarketAtTick,
} from "../../helpers/fixtures/core";
import { E2E_TAG } from "../../helpers/tags";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

describeMaybe(`${E2E_TAG} Market Limits and Stress Tests`, function () {
  const ALPHA = ethers.parseEther("1");
  const TICK_COUNT = 100;
  const MARKET_DURATION = 7 * 24 * 60 * 60; // 7 days

  it("Should handle maximum tick count", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;

    const largeTicks = 50000;
    const minTick = 100000;
    const maxTick = minTick + (largeTicks - 1) * 10;
    const tickSpacing = 10;

    const marketIdBig = await core
      .connect(keeper)
      .createMarket.staticCall(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );

    const marketId = Number(marketIdBig);
    const market = await core.getMarket(marketId);
    expect(Number(market.numBins)).to.equal(largeTicks - 1);

    await settleMarketAtTick(core, keeper, marketId, maxTick - 15);

    const settledMarket = await core.getMarket(marketId);
    expect(settledMarket.settlementTick).to.equal(BigInt(maxTick - 15));
  });

  it("Should handle rapid market creation and settlement", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const baseStartTime = currentTime + 3600;

    // Create and settle multiple markets rapidly
    for (let i = 1; i <= 10; i++) {
      const minTick = 100000;
      const maxTick = 100990;
      const tickSpacing = 10;

      await core
        .connect(keeper)
        .createMarket(
          i,
          minTick,
          maxTick,
          tickSpacing,
          baseStartTime + i * 100,
          baseStartTime + i * 100 + MARKET_DURATION,
          ALPHA
        );

      const settlementLower = 100000 + (i % 100) * 10;
      const settlementUpper = settlementLower + 10;
      const settlementTick = (settlementLower + settlementUpper) / 2;
      await settleMarketAtTick(core, keeper, i, settlementTick);

      const market = await core.getMarket(i);
      expect(market.settled).to.be.true;
      expect(market.settlementTick).to.equal(BigInt(settlementTick));
    }
  });

  it("Should handle maximum tick count of 1,000,000", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const maxTickCount = await core.MAX_TICK_COUNT(); // 1,000,000

    // Calculate tick range for max count
    const minTick = 100000;
    const tickSpacing = 10;
    const maxTick = minTick + (Number(maxTickCount) - 1) * tickSpacing;

    // Test with actual maximum tick count
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );

    const market = await core.getMarket(1);
    expect(market.numBins).to.equal(maxTickCount - 1n);

    // Sample a few tick values to ensure tree initialization
    const WAD = ethers.parseEther("1");
    expect(await getTickValue(core, 1, minTick, tickSpacing)).to.equal(WAD);
    expect(
      await getTickValue(core, 1, minTick + 100000 * tickSpacing, tickSpacing)
    ).to.equal(
      WAD
    );
    expect(await getTickValue(core, 1, maxTick, tickSpacing)).to.equal(WAD);
  });

  it("Should validate time range correctly", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const minTick = 100000;
    const maxTick = 100990;
    const tickSpacing = 10;

    // Test start == end (should fail)
    await expect(
      core
        .connect(keeper)
        .createMarket(
          1,
          minTick,
          maxTick,
          tickSpacing,
          currentTime,
          currentTime,
          ALPHA
        )
    ).to.be.revertedWithCustomError(core, "InvalidTimeRange");

    // Test start > end (should fail)
    await expect(
      core
        .connect(keeper)
        .createMarket(
          1,
          minTick,
          maxTick,
          tickSpacing,
          currentTime + 1000,
          currentTime,
          ALPHA
        )
    ).to.be.revertedWithCustomError(core, "InvalidTimeRange");
  });

  it("Should auto-increment market IDs on creation", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const minTick = 100000;
    const maxTick = 100990;
    const tickSpacing = 10;

    const firstId = await core
      .connect(keeper)
      .createMarket.staticCall(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );

    const secondId = await core
      .connect(keeper)
      .createMarket.staticCall(
        1,
        minTick,
        maxTick,
        tickSpacing,
        endTime + 100,
        endTime + 100 + MARKET_DURATION,
        ALPHA
      );
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        endTime + 100,
        endTime + 100 + MARKET_DURATION,
        ALPHA
      );

    expect(secondId).to.equal(firstId + 1n);

    const firstMarket = await core.getMarket(Number(firstId));
    const secondMarket = await core.getMarket(Number(secondId));
    expect(firstMarket.minTick).to.equal(minTick);
    expect(secondMarket.minTick).to.equal(minTick);
  });

  it("Should validate liquidity parameter boundaries", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const minTick = 100000;
    const maxTick = 100990;
    const tickSpacing = 10;

    const minAlpha = await core.MIN_LIQUIDITY_PARAMETER();
    const maxAlpha = await core.MAX_LIQUIDITY_PARAMETER();

    // Test minimum boundary (should succeed)
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        minAlpha
      );

    // Test maximum boundary (should succeed)
    await core
      .connect(keeper)
      .createMarket(
        2,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        maxAlpha
      );

    // Test below minimum (should fail)
    await expect(
      core
        .connect(keeper)
        .createMarket(
          3,
          minTick,
          maxTick,
          tickSpacing,
          startTime,
          endTime,
          minAlpha - 1n
        )
    ).to.be.revertedWithCustomError(core, "InvalidLiquidityParameter");

    // Test above maximum (should fail)
    await expect(
      core
        .connect(keeper)
        .createMarket(
          4,
          minTick,
          maxTick,
          tickSpacing,
          startTime,
          endTime,
          maxAlpha + 1n
        )
    ).to.be.revertedWithCustomError(core, "InvalidLiquidityParameter");
  });
});

```


## test/e2e/scenarios/stress-market-operations.spec.ts

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { time, loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  getTickValue,
  settleMarketAtTick,
} from "../../helpers/fixtures/core";
import { E2E_TAG } from "../../helpers/tags";

const describeMaybe = process.env.COVERAGE ? describe.skip : describe;

describeMaybe(`${E2E_TAG} Market Operations - Stress Tests`, function () {
  const ALPHA = ethers.parseEther("1");
  const TICK_COUNT = 100;
  const MARKET_DURATION = 7 * 24 * 60 * 60; // 7 days
  const WAD = ethers.parseEther("1");

  it("Should handle maximum tick count", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;

    // This might be slow, so we test with a smaller but significant number
    const largeTicks = 50000;
    const minTick = 100000;
    const maxTick = minTick + (largeTicks - 1) * 10;
    const tickSpacing = 10;

    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );

    const market = await core.getMarket(1);
    expect(Number(market.numBins)).to.equal(largeTicks - 1);

    // Test settlement with large tick count
    await settleMarketAtTick(core, keeper, 1, maxTick - 15);

    const settledMarket = await core.getMarket(1);
    expect(settledMarket.settlementTick).to.equal(BigInt(maxTick - 15));
  });

  it("Should handle rapid market creation and settlement", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const baseStartTime = currentTime + 3600;

    // Create and settle multiple markets rapidly
    for (let i = 1; i <= 10; i++) {
      const minTick = 100000;
      const maxTick = 100990;
      const tickSpacing = 10;

      await core
        .connect(keeper)
        .createMarket(
          i,
          minTick,
          maxTick,
          tickSpacing,
          baseStartTime + i * 100,
          baseStartTime + i * 100 + MARKET_DURATION,
          ALPHA
        );

      const settlementTick = 100000 + (i % 100) * 10;
      await settleMarketAtTick(core, keeper, i, settlementTick);

      const market = await core.getMarket(i);
      expect(market.settled).to.be.true;
      expect(market.settlementTick).to.equal(BigInt(settlementTick));
    }
  });

  it("Should handle maximum tick count of 1,000,000", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const maxTickCount = await core.MAX_TICK_COUNT(); // 1,000,000

    // Calculate tick range for max count
    const minTick = 100000;
    const tickSpacing = 10;
    const maxTick = minTick + (Number(maxTickCount) - 1) * tickSpacing;

    // Test with actual maximum tick count
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );

    const market = await core.getMarket(1);
    expect(market.numBins).to.equal(maxTickCount - 1n);

    // Sample a few tick values to ensure tree initialization
    expect(await getTickValue(core, 1, minTick, tickSpacing)).to.equal(WAD);
    expect(
      await getTickValue(core, 1, minTick + 100000 * tickSpacing, tickSpacing)
    ).to.equal(
      WAD
    );
    expect(await getTickValue(core, 1, maxTick, tickSpacing)).to.equal(WAD);
  });

  it("Should validate time range correctly", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const minTick = 100000;
    const maxTick = 100990;
    const tickSpacing = 10;

    // Test start == end (should fail)
    await expect(
      core
        .connect(keeper)
        .createMarket(
          1,
          minTick,
          maxTick,
          tickSpacing,
          currentTime,
          currentTime,
          ALPHA
        )
    ).to.be.revertedWithCustomError(core, "InvalidTimeRange");

    // Test start > end (should fail)
    await expect(
      core
        .connect(keeper)
        .createMarket(
          1,
          minTick,
          maxTick,
          tickSpacing,
          currentTime + 1000,
          currentTime,
          ALPHA
        )
    ).to.be.revertedWithCustomError(core, "InvalidTimeRange");
  });

  it("Should auto-increment market IDs on creation", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const minTick = 100000;
    const maxTick = 100990;
    const tickSpacing = 10;

    const firstId = await core
      .connect(keeper)
      .createMarket.staticCall(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );

    const secondId = await core
      .connect(keeper)
      .createMarket.staticCall(
        1,
        minTick,
        maxTick,
        tickSpacing,
        endTime + 100,
        endTime + 100 + MARKET_DURATION,
        ALPHA
      );
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        endTime + 100,
        endTime + 100 + MARKET_DURATION,
        ALPHA
      );

    expect(secondId).to.equal(firstId + 1n);

    const firstMarket = await core.getMarket(Number(firstId));
    const secondMarket = await core.getMarket(Number(secondId));
    expect(firstMarket.minTick).to.equal(minTick);
    expect(secondMarket.minTick).to.equal(minTick);
  });

  it("Should validate liquidity parameter boundaries", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const minTick = 100000;
    const maxTick = 100990;
    const tickSpacing = 10;

    const minAlpha = await core.MIN_LIQUIDITY_PARAMETER();
    const maxAlpha = await core.MAX_LIQUIDITY_PARAMETER();

    // Test minimum boundary (should succeed)
    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        minAlpha
      );

    // Test maximum boundary (should succeed)
    await core
      .connect(keeper)
      .createMarket(
        2,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        maxAlpha
      );

    // Test below minimum (should fail)
    await expect(
      core
        .connect(keeper)
        .createMarket(
          3,
          minTick,
          maxTick,
          tickSpacing,
          startTime,
          endTime,
          minAlpha - 1n
        )
    ).to.be.revertedWithCustomError(core, "InvalidLiquidityParameter");

    // Test above maximum (should fail)
    await expect(
      core
        .connect(keeper)
        .createMarket(
          4,
          minTick,
          maxTick,
          tickSpacing,
          startTime,
          endTime,
          maxAlpha + 1n
        )
    ).to.be.revertedWithCustomError(core, "InvalidLiquidityParameter");
  });

  it("Should handle multiple markets with varied parameters", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const baseStartTime = currentTime + 3600;

    // Create markets with various tick counts and liquidity parameters
    const marketConfigs = [
      { id: 1, tickCount: 10, alpha: ethers.parseEther("0.001") },
      { id: 2, tickCount: 100, alpha: ethers.parseEther("0.1") },
      { id: 3, tickCount: 1000, alpha: ethers.parseEther("1") },
      { id: 4, tickCount: 10000, alpha: ethers.parseEther("10") },
      { id: 5, tickCount: 50000, alpha: ethers.parseEther("100") },
    ];

    for (let i = 0; i < marketConfigs.length; i++) {
      const config = marketConfigs[i];
      const startTime = baseStartTime + i * 1000;
      const endTime = startTime + MARKET_DURATION;

      const minTick = 100000;
      const tickSpacing = 10;
      const maxTick = minTick + (config.tickCount - 1) * tickSpacing;

      await core
        .connect(keeper)
        .createMarket(
          config.id,
          minTick,
          maxTick,
          tickSpacing,
          startTime,
          endTime,
          config.alpha
        );

      await core.connect(keeper).setMarketActive(config.id, true);

      const market = await core.getMarket(config.id);
      expect(Number(market.numBins)).to.equal(config.tickCount - 1);
      expect(market.liquidityParameter).to.equal(config.alpha);
      expect(market.isActive).to.be.true;
      expect(market.settled).to.be.false;
    }

    // Settle all markets with different winning ticks
    for (let i = 0; i < marketConfigs.length; i++) {
      const config = marketConfigs[i];
      const midPoint = Math.floor(config.tickCount / 2);
      const winningTickLower = 100000 + midPoint * 10;
      const winningTickUpper = winningTickLower + 10;

      await settleMarketAtTick(
        core,
        keeper,
        config.id,
        (winningTickLower + winningTickUpper) / 2
      );

      const market = await core.getMarket(config.id);
      expect(market.settled).to.be.true;
      expect(market.isActive).to.be.false;
      expect(market.settlementTick).to.equal(
        BigInt((winningTickLower + winningTickUpper) / 2)
      );
    }
  });

  it("Should handle large-scale tick value queries", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const startTime = currentTime + 3600;
    const endTime = startTime + MARKET_DURATION;
    const tickCount = 10000;
    const minTick = 100000;
    const tickSpacing = 10;
    const maxTick = minTick + (tickCount - 1) * tickSpacing;

    await core
      .connect(keeper)
      .createMarket(
        1,
        minTick,
        maxTick,
        tickSpacing,
        startTime,
        endTime,
        ALPHA
      );

    // Query many tick values (sampling approach for performance)
    const sampleSize = 100;
    const step = Math.floor(tickCount / sampleSize);

    for (let i = 0; i < tickCount; i += step) {
      const actualTick = minTick + i * tickSpacing;
      const tickValue = await getTickValue(core, 1, actualTick, tickSpacing);
      expect(tickValue).to.equal(WAD);
    }

    // Test edge cases
    expect(await getTickValue(core, 1, minTick, tickSpacing)).to.equal(WAD);
    expect(await getTickValue(core, 1, maxTick, tickSpacing)).to.equal(WAD);
  });

  it("Should handle stress test: rapid market operations", async function () {
    const { core, keeper } = await loadFixture(coreFixture);

    const currentTime = await time.latest();
    const minTick = 100000;
    const maxTick = 100990;
    const tickSpacing = 10;

    // Rapid operations: create, settle, repeat
    for (let i = 1; i <= 20; i++) {
      const startTime = currentTime + i * 10;
      const endTime = startTime + MARKET_DURATION;

      // Create market
      await core
        .connect(keeper)
        .createMarket(
          i,
          minTick,
          maxTick,
          tickSpacing,
          startTime,
          endTime,
          ALPHA
        );

      // Immediately settle
      const settlementTick = 100000 + (i % 100) * 10;
      await settleMarketAtTick(core, keeper, i, settlementTick);

      const market = await core.getMarket(i);
      expect(market.settled).to.be.true;
    }
  });
});

```


## test/helpers/fixtures/core.ts

```typescript
import { ethers } from "hardhat";
import { time } from "@nomicfoundation/hardhat-network-helpers";

// Common constants - 6 decimal based (USDC)
export const WAD = ethers.parseEther("1");
export const USDC_DECIMALS = 6;
export const INITIAL_SUPPLY = ethers.parseUnits("1000000000000", USDC_DECIMALS);
export const ALPHA = ethers.parseEther("1"); // 1 ETH = ~$3000, more realistic liquidity parameter
export const TICK_COUNT = 100;
export const MARKET_DURATION = 7 * 24 * 60 * 60;

// Test quantities - 6 decimal based
export const SMALL_QUANTITY = ethers.parseUnits("0.001", 6);
export const MEDIUM_QUANTITY = ethers.parseUnits("0.01", 6);
export const LARGE_QUANTITY = ethers.parseUnits("0.1", 6);
export const CHUNK_BOUNDARY_QUANTITY = ethers.parseUnits("0.013", 6);

// Cost limits - 6 decimal based
export const SMALL_COST = ethers.parseUnits("0.01", 6);
export const MEDIUM_COST = ethers.parseUnits("0.1", 6);
export const LARGE_COST = ethers.parseUnits("1", 6);
export const EXTREME_COST = ethers.parseUnits("1000", 6);

// Factor limits
export const MIN_FACTOR = ethers.parseEther("0.0001");
export const MAX_FACTOR = ethers.parseEther("10000");

export const SETTLEMENT_VALUE_UNIT = 1_000_000n; // Tick values scaled by 1e6

export function toSettlementValue(tick: number | bigint): bigint {
  return BigInt(tick) * SETTLEMENT_VALUE_UNIT;
}

export async function increaseToSafe(targetTimestamp: number) {
  const latest = await time.latest();
  const safeTarget = Math.max(targetTimestamp, latest + 1);
  await time.increaseTo(safeTarget);
}

const CORE_COMPAT_SYMBOL = Symbol.for("clmsr.core.compat-applied");
const CORE_CONNECT_PATCH_SYMBOL = Symbol.for("clmsr.core.compat-connect");

function toNumber(value: any): number {
  if (typeof value === "number") return value;
  if (typeof value === "bigint") return Number(value);
  return Number.NaN;
}

function cloneWithZeroAddress(args: any[]): any[] {
  const copy = [...args];
  copy.push(ethers.ZeroAddress);
  return copy;
}

function ensureCoreCompatibility(contract: any) {
  if (!contract || contract[CORE_COMPAT_SYMBOL]) {
    return contract;
  }

  Object.defineProperty(contract, CORE_COMPAT_SYMBOL, {
    value: true,
    enumerable: false,
    configurable: false,
  });

  const applyCostBuffer = (value: bigint) => (value * 1000n) / 10000n + 1n + value;

  const patchFunction = (
    key: string,
    mapper: (args: any[]) => Promise<any[]>
  ) => {
    if (typeof contract[key] !== "function") {
      return;
    }

    const originalFn = contract[key].bind(contract);
    const originalStatic = contract[key].staticCall
      ? contract[key].staticCall.bind(contract)
      : undefined;

    const patched = async (...args: any[]) => {
      const mappedArgs = await mapper(args);
      return originalFn(...mappedArgs);
    };

    if (originalStatic) {
      patched.staticCall = async (...args: any[]) => {
        const mappedArgs = await mapper(args);
        return originalStatic(...mappedArgs);
      };
    }

    contract[key] = patched;
  };

  const handleCreateMarketArgs = async (args: any[]) => {
    if (args.length === 7) {
      const maybeLegacy =
        Number.isFinite(toNumber(args[2])) &&
        Number.isFinite(toNumber(args[1])) &&
        toNumber(args[2]) > toNumber(args[1]);

      if (maybeLegacy) {
        const [
          ,
          minTick,
          maxTick,
          tickSpacing,
          startTs,
          endTs,
          liquidity,
        ] = args;

        const settlementRaw =
          typeof endTs === "bigint" ? endTs + 3600n : Number(endTs) + 3600;

        return [
          minTick,
          maxTick,
          tickSpacing,
          startTs,
          endTs,
          settlementRaw,
          liquidity,
          ethers.ZeroAddress,
        ];
      }

      return cloneWithZeroAddress(args);
    }

    if (args.length === 8 && (args[7] === undefined || args[7] === null)) {
      const copy = [...args];
      copy[7] = ethers.ZeroAddress;
      return copy;
    }

    return args;
  };

  patchFunction("createMarket", handleCreateMarketArgs);
  patchFunction(
    "createMarket(int256,int256,int256,uint64,uint64,uint64,uint256)",
    handleCreateMarketArgs
  );
  patchFunction(
    "createMarket(int256,int256,int256,uint64,uint64,uint64,uint256,address)",
    handleCreateMarketArgs
  );

  patchFunction("openPosition", async (args) => {
    if (args.length === 6 && typeof args[0] === "string") {
      return args.slice(1);
    }

    if (args.length === 4) {
      const [marketId, lowerTick, upperTick, quantity] = args;
      const baseCost: bigint = await contract.calculateOpenCost(
        marketId,
        lowerTick,
        upperTick,
        quantity
      );
      const maxCost = applyCostBuffer(baseCost);
      return [marketId, lowerTick, upperTick, quantity, maxCost];
    }

    return args;
  });

  return contract;
}

export function applyCoreCompatibility(contract: any) {
  if (!contract) {
    return contract;
  }

  if (
    typeof contract.connect === "function" &&
    !contract[CORE_CONNECT_PATCH_SYMBOL]
  ) {
    const originalConnect = contract.connect.bind(contract);
    const patchedConnect = (signer: any) => {
      const connected = originalConnect(signer);
      return applyCoreCompatibility(connected);
    };

    Object.defineProperty(contract, CORE_CONNECT_PATCH_SYMBOL, {
      value: true,
      enumerable: false,
      configurable: false,
    });

    contract.connect = patchedConnect;
  }

  return ensureCoreCompatibility(contract);
}

export function toSettlementValueFromRange(
  lowerTick: number | bigint,
  upperTick: number | bigint
): bigint {
  const lower = BigInt(lowerTick);
  const upper = BigInt(upperTick);
  if (upper < lower) {
    throw new Error("upperTick must be >= lowerTick");
  }
  // Use midpoint (floor) within range to derive settlement tick
  return ((lower + upper) / 2n) * SETTLEMENT_VALUE_UNIT;
}


export async function settleMarketAtTick(
  core: any,
  keeper: any,
  marketId: number,
  tick: number | bigint
) {
  const market = await core.getMarket(marketId);
  const gate = market.settlementTimestamp === 0n ? market.endTimestamp : market.settlementTimestamp;
  const latest = await time.latest();
  if (BigInt(latest) < gate) {
    await time.increaseTo(Number(gate) + 1);
  }
  return core.connect(keeper).settleMarket(marketId, toSettlementValue(tick));
}

export async function advanceToClaimOpen(core: any, marketId: number) {
  const market = await core.getMarket(marketId);
  const T =
    market.settlementTimestamp === 0n
      ? market.endTimestamp
      : market.settlementTimestamp;
  const claimOpen = Number(T) + 15 * 60;
  const latest = await time.latest();
  if (latest < claimOpen) {
    await time.increaseTo(claimOpen);
  }
}

export async function settleMarketUsingRange(
  core: any,
  keeper: any,
  marketId: number,
  lowerTick: number | bigint,
  upperTick: number | bigint
) {
  return settleMarketAtTick(
    core,
    keeper,
    marketId,
    (BigInt(lowerTick) + BigInt(upperTick)) / 2n
  );
}

export async function createMarketWithId(
  core: any,
  signer: any,
  args: [number, number, number, number, number, number, bigint, string]
) {
  const createMarket = core.connect(signer)[
    "createMarket(int256,int256,int256,uint64,uint64,uint64,uint256,address)"
  ];

  const marketIdBig = await createMarket.staticCall(...args);
  await createMarket(...args);
  return Number(marketIdBig);
}

export async function createMarketWithConfig(
  core: any,
  signer: any,
  config: {
    minTick: number;
    maxTick: number;
    tickSpacing: number;
    startTime: number;
    endTime: number;
    liquidityParameter: bigint;
    settlementTime?: number;
    feePolicy?: string;
  }
) {
  const {
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    liquidityParameter,
    settlementTime = endTime + 3600,
    feePolicy = ethers.ZeroAddress,
  } = config;

  return createMarketWithId(core, signer, [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    settlementTime,
    liquidityParameter,
    feePolicy,
  ]);
}

export async function setMarketActivation(
  core: any,
  signer: any,
  marketId: number,
  active: boolean = true
) {
  await core.connect(signer).setMarketActive(marketId, active);
}

export async function legacyCreateMarket(
  core: any,
  signer: any,
  _legacyMarketId: number,
  minTick: number,
  maxTick: number,
  tickSpacing: number,
  startTime: number,
  endTime: number,
  liquidityParameter: bigint,
  settlementTime?: number
) {
  const effectiveSettlement = settlementTime ?? endTime + 3600;
  return createMarketWithId(core, signer, [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    effectiveSettlement,
    liquidityParameter,
    ethers.ZeroAddress,
  ]);
}

/**
 * Unit fixture - ÎùºÏù¥Î∏åÎü¨Î¶¨Îßå
 */
export async function unitFixture() {
  const [deployer, keeper, alice, bob, charlie] = await ethers.getSigners();

  // Deploy libraries
  const FixedPointMathUFactory = await ethers.getContractFactory(
    "FixedPointMathU"
  );
  const fixedPointMathU = await FixedPointMathUFactory.deploy();
  await fixedPointMathU.waitForDeployment();

  const LazyMulSegmentTreeFactory = await ethers.getContractFactory(
    "LazyMulSegmentTree",
    {
      libraries: { FixedPointMathU: await fixedPointMathU.getAddress() },
    }
  );
  const lazyMulSegmentTree = await LazyMulSegmentTreeFactory.deploy();
  await lazyMulSegmentTree.waitForDeployment();

  const CLMSRMarketManagerFactory = await ethers.getContractFactory(
    "CLMSRMarketManagerTest",
    {
      libraries: {
        LazyMulSegmentTree: await lazyMulSegmentTree.getAddress(),
      },
    }
  );
  const manager = await CLMSRMarketManagerFactory.deploy();
  await manager.waitForDeployment();

  return {
    fixedPointMathU,
    lazyMulSegmentTree,
    deployer,
    keeper,
    alice,
    bob,
    charlie,
    manager,
  };
}

/**
 * Component fixture - Core + Mocks
 */
async function buildCoreFixture(contractName: string) {
  const baseFixture = await unitFixture();
  const { deployer, keeper, alice, bob, charlie, manager } = baseFixture as any;

  // Deploy USDC token
  const MockERC20Factory = await ethers.getContractFactory("MockERC20");
  const paymentToken = await MockERC20Factory.deploy("USD Coin", "USDC", 6);
  await paymentToken.waitForDeployment();

  // Mint tokens
  const users = [alice, bob, charlie];
  for (const user of users) {
    await paymentToken.mint(user.address, INITIAL_SUPPLY);
  }

  // Deploy position contract
  const MockPositionFactory = await ethers.getContractFactory("MockPosition");
  const mockPosition = await MockPositionFactory.deploy();
  await mockPosition.waitForDeployment();

  // Deploy core contract (upgradeable)
  const CLMSRMarketCoreFactory = await ethers.getContractFactory(
    contractName,
    {
      libraries: {
        FixedPointMathU: await baseFixture.fixedPointMathU.getAddress(),
        LazyMulSegmentTree: await baseFixture.lazyMulSegmentTree.getAddress(),
      },
    }
  );

  const core = await CLMSRMarketCoreFactory.deploy();
  await core.waitForDeployment();

  applyCoreCompatibility(core);

  // Initialize upgradeable contract
  await core.initialize(
    await paymentToken.getAddress(),
    await mockPosition.getAddress()
  );

  await core.connect(deployer).setManager(await manager.getAddress());

  // Setup contracts
  await paymentToken.mint(await core.getAddress(), INITIAL_SUPPLY);
  await mockPosition.setCore(await core.getAddress());

  // Transfer ownership to keeper so tests exercise delegated permissions
  await core.connect(deployer).transferOwnership(keeper.address);

  // Approve tokens
  for (const user of users) {
    await paymentToken
      .connect(user)
      .approve(await core.getAddress(), ethers.MaxUint256);
  }

  return {
    ...baseFixture,
    core,
    paymentToken,
    mockPosition,
    manager,
    deployer,
  };
}

export async function coreFixture() {
  return buildCoreFixture("CLMSRMarketCore");
}

/**
 * Integration fixture - Core + Position real (Ï∂îÌõÑ Ïã§Ï†ú Position Íµ¨ÌòÑ Ïãú)
 */
export async function marketFixture() {
  const contracts = await coreFixture();
  const { core, keeper } = contracts;

  const startTime = await time.latest();
  const endTime = startTime + MARKET_DURATION;
  const settlementTime = endTime + 3600; // 1 hour after end

  // ÏÉàÎ°úÏö¥ Ìã± ÏãúÏä§ÌÖú: 100000Î∂ÄÌÑ∞ ÏãúÏûë, 10 Í∞ÑÍ≤©ÏúºÎ°ú TICK_COUNTÍ∞ú
  const minTick = 100000;
  const maxTick = minTick + (TICK_COUNT - 1) * 10;
  const tickSpacing = 10;

  const createArgs: [number, number, number, number, number, number, bigint, string] = [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    settlementTime,
    ALPHA,
    ethers.ZeroAddress,
  ];

  const marketId = await createMarketWithId(core, keeper, createArgs);

  return {
    ...contracts,
    marketId,
    startTime,
    endTime,
  };
}

/**
 * Create active market helper
 */
export async function createActiveMarket(contracts: any) {
  const currentTime = await time.latest();
  const startTime = currentTime + 200; // Add larger buffer to avoid timestamp conflicts
  const endTime = startTime + MARKET_DURATION;
  const settlementTime = endTime + 3600; // 1 hour after end

  // ÏÉàÎ°úÏö¥ Ìã± ÏãúÏä§ÌÖú: 100000Î∂ÄÌÑ∞ ÏãúÏûë, 10 Í∞ÑÍ≤©ÏúºÎ°ú TICK_COUNTÍ∞ú
  const minTick = 100000;
  const maxTick = minTick + (TICK_COUNT - 1) * 10;
  const tickSpacing = 10;

  const createArgs: [number, number, number, number, number, number, bigint, string] = [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    settlementTime,
    ALPHA,
    ethers.ZeroAddress,
  ];

  const marketId = await createMarketWithId(
    contracts.core,
    contracts.keeper,
    createArgs
  );

  await setMarketActivation(contracts.core, contracts.keeper, marketId, true);

  // Move to market start time (ensure monotonic timestamp progression)
  await increaseToSafe(startTime + 1);

  // Tree Ï¥àÍ∏∞ÌôîÎ•º ÏúÑÌïú Ï≤´ Î≤àÏß∏ position ÏÉùÏÑ± (Îß§Ïö∞ ÏûëÏùÄ ÏàòÎüâ)
  await contracts.core.connect(contracts.alice).openPosition(
    marketId,
    100500, // Ï§ëÍ∞Ñ Ìã±
    100510,
    1n, // 1 wei (ÏµúÏÜå ÏàòÎüâ)
    ethers.parseEther("1000.0") // Ï∂©Î∂ÑÌïú ÏµúÎåÄ ÎπÑÏö©
  );

  return { marketId, startTime, endTime };
}

/**
 * Create active market fixture for integration tests
 */
export async function createActiveMarketFixture() {
  const contracts = await coreFixture();
  const { core, keeper } = contracts;

  const currentTime = await time.latest();
  const startTime = currentTime + 300; // Larger buffer for fixture tests
  const endTime = startTime + MARKET_DURATION;
  const settlementTime = endTime + 3600; // 1 hour after end

  // ÏÉàÎ°úÏö¥ Ìã± ÏãúÏä§ÌÖú: 100000Î∂ÄÌÑ∞ ÏãúÏûë, 10 Í∞ÑÍ≤©ÏúºÎ°ú TICK_COUNTÍ∞ú
  const minTick = 100000;
  const maxTick = minTick + (TICK_COUNT - 1) * 10;
  const tickSpacing = 10;

  const createArgs: [number, number, number, number, number, number, bigint, string] = [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    settlementTime,
    ALPHA,
    ethers.ZeroAddress,
  ];

  const marketId = await createMarketWithId(core, keeper, createArgs);

  await setMarketActivation(core, keeper, marketId, true);

  // Move to market start time (ensure monotonic timestamp progression)
  await increaseToSafe(startTime + 1);

  return {
    ...contracts,
    marketId,
    startTime,
    endTime,
  };
}

/**
 * Create a market with extreme parameters for boundary testing
 */
export async function createExtremeMarket(
  contracts: Awaited<ReturnType<typeof coreFixture>>,
  requestedMarketId: number = 1
) {
  const startTime = await time.latest();
  const endTime = startTime + MARKET_DURATION;
  const settlementTime = endTime + 3600; // 1 hour after end
  const extremeAlpha = ethers.parseEther("1000");

  // ÏÉàÎ°úÏö¥ Ìã± ÏãúÏä§ÌÖú: 100000Î∂ÄÌÑ∞ ÏãúÏûë, 10 Í∞ÑÍ≤©ÏúºÎ°ú TICK_COUNTÍ∞ú
  const minTick = 100000;
  const maxTick = minTick + (TICK_COUNT - 1) * 10;
  const tickSpacing = 10;

  const createArgs: [number, number, number, number, number, number, bigint, string] = [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    settlementTime,
    extremeAlpha,
    ethers.ZeroAddress,
  ];

  const marketId = await createMarketWithId(
    contracts.core,
    contracts.keeper,
    createArgs
  );

  await setMarketActivation(contracts.core, contracts.keeper, marketId, true);

  return { marketId, startTime, endTime, alpha: extremeAlpha };
}

// Ìã± Ïù∏Îç±Ïä§Î•º Ïã§Ï†ú Ìã± Í∞íÏúºÎ°ú Î≥ÄÌôòÌïòÎäî Ìó¨Ìçº Ìï®Ïàò
export function indexToTick(index: number): number {
  return 100000 + index * 10;
}

// Ïã§Ï†ú Ìã± Í∞íÏùÑ Ïù∏Îç±Ïä§Î°ú Î≥ÄÌôòÌïòÎäî Ìó¨Ìçº Ìï®Ïàò
export function tickToIndex(tick: number): number {
  return (tick - 100000) / 10;
}

/**
 * Helper to retrieve single tick value via range sum API
 */
export async function getTickValue(
  core: any,
  marketId: number,
  tick: number,
  tickSpacingOverride?: number
): Promise<bigint> {
  const market = await core.getMarket(marketId);
  const rawSpacing =
    tickSpacingOverride ??
    Number(
      market.tickSpacing !== undefined
        ? market.tickSpacing
        : market[7] /* tuple fallback */
    );
  if (!Number.isFinite(rawSpacing) || rawSpacing <= 0) {
    throw new Error("Invalid tick spacing");
  }
  const maxTickSource =
    market.maxTick !== undefined ? market.maxTick : market[6];
  const minTickSource =
    market.minTick !== undefined ? market.minTick : market[5];

  if (maxTickSource === undefined || minTickSource === undefined) {
    throw new Error("Market tick bounds unavailable");
  }

  const maxTick = Number(maxTickSource);
  const minTick = Number(minTickSource);

  if (tick === maxTick) {
    const lowerTick = Math.max(minTick, maxTick - rawSpacing);
    return core.getRangeSum(marketId, lowerTick, maxTick);
  }

  if (tick < minTick) {
    return core.getRangeSum(marketId, tick, tick + rawSpacing);
  }

  const upperTick = tick + rawSpacing;
  return core.getRangeSum(marketId, tick, upperTick);
}

// ÏùòÎØ∏ Í∏∞Î∞ò ÎßàÏºì ÏÑ§Ï†ï Ìó¨Ìçº Ìï®ÏàòÎì§

/**
 * ÌëúÏ§Ä ÌôúÏÑ± ÎßàÏºì ÏÑ§Ï†ï - ÎåÄÎ∂ÄÎ∂ÑÏùò ÌÖåÏä§Ìä∏ÏóêÏÑú ÏÇ¨Ïö©
 */
export async function setupActiveMarket(
  contracts: any
) {
  return await createActiveMarket(contracts);
}

/**
 * Îã§Ï§ë ÎßàÏºì ÏÑ§Ï†ï - Ïó¨Îü¨ ÎßàÏºìÏù¥ ÌïÑÏöîÌïú ÌÖåÏä§Ìä∏Ïö©
 */
export async function setupMultipleMarkets(contracts: any, count: number = 3) {
  const markets = [];
  for (let i = 1; i <= count; i++) {
    const market = await createActiveMarket(contracts);
    markets.push(market);
  }
  return markets;
}

/**
 * Ïª§Ïä§ÌÖÄ ÎßàÏºì ÏÑ§Ï†ï - ÌäπÎ≥ÑÌïú ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÌïÑÏöîÌïú ÌÖåÏä§Ìä∏Ïö©
 */
export async function setupCustomMarket(
  contracts: any,
  options: {
    numTicks?: number;
    alpha?: bigint;
    duration?: number;
  } = {}
) {
  const {
    numTicks = TICK_COUNT,
    alpha = ALPHA,
    duration = MARKET_DURATION,
  } = options;

  const currentTime = await time.latest();
  const startTime = currentTime + 200;
  const endTime = startTime + duration;
  const settlementTime = endTime + 3600; // 1 hour after end

  // ÏÉàÎ°úÏö¥ Ìã± ÏãúÏä§ÌÖúÏúºÎ°ú Î≥ÄÌôò
  const minTick = 100000;
  const maxTick = minTick + (numTicks - 1) * 10;
  const tickSpacing = 10;

  const createArgs: [number, number, number, number, number, number, bigint, string] = [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    settlementTime,
    alpha,
    ethers.ZeroAddress,
  ];

  const actualMarketId = await createMarketWithId(
    contracts.core,
    contracts.keeper,
    createArgs
  );

  await setMarketActivation(contracts.core, contracts.keeper, actualMarketId, true);

  await increaseToSafe(startTime + 1);

  return { marketId: actualMarketId, startTime, endTime, numTicks, alpha };
}

/**
 * Í≥†Ïú†ÎèôÏÑ± ÎßàÏºì ÏÑ§Ï†ï - ÏÑ±Îä•/Ïä§Ìä∏Î†àÏä§ ÌÖåÏä§Ìä∏Ïö©
 */
export async function setupHighLiquidityMarket(
  contracts: any,
  marketId: number = 1
) {
  return await setupCustomMarket(contracts, {
    marketId,
    alpha: ethers.parseEther("10"),
  });
}

/**
 * Í≤ΩÍ≥ÑÍ∞í ÌÖåÏä§Ìä∏Ïö© Í∑πÌïú ÎßàÏºì ÏÑ§Ï†ï
 */
export async function setupExtremeMarket(contracts: any, marketId: number = 1) {
  return await createExtremeMarket(contracts, marketId);
}

// Í∞ÄÍ≤©/Ìã± Í∞í Í∏∞Î∞ò Ìó¨Ìçº Ìï®ÏàòÎì§ (index Í∞úÎÖê ÏôÑÏ†Ñ Ï†úÍ±∞)

/**
 * Ïã§Ï†ú Í∞ÄÍ≤© Î≤îÏúÑÎ•º ÎÇòÌÉÄÎÇ¥Îäî Ìã± Í∞íÎì§
 */
export const TICK_VALUES = {
  // ÏãúÏû• Î≤îÏúÑ: 100,000 ~ 199,990 (10 Í∞ÑÍ≤©)
  MARKET_MIN: 100000,
  MARKET_MAX: 199990,
  SPACING: 10,

  // ÌÖåÏä§Ìä∏Ïö© ÏùòÎØ∏ÏûàÎäî Í∞ÄÍ≤©Îì§
  LOW_PRICE: 105000, // 105.0 (Ï†ÄÍ∞Ä)
  MID_PRICE: 150000, // 150.0 (Ï§ëÍ∞ÑÍ∞Ä)
  HIGH_PRICE: 195000, // 195.0 (Í≥†Í∞Ä)

  // Í±∞Îûò Î≤îÏúÑÎì§
  NARROW_RANGE: { lower: 149990, upper: 150010 }, // 150.0 ¬± 0.1
  WIDE_RANGE: { lower: 120000, upper: 180000 }, // 120.0 ~ 180.0
  SINGLE_TICK: { lower: 150000, upper: 150000 }, // Ï†ïÌôïÌûà 150.0
} as const;

/**
 * Í∞ÄÍ≤© Í∏∞Î∞ò Ìè¨ÏßÄÏÖò Ïó¥Í∏∞ Ìó¨Ìçº
 */
export async function openPositionAtPrice(
  core: any,
  trader: any,
  marketId: number,
  lowerPrice: number,
  upperPrice: number,
  quantity: bigint,
  maxCost: bigint
) {
  return await core
    .connect(trader)
    .openPosition(marketId, lowerPrice, upperPrice, quantity, maxCost);
}

/**
 * Îã®Ïùº Í∞ÄÍ≤©ÏóêÏÑúÏùò Ìè¨ÏßÄÏÖò Ïó¥Í∏∞
 */
export async function openSinglePricePosition(
  core: any,
  trader: any,
  marketId: number,
  price: number,
  quantity: bigint,
  maxCost: bigint
) {
  return await openPositionAtPrice(
    core,
    trader,
    marketId,
    price,
    price,
    quantity,
    maxCost
  );
}

```


## test/helpers/fixtures/position.ts

```typescript
import { ethers } from "hardhat";
import { time } from "@nomicfoundation/hardhat-network-helpers";
import {
  coreFixture,
  unitFixture,
  INITIAL_SUPPLY,
  ALPHA,
  TICK_COUNT,
  MARKET_DURATION,
  applyCoreCompatibility,
} from "./core";

const DEFAULT_POSITION_QUANTITY = ethers.parseUnits("10", 6);
const DEFAULT_POSITION_MAX_COST = ethers.parseUnits("1000", 6);

async function createMarketAndReturnId(
  core: any,
  signer: any,
  args: [number, number, number, number, number, number, bigint, string],
  activate: boolean = true
) {
  const marketIdBig = await core.connect(signer).createMarket.staticCall(...args);
  await core.connect(signer).createMarket(...args);
  const marketId = Number(marketIdBig);
  if (activate) {
    await core.connect(signer).setMarketActive(marketId, true);
  }
  return marketId;
}

/**
 * Position fixture - CLMSRPosition contract for complex testing
 */
export async function positionFixture() {
  const baseFixture = await unitFixture();
  const { deployer, keeper, alice, bob, charlie, manager } = baseFixture

  // Deploy USDC token
  const MockERC20Factory = await ethers.getContractFactory("MockERC20");
  const paymentToken = await MockERC20Factory.deploy("USD Coin", "USDC", 6);
  await paymentToken.waitForDeployment();

  // Mint tokens
  const users = [alice, bob, charlie];
  for (const user of users) {
    await paymentToken.mint(user.address, INITIAL_SUPPLY);
  }

  // Use MockPosition for testing to avoid circular dependency
  const MockPositionFactory = await ethers.getContractFactory("MockPosition");
  const position = await MockPositionFactory.deploy();
  await position.waitForDeployment();

  // Deploy core with position address (upgradeable)
  const CLMSRMarketCoreFactory = await ethers.getContractFactory(
    "CLMSRMarketCore",
    {
      libraries: {
        FixedPointMathU: await baseFixture.fixedPointMathU.getAddress(),
        LazyMulSegmentTree: await baseFixture.lazyMulSegmentTree.getAddress(),
      },
    }
  );

  const core = await CLMSRMarketCoreFactory.deploy();
  await core.waitForDeployment();
  applyCoreCompatibility(core);

  // Initialize upgradeable contract
  await core.initialize(
    await paymentToken.getAddress(),
    await position.getAddress()
  );

  await core.connect(deployer).setManager(await manager.getAddress());

  // Set core in position contract
  await position.setCore(await core.getAddress());

  // Delegate ownership to keeper for compatibility
  await core.connect(deployer).transferOwnership(keeper.address);
  await position.connect(deployer).transferOwnership(keeper.address);

  // Setup contracts
  await paymentToken.mint(await core.getAddress(), INITIAL_SUPPLY);

  // Approve tokens
  for (const user of users) {
    await paymentToken
      .connect(user)
      .approve(await core.getAddress(), ethers.MaxUint256);
  }

  return {
    ...baseFixture,
    core,
    paymentToken,
    position,
    manager,
    deployer,
  };
}

/**
 * Active Position fixture - Actual CLMSRPosition contract for unit tests
 */
export async function activePositionFixture() {
  const baseFixture = await unitFixture();
  const { deployer, keeper, alice, bob, charlie, manager } = baseFixture as any;

  // Deploy USDC token
  const MockERC20Factory = await ethers.getContractFactory("MockERC20");
  const paymentToken = await MockERC20Factory.deploy("USD Coin", "USDC", 6);
  await paymentToken.waitForDeployment();

  // Mint tokens
  const users = [alice, bob, charlie];
  for (const user of users) {
    await paymentToken.mint(user.address, INITIAL_SUPPLY);
  }

  // Calculate deterministic addresses for circular dependency
  const CLMSRMarketCoreFactory = await ethers.getContractFactory(
    "CLMSRMarketCore",
    {
      libraries: {
        FixedPointMathU: await baseFixture.fixedPointMathU.getAddress(),
        LazyMulSegmentTree: await baseFixture.lazyMulSegmentTree.getAddress(),
      },
    }
  );

  const CLMSRPositionFactory = await ethers.getContractFactory("CLMSRPosition");

  // Deploy position implementation and initialize with placeholder core
  const position = await CLMSRPositionFactory.deploy();
  await position.waitForDeployment();
  await position.initialize(ethers.ZeroAddress);

  // Deploy core and initialize with position address
  const core = await CLMSRMarketCoreFactory.deploy();
  await core.waitForDeployment();
  applyCoreCompatibility(core);

  await core.initialize(
    await paymentToken.getAddress(),
    await position.getAddress()
  );

  await core.connect(deployer).setManager(await manager.getAddress());

  // Link position to core and delegate ownership
  await position.updateCore(await core.getAddress());
  await core.connect(deployer).transferOwnership(keeper.address);
  await position.connect(deployer).transferOwnership(keeper.address);

  // Setup contracts
  await paymentToken.mint(await core.getAddress(), INITIAL_SUPPLY);

  // Approve tokens
  for (const user of users) {
    await paymentToken
      .connect(user)
      .approve(await core.getAddress(), ethers.MaxUint256);
  }

  return {
    ...baseFixture,
    core,
    paymentToken,
    position,
    manager,
    deployer,
  };
}

/**
 * Position market fixture - CLMSRPosition + active market
 */
export async function positionMarketFixture() {
  const contracts = await positionFixture();
  const { core, keeper } = contracts;

  const currentTime = await time.latest();
  const startTime = currentTime + 500; // Larger buffer for position market tests
  const endTime = startTime + MARKET_DURATION;

  // ÏÉàÎ°úÏö¥ Ìã± ÏãúÏä§ÌÖú ÏÇ¨Ïö©
  const minTick = 100000;
  const maxTick = minTick + (TICK_COUNT - 1) * 10;
  const tickSpacing = 10;
  const settlementTime = endTime + 3600;

  const createArgs: [number, number, number, number, number, number, bigint, string] = [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    settlementTime,
    ALPHA,
    ethers.ZeroAddress,
  ];

  const marketId = await createMarketAndReturnId(core, keeper, createArgs);

  // Move to market start time
  await time.increaseTo(startTime + 1);

  return {
    ...contracts,
    marketId,
    startTime,
    endTime,
  };
}

/**
 * Active Position market fixture - CLMSRPosition + active market
 */
export async function activePositionMarketFixture() {
  const contracts = await activePositionFixture();
  const { core, keeper } = contracts;

  const currentTime = await time.latest();
  const startTime = currentTime + 600; // Even larger buffer for real position tests
  const endTime = startTime + MARKET_DURATION;
  const settlementTime = endTime + 3600;

  // ÏÉàÎ°úÏö¥ Ìã± ÏãúÏä§ÌÖú ÏÇ¨Ïö©
  const minTick = 100000;
  const maxTick = minTick + (TICK_COUNT - 1) * 10;
  const tickSpacing = 10;

  const createArgs: [number, number, number, number, number, number, bigint, string] = [
    minTick,
    maxTick,
    tickSpacing,
    startTime,
    endTime,
    settlementTime,
    ALPHA,
    ethers.ZeroAddress,
  ];

  const marketId = await createMarketAndReturnId(core, keeper, createArgs);

  // LazyMulSegmentTreeÎäî createMarketÏóêÏÑú ÏûêÎèô Ï¥àÍ∏∞ÌôîÎê®

  // Move to market start time
  await time.increaseTo(startTime + 1);

  return {
    ...contracts,
    marketId,
    startTime,
    endTime,
  };
}

function applyBuffer(value: bigint, bufferBps: bigint = 1000n) {
  const buffer = (value * bufferBps) / 10000n + 1n;
  return value + buffer;
}

export async function quoteOpenCost(
  core: any,
  marketId: number,
  lowerTick: number,
  upperTick: number,
  quantity: bigint,
  bufferBps: bigint = 1000n
) {
  const baseCost: bigint = await core.calculateOpenCost(
    marketId,
    lowerTick,
    upperTick,
    quantity
  );
  return applyBuffer(baseCost, bufferBps);
}

export async function openPositionWithQuote(
  core: any,
  signer: any,
  params: {
    marketId: number;
    lowerTick: number;
    upperTick: number;
    quantity: bigint;
    maxCost?: bigint;
    bufferBps?: bigint;
  }
) {
  const { marketId, lowerTick, upperTick, quantity, maxCost, bufferBps } = params;
  const costLimit =
    maxCost ?? (await quoteOpenCost(core, marketId, lowerTick, upperTick, quantity, bufferBps));

  const positionId = await core
    .connect(signer)
    .openPosition.staticCall(marketId, lowerTick, upperTick, quantity, costLimit);

  await core
    .connect(signer)
    .openPosition(marketId, lowerTick, upperTick, quantity, costLimit);

  return { positionId, maxCost: costLimit };
}

export async function quoteIncreaseCostWithBuffer(
  core: any,
  positionId: bigint,
  additionalQuantity: bigint,
  bufferBps: bigint = 1000n
) {
  const baseCost: bigint = await core.calculateIncreaseCost(
    positionId,
    additionalQuantity
  );
  return applyBuffer(baseCost, bufferBps);
}

export async function listMarketPositions(position: any, marketId: number) {
  if (typeof position.getMarketPositions === "function") {
    return position.getMarketPositions(marketId);
  }

  const length: bigint = await position.getMarketTokenLength(marketId);
  const results: bigint[] = [];
  for (let i = 0n; i < length; i++) {
    const tokenId: bigint = await position.getMarketTokenAt(marketId, i);
    if (tokenId !== 0n) {
      results.push(tokenId);
    }
  }
  return results;
}

/**
 * Position with active market and positions
 */
export async function positionWithDataFixture() {
  const contracts = await positionMarketFixture();
  const { core, position, alice, bob, marketId } = contracts;

  // Create some test positions
  const positionParams = {
    marketId,
    lowerTick: 100100,
    upperTick: 100200,
    quantity: DEFAULT_POSITION_QUANTITY,
    maxCost: DEFAULT_POSITION_MAX_COST,
  };

  // Alice opens position
  const alicePositionId = await core
    .connect(alice)
    .openPosition.staticCall(
      positionParams.marketId,
      positionParams.lowerTick,
      positionParams.upperTick,
      positionParams.quantity,
      positionParams.maxCost
    );
  await core
    .connect(alice)
    .openPosition(
      positionParams.marketId,
      positionParams.lowerTick,
      positionParams.upperTick,
      positionParams.quantity,
      positionParams.maxCost
    );

  // Bob opens position
  const bobPositionId = await core
    .connect(bob)
    .openPosition.staticCall(
      positionParams.marketId,
      positionParams.lowerTick,
      positionParams.upperTick,
      positionParams.quantity,
      positionParams.maxCost
    );
  await core
    .connect(bob)
    .openPosition(
      positionParams.marketId,
      positionParams.lowerTick,
      positionParams.upperTick,
      positionParams.quantity,
      positionParams.maxCost
    );

  return {
    contracts,
    alicePositionId,
    bobPositionId,
    positionParams,
  };
}

/**
 * Helper to create position with specific parameters
 */
export async function createTestPosition(
  contracts: Awaited<ReturnType<typeof positionFixture>>,
  user: any,
  marketId: number,
  lowerTick: number = 100100, // Ïã§Ï†ú Ìã±Í∞íÏúºÎ°ú Î≥ÄÍ≤Ω
  upperTick: number = 100200, // Ïã§Ï†ú Ìã±Í∞íÏúºÎ°ú Î≥ÄÍ≤Ω
  quantity: bigint = DEFAULT_POSITION_QUANTITY,
  maxCost: bigint = DEFAULT_POSITION_MAX_COST
) {
  // Ensure core exists
  if (!contracts.core) {
    throw new Error("Core contract not found in contracts");
  }

  const params = {
    marketId,
    lowerTick,
    upperTick,
    quantity,
    maxCost,
  };

  const positionId = await contracts.core
    .connect(user)
    .openPosition.staticCall(
      params.marketId,
      params.lowerTick,
      params.upperTick,
      params.quantity,
      params.maxCost
    );
  await contracts.core
    .connect(user)
    .openPosition(
      params.marketId,
      params.lowerTick,
      params.upperTick,
      params.quantity,
      params.maxCost
    );

  return { positionId, params };
}

/**
 * Helper to create position with real CLMSRPosition contract
 */
export async function createRealTestPosition(
  contracts: Awaited<ReturnType<typeof activePositionFixture>>,
  user: any,
  marketId: number,
  lowerTick: number = 100100,
  upperTick: number = 100200,
  quantity: bigint = DEFAULT_POSITION_QUANTITY,
  maxCost: bigint = DEFAULT_POSITION_MAX_COST
) {
  // Ensure core exists
  if (!contracts.core) {
    throw new Error("Core contract not found in contracts");
  }

  const params = {
    marketId,
    lowerTick,
    upperTick,
    quantity,
    maxCost,
  };

  // Call directly to core (no router needed)
  const positionId = await contracts.core
    .connect(user)
    .openPosition.staticCall(
      params.marketId,
      params.lowerTick,
      params.upperTick,
      params.quantity,
      params.maxCost
    );
  await contracts.core
    .connect(user)
    .openPosition(
      params.marketId,
      params.lowerTick,
      params.upperTick,
      params.quantity,
      params.maxCost
    );

  return { positionId, params };
}

```


## test/helpers/limits.ts

```typescript
import { parseUnits } from "ethers";

/**
 * Safe trading limits based on mathematical constraints
 *
 * Background:
 * - MAX_EXP_INPUT_WAD ‚âà 0.13 (maximum safe input for exp function)
 * - For Œ± = 0.5, max safe quantity per chunk = Œ± √ó 0.13 ‚âà 0.065 ETH = 65 USDC
 * - To prevent chunk overflow, we use 30-50% of this limit for stress tests
 */

// Standard liquidity parameter used in tests
export const STANDARD_ALPHA = parseUnits("0.5", 18); // 0.5 WAD

// Helper function to calculate safe quantity for given alpha and percentage
export function qtyFor(alpha: bigint, pct = 0.3): bigint {
  // alpha √ó 0.13 √ó pct, converted to 6-decimal USDC
  const alphaNumber = Number(alpha) / 1e18; // Convert from WAD to decimal
  const maxSafeUSDC = alphaNumber * 0.13 * pct; // Calculate safe amount
  return parseUnits(maxSafeUSDC.toFixed(6), 6); // Convert to 6-decimal USDC
}

// Safe trading sizes for different strategies (30% of theoretical max)
export const SAFE_DAY_TRADE_SIZE = qtyFor(STANDARD_ALPHA, 0.3); // ~2 USDC
export const SAFE_SCALP_SIZE = qtyFor(STANDARD_ALPHA, 0.12); // ~0.8 USDC
export const SAFE_SWING_SIZE = qtyFor(STANDARD_ALPHA, 0.54); // ~3.5 USDC

// Conservative trading sizes for extreme stress tests (15% of theoretical max)
export const CONSERVATIVE_TRADE_SIZE = qtyFor(STANDARD_ALPHA, 0.15); // ~1 USDC

// Maximum safe single chunk size (90% of theoretical max)
export const MAX_SAFE_CHUNK_SIZE = qtyFor(STANDARD_ALPHA, 0.9); // ~5.85 USDC

/**
 * Calculate safe maxCost with reasonable buffer
 * @param cost Expected cost in USDC (6 decimals)
 * @param bufferMultiplier Multiplier for buffer (default 1.5x)
 * @returns Safe maxCost with buffer
 */
export function safeMaxCost(cost: bigint, bufferMultiplier = 1.5): bigint {
  const buffer = (cost * BigInt(Math.floor(bufferMultiplier * 100))) / 100n;
  return buffer;
}

/**
 * Calculate safe maxCost with fixed buffer
 * @param cost Expected cost in USDC (6 decimals)
 * @param fixedBuffer Fixed buffer amount in USDC (default 0.5 USDC)
 * @returns Safe maxCost with fixed buffer
 */
export function safeMaxCostFixed(
  cost: bigint,
  fixedBuffer = parseUnits("0.5", 6)
): bigint {
  return cost + fixedBuffer;
}

```


## test/helpers/tags.ts

```typescript
// Test layer tags for filtering
export const UNIT_TAG = "@unit";
export const COMPONENT_TAG = "@component";
export const INTEGRATION_TAG = "@integration";
export const INVARIANT_TAG = "@invariant";
export const E2E_TAG = "@e2e";
export const PERF_TAG = "@perf";
export const SECURITY_TAG = "@security";
export const REPLAY_TAG = "@replay";

// Test descriptions with tags
export const withTag = (tag: string, description: string) =>
  `${tag} ${description}`;

```


## test/helpers/utils/random.ts

```typescript
/**
 * Deterministic pseudo-random number generator based on Park-Miller LCG.
 * Returns values in the range [0, 1).
 */
export function createDeterministicRandom(
  seed: number | bigint | string = 1
): () => number {
  const modulus = 2147483647n;
  const multiplier = 48271n;

  let state = BigInt(seed) % modulus;
  if (state <= 0n) {
    state += modulus - 1n;
  }

  return () => {
    state = (state * multiplier) % modulus;
    return Number(state) / Number(modulus);
  };
}

/**
 * Deterministic incrementer helper for generating sequential identifiers.
 */
export function createIncrementer(start = 1): () => number {
  let current = start;
  return () => current++;
}

```

## Configuration


## hardhat.config.ts

```typescript
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "@openzeppelin/hardhat-upgrades";
import "hardhat-gas-reporter";
import "hardhat-tracer";
import "solidity-docgen";
import "solidity-coverage";
import dotenv from "dotenv";

dotenv.config();

const isCoverage = process.env.COVERAGE === "1";

const config: HardhatUserConfig = {
  solidity: {
    // Í∏∞Î≥∏ ÏÑ§Ï†ï (ÌÖåÏä§Ìä∏/Í∏∞ÌÉÄ Ïª®Ìä∏ÎûôÌä∏)
    compilers: [
      {
        version: "0.8.30",
        settings: {
          viaIR: true,
          evmVersion: "paris",
          optimizer: {
            enabled: true,
            runs: 200,
          },
          metadata: {
            bytecodeHash: "none", // Remove metadata hash to save additional bytes
            useLiteralContent: true,
          },
        },
      },
    ],
    // ÏΩîÏñ¥Îßå ÏΩîÎìú ÏÇ¨Ïù¥Ï¶à Ïö∞ÏÑ† ÏÑ§Ï†ïÏúºÎ°ú Î≥ÑÎèÑ Ïª¥ÌååÏùº
    overrides: {
      "contracts/core/CLMSRMarketCore.sol": {
        version: "0.8.30",
        settings: {
          viaIR: true,
          evmVersion: "paris",
          optimizer: {
            enabled: true,
            runs: 0, // ÏÇ¨Ïù¥Ï¶à Ïö∞ÏÑ† (Ïù∏ÎùºÏù¥Îãù ÏµúÏÜåÌôî)
          },
          debug: {
            revertStrings: "strip",
          },
          metadata: {
            bytecodeHash: "none",
            useLiteralContent: false,
          },
        },
      },
      // ÏÑ∏Í∑∏Î®ºÌä∏ Ìä∏Î¶¨Îäî IR Í≤ΩÎ°ú Ïú†ÏßÄ (stack too deep Î∞©ÏßÄ)
      "contracts/libraries/LazyMulSegmentTree.sol": {
        version: "0.8.30",
        settings: {
          viaIR: true,
          evmVersion: "paris",
          optimizer: {
            enabled: true,
            runs: 200,
          },
          metadata: {
            bytecodeHash: "none",
            useLiteralContent: true,
          },
        },
      },
      "contracts/managers/CLMSRMarketManager.sol": {
        version: "0.8.30",
        settings: {
          viaIR: true,
          evmVersion: "paris",
          optimizer: {
            enabled: true,
            runs: 200,
            // Keep default optimizer details
          },
          metadata: {
            bytecodeHash: "none",
            useLiteralContent: true,
          },
        },
      },
    },
  },
  networks: {
    // Citrea Testnet Tangerine (Production)
    "citrea-prod": {
      url: process.env.CITREA_RPC_URL || "https://rpc.testnet.citrea.xyz",
      chainId: 5115,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
    },
    // Citrea Testnet Tangerine (Development)
    "citrea-dev": {
      url: process.env.CITREA_RPC_URL || "https://rpc.testnet.citrea.xyz",
      chainId: 5115,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
    },

    // Hardhat local network
    hardhat: {
      chainId: 31337,
      allowUnlimitedContractSize: true,
      blockGasLimit: 30000000,
      gas: 30000000,
      gasPrice: 1000000000,
      initialBaseFeePerGas: 0,
      accounts: {
        count: 20,
        accountsBalance: "10000000000000000000000", // 10,000 ETH
      },
      mining: {
        auto: true,
        interval: 0,
      },
    },
    localhost: {
      url: "http://127.0.0.1:8545",
      // Use default Hardhat accounts
      accounts: [
        "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80", // Account #0
        "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d", // Account #1
      ],
    },
  },
  gasReporter: {
    enabled: process.env.REPORT_GAS !== undefined,
    currency: "USD",
  },
  etherscan: {
    apiKey: {
      // Citrea networks (Blockscout doesn't require API key)
      "citrea-dev": "dummy",
      "citrea-prod": "dummy",
    },
    customChains: [
      {
        network: "citrea-dev",
        chainId: 5115,
        urls: {
          apiURL: "https://explorer.testnet.citrea.xyz/api",
          browserURL: "https://explorer.testnet.citrea.xyz",
        },
      },
      {
        network: "citrea-prod",
        chainId: 5115,
        urls: {
          apiURL: "https://explorer.testnet.citrea.xyz/api",
          browserURL: "https://explorer.testnet.citrea.xyz",
        },
      },
    ],
  },
  sourcify: {
    enabled: true,
  },
  docgen: {
    outputDir: "../website/docs/contracts",
    pages: "items",
    exclude: ["mocks/**", "test/**"],
    theme: "markdown",
  },
};

export default config;

```


## tsconfig.json

```json
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  }
}

```


## package.json

```json
{
  "name": "signals-v0",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "repository": "https://github.com/signals-protocol/signals-v0.git",
  "author": "worjs <whworjs777@gmail.com>",
  "license": "MIT",
  "scripts": {
    "compile": "hardhat compile",
    "test": "hardhat test",
    "postinstall": "patch-package",
    "deploy:localhost": "COMMAND=deploy:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "upgrade:localhost": "COMMAND=upgrade:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "upgrade:citrea:dev": "MANIFEST_DEFAULT_DIR=.openzeppelin/dev COMMAND=upgrade:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "upgrade:citrea:prod": "MANIFEST_DEFAULT_DIR=.openzeppelin/prod COMMAND=upgrade:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "market:localhost": "COMMAND=create-market:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "market:citrea:dev": "COMMAND=create-market:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "market:citrea:prod": "COMMAND=create-market:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "settle:localhost": "COMMAND=settle-market:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "settle:citrea:dev": "COMMAND=settle-market:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "settle:citrea:prod": "COMMAND=settle-market:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "close:localhost": "COMMAND=close-market:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "close:citrea:dev": "COMMAND=close-market:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "close:citrea:prod": "COMMAND=close-market:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "update-timing:localhost": "COMMAND=update-market-timing:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "update-timing:citrea:dev": "COMMAND=update-market-timing:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "update-timing:citrea:prod": "COMMAND=update-market-timing:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "emit:citrea:dev": "COMMAND=emit-position-settled:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "emit:citrea:prod": "COMMAND=emit-position-settled:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "check-status:citrea:dev": "COMMAND=check-position-status:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "check-status:citrea:prod": "COMMAND=check-position-status:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "status:localhost": "COMMAND=status:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "status:citrea:dev": "COMMAND=status:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "status:citrea:prod": "COMMAND=status:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "safety:localhost": "COMMAND=safety-check:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "safety:citrea:dev": "MANIFEST_DEFAULT_DIR=.openzeppelin/dev COMMAND=safety-check:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "safety:citrea:prod": "MANIFEST_DEFAULT_DIR=.openzeppelin/prod COMMAND=safety-check:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "verify:citrea:dev": "bash scripts/verify-all.sh citrea-dev",
    "verify:citrea:prod": "bash scripts/verify-all.sh citrea-prod",
    "find-divergence": "npx hardhat run verification/find-divergence-block.ts --network citrea-prod",
    "manifest:backup:localhost": "COMMAND=manifest-backup:localhost npx hardhat run scripts/dispatcher.ts",
    "manifest:backup:dev": "COMMAND=manifest-backup:dev npx hardhat run scripts/dispatcher.ts",
    "manifest:backup:prod": "COMMAND=manifest-backup:prod npx hardhat run scripts/dispatcher.ts",
    "manifest:commit:localhost": "COMMAND=manifest-commit:localhost npx hardhat run scripts/dispatcher.ts",
    "manifest:commit:dev": "COMMAND=manifest-commit:dev npx hardhat run scripts/dispatcher.ts",
    "manifest:commit:prod": "COMMAND=manifest-commit:prod npx hardhat run scripts/dispatcher.ts",
    "manifest:sync": "COMMAND=manifest-sync:all npx hardhat run scripts/dispatcher.ts",
    "manifest:validate:localhost": "COMMAND=manifest-validate:localhost npx hardhat run scripts/dispatcher.ts",
    "manifest:validate:dev": "COMMAND=manifest-validate:dev npx hardhat run scripts/dispatcher.ts",
    "manifest:validate:prod": "COMMAND=manifest-validate:prod npx hardhat run scripts/dispatcher.ts",
    "repair:localhost": "COMMAND=repair-manifest:localhost npx hardhat run scripts/dispatcher.ts --network localhost",
    "repair:citrea:dev": "MANIFEST_DEFAULT_DIR=.openzeppelin/dev COMMAND=repair-manifest:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "repair:citrea:prod": "MANIFEST_DEFAULT_DIR=.openzeppelin/prod COMMAND=repair-manifest:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod",
    "test:full:localhost": "npx hardhat run scripts/full-test-localhost.ts --network localhost",
    "coverage": "NODE_OPTIONS=--max-old-space-size=8192 COVERAGE=1 npx hardhat coverage",
    "coverage:check": "node scripts/check-coverage.mjs",
    "test:fast": "npx hardhat test",
    "test:replay": "node scripts/test-replay.js",
    "coverage:all": "npm run coverage && npm run coverage:check && npm --prefix clmsr-sdk test -- --coverage && npm --prefix clmsr-subgraph run test:citrea:dev",
    "beta": "npx hardhat run scripts/beta-distribution.ts --network citrea-prod",
    "compensate:citrea:dev": "COMMAND=compensate-susd:citrea:dev npx hardhat run scripts/dispatcher.ts --network citrea-dev",
    "compensate:citrea:prod": "COMMAND=compensate-susd:citrea:prod npx hardhat run scripts/dispatcher.ts --network citrea-prod"
  },
  "devDependencies": {
    "@nomicfoundation/hardhat-chai-matchers": "^2.0.8",
    "@nomicfoundation/hardhat-ethers": "^3.0.8",
    "@nomicfoundation/hardhat-ignition": "^0.15.11",
    "@nomicfoundation/hardhat-ignition-ethers": "^0.15.11",
    "@nomicfoundation/hardhat-network-helpers": "^1.0.12",
    "@nomicfoundation/hardhat-toolbox": "^5.0.0",
    "@nomicfoundation/hardhat-verify": "^2.0.14",
    "@typechain/ethers-v6": "^0.5.1",
    "@typechain/hardhat": "^9.1.0",
    "@types/chai": "^4.3.10",
    "@types/mocha": "^10.0.10",
    "chai": "^4.3.10",
    "dotenv": "^17.2.0",
    "ethers": "^6.14.3",
    "hardhat": "^2.24.1",
    "hardhat-gas-reporter": "^2.3.0",
    "hardhat-tracer": "^3.2.1",
    "patch-package": "^8.0.1",
    "solidity-coverage": "^0.8.16",
    "solidity-docgen": "^0.6.0-beta.36",
    "ts-node": "^10.9.2",
    "typechain": "^8.3.2",
    "typescript": "^5.8.3"
  },
  "dependencies": {
    "@openzeppelin/contracts": "^5.3.0",
    "@openzeppelin/contracts-upgradeable": "^5.4.0",
    "@openzeppelin/hardhat-upgrades": "^3.9.1",
    "@prb/math": "^4.1.0",
    "@redstone-finance/evm-connector": "^0.9.0",
    "@redstone-finance/sdk": "^0.9.0",
    "@whworjs7946/clmsr-v0": "^1.12.0",
    "axios": "^1.10.0"
  }
}

```


## README.md

```markdown
# üöÄ CLMSR Market System

[![Tests](https://img.shields.io/badge/tests-686%20passing-brightgreen)](./test/)
[![Security](https://img.shields.io/badge/security-hardened-green)](./README.md#security-enhancements)
[![Coverage](https://img.shields.io/badge/coverage-%E2%89%A580%25-brightgreen)](./test/)
[![Status](https://img.shields.io/badge/status-in%20development-yellow)](./README.md)

> **CLMSR (Continuous Logarithmic Market Scoring Rule) implementation with comprehensive security hardening and 686 passing tests.**

---

## üéØ Quick Start

```bash
# Install dependencies
npm install

# Run tests (686 tests)
npm test

# Enforce coverage thresholds
npm run coverage && npm run coverage:check

# Compile contracts
npm run compile

# Generate complete codebase documentation
./combine_all_files.sh
```

---

## üìä Project Status

| Metric                 | Status                  | Details                                   |
| ---------------------- | ----------------------- | ----------------------------------------- |
| **Tests**              | ‚úÖ **686 passing**      | Full hardhat suite + subgraph matchstick  |
| **Security**           | ‚úÖ **Hardened**         | Critical vulnerabilities fixed            |
| **Documentation**      | ‚úÖ **Complete**         | Auto-generated comprehensive docs         |
| **Gas Optimization**   | ‚úÖ **Optimized**        | Efficient chunk-split algorithms          |
| **Coverage**           | ‚úÖ **‚â•80% gated**       | Enforced via `npm run coverage:check`     |
| **Development Status** | ‚úÖ **Production Ready** | Deployed on Base Mainnet                  |

---

## üèóÔ∏è Architecture Overview

### üéØ Core Concept: CLMSR (Continuous Logarithmic Market Scoring Rule)

CLMSR is an automated market maker algorithm for prediction markets:

- **Price Formula**: `P_i = exp(q_i/Œ±) / Œ£_j exp(q_j/Œ±)`
- **Cost Formula**: `C = Œ± * ln(Œ£_after / Œ£_before)`
- **Liquidity Parameter**: `Œ±` (configurable per market)

### üß© System Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CLMSRRouter   ‚îÇ    ‚îÇ CLMSRMarketCore ‚îÇ    ‚îÇ CLMSRPosition   ‚îÇ
‚îÇ   (UX Layer)    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ (Core Logic)    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   (NFT Mgmt)    ‚îÇ
‚îÇ  üìÖ PLANNED     ‚îÇ    ‚îÇ   ‚úÖ ACTIVE     ‚îÇ    ‚îÇ   ‚úÖ ACTIVE     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CLMSRManager    ‚îÇ    ‚îÇ LazyMulSegTree  ‚îÇ    ‚îÇ FixedPointMath  ‚îÇ
‚îÇ (Governance)    ‚îÇ    ‚îÇ (Efficient DS)  ‚îÇ    ‚îÇ (Math Library)  ‚îÇ
‚îÇ  üìÖ PLANNED     ‚îÇ    ‚îÇ   ‚úÖ ACTIVE     ‚îÇ    ‚îÇ   ‚úÖ ACTIVE     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

> **üìÖ Implementation Status**: Core contracts (CLMSRMarketCore, CLMSRPosition) and libraries are fully implemented and tested. Manager and Router contracts are planned for future implementation.

---

## üìÅ Project Structure

```
signals-v0/
‚îú‚îÄ‚îÄ üìÑ contracts/
‚îÇ   ‚îú‚îÄ‚îÄ üéØ core/CLMSRMarketCore.sol          # Core trading logic (1,031 lines)
‚îÇ   ‚îú‚îÄ‚îÄ üîå interfaces/                       # Contract interfaces (4 files)
‚îÇ   ‚îú‚îÄ‚îÄ üìö libraries/                        # Math libraries (2 files)
‚îÇ   ‚îú‚îÄ‚îÄ üß™ test/                            # Solidity test helpers (2 files)
‚îÇ   ‚îî‚îÄ‚îÄ üé≠ mocks/                           # Testing mocks (2 files)
‚îú‚îÄ‚îÄ üß™ test/
‚îÇ   ‚îú‚îÄ‚îÄ üìä core/                            # Core functionality tests (7 files)
‚îÇ   ‚îú‚îÄ‚îÄ üî¢ FixedPointMath.test.ts           # Math library tests (52 tests)
‚îÇ   ‚îî‚îÄ‚îÄ üå≥ LazyMulSegmentTree.test.ts       # Segment tree tests (79 tests)
‚îú‚îÄ‚îÄ ‚öôÔ∏è  hardhat.config.ts                   # Build configuration
‚îú‚îÄ‚îÄ üì¶ package.json                         # Dependencies
‚îî‚îÄ‚îÄ üöÄ combine_all_files.sh                 # Auto documentation generator
```

---

## üõ°Ô∏è Security Enhancements

### üîí Critical Security Fixes Applied

| Issue                   | Severity    | Description                                      | Status       |
| ----------------------- | ----------- | ------------------------------------------------ | ------------ |
| **Zero-Cost Attack**    | üî¥ Critical | `fromWad()` truncation allowing free positions   | ‚úÖ **FIXED** |
| **Gas DoS Attack**      | üî¥ Critical | Unlimited chunk splitting causing gas exhaustion | ‚úÖ **FIXED** |
| **Time Validation**     | üü° Medium   | Trading in expired markets                       | ‚úÖ **FIXED** |
| **Overflow Protection** | üü° Medium   | Mathematical overflow in large trades            | ‚úÖ **FIXED** |

### üõ°Ô∏è Security Mechanisms

1. **Round-Up Cost Calculation**

   ```solidity
   // Before: fromWad() - truncation allows 0 cost
   uint256 cost6 = costWad.fromWad();

   // After: fromWadRoundUp() - guarantees minimum 1 micro USDC
   uint256 cost6 = costWad.fromWadRoundUp();
   ```

2. **Gas DoS Protection**

   ```solidity
   uint256 private constant MAX_CHUNKS_PER_TX = 100;

   uint256 requiredChunks = (quantity + maxSafeQuantityPerChunk - 1) / maxSafeQuantityPerChunk;
   if (requiredChunks > MAX_CHUNKS_PER_TX) {
       revert InvalidQuantity(uint128(quantity));
   }
   ```

3. **Time Boundary Validation**
   ```solidity
   if (block.timestamp < market.startTimestamp) {
       revert InvalidMarketParameters("Market not started");
   }
   if (block.timestamp > market.endTimestamp) {
       market.isActive = false;
       revert InvalidMarketParameters("Market expired");
   }
   ```

---

## üß™ Testing Excellence

### üìä Test Coverage Breakdown

| Category               | Tests   | Coverage | Description                           |
| ---------------------- | ------- | -------- | ------------------------------------- |
| **FixedPointMath**     | 52      | 100%     | Mathematical operations & precision   |
| **LazyMulSegmentTree** | 79      | 100%     | Segment tree operations               |
| **Core Boundaries**    | 42      | 100%     | Edge cases & boundary conditions      |
| **Core Deployment**    | 15      | 100%     | Deployment & configuration            |
| **Core Events**        | 25      | 100%     | Event emission & authorization        |
| **Core Execution**     | 67      | 100%     | Trade execution & position management |
| **Core Invariants**    | 12      | 100%     | Mathematical invariants               |
| **Core Markets**       | 32      | 100%     | Market creation & management          |
| **Total**              | **324** | **100%** | **Complete test coverage**            |

### üéØ Special Test Scenarios

- **Security Attack Prevention**: Zero-cost positions, gas DoS attacks
- **Boundary Testing**: Min/max quantities, time boundaries, tick boundaries
- **Mathematical Accuracy**: CLMSR formulas, chunk splitting, precision
- **Gas Optimization**: Large trades, complex operation scenarios
- **Error Handling**: All revert conditions and edge cases

---

## üöÄ Key Features

### üéØ Core Functionality

1. **Complete CLMSR Implementation**

   - Continuous logarithmic market scoring rule
   - Chunk-split support for large trades
   - Per-market liquidity parameter configuration

2. **NFT-Based Position Management**

   - ERC721 compatible position tokens
   - Range-based positions (lowerTick ~ upperTick)
   - Complete position lifecycle management

3. **High-Performance Data Structures**
   - Lazy Multiplication Segment Tree
   - O(log N) updates and queries
   - Memory-efficient sparse arrays

### üõ°Ô∏è Security Features

1. **Attack Prevention Mechanisms**

   - Zero-cost attack prevention
   - Gas DoS attack prevention
   - Time-based validation

2. **Mathematical Stability**

   - Overflow protection
   - Precision maintenance
   - Safe exponential operations

3. **Access Control**
   - Role-based permission management
   - Emergency pause mechanism
   - Authorized callers only

---

## üîß Development Tools

### üìã Available Scripts

```bash
# Testing
npm test                    # Run all tests (324 tests)
npm run test:core          # Core functionality tests only
npm run test:math          # Math library tests only

# Build & Compilation
npm run compile            # Compile smart contracts
npm run clean              # Clean build artifacts

# Documentation
./combine_all_files.sh     # Generate complete codebase documentation
npm run docs               # Generate API documentation

# Code Quality
npm run lint               # Code style checks
npm run format             # Code formatting
```

### üõ†Ô∏è Advanced Build Script

The new `combine_all_files.sh` provides:

- ‚úÖ **Automatic File Detection**: Auto-recognizes new files
- ‚úÖ **Live Test Results**: Runs tests during script execution
- ‚úÖ **Project Statistics**: Auto-calculates file counts, sizes, lines
- ‚úÖ **Git Integration**: Extracts commit counts and contributors
- ‚úÖ **Security Tracking**: Auto-counts security fixes from README
- ‚úÖ **Beautiful Output**: Colorized output with emojis

---

## üìà Performance Metrics

### ‚ö° Gas Optimization

| Operation                   | Gas Cost  | Optimization            |
| --------------------------- | --------- | ----------------------- |
| **Position Open**           | ~150K gas | Optimized segment tree  |
| **Position Increase**       | ~80K gas  | Cached calculations     |
| **Position Decrease**       | ~90K gas  | Efficient state updates |
| **Large Trade (10x chunk)** | ~800K gas | Chunk-split algorithm   |

### üèÉ‚Äç‚ôÇÔ∏è Execution Performance

- **Test Suite**: 324 tests in ~4 seconds
- **Compilation**: Full build in ~10 seconds
- **Documentation**: Complete docs in ~5 seconds

---

## üéØ Development Roadmap

### ‚úÖ Completed (v0.1)

- [x] Core CLMSR implementation
- [x] Security hardening
- [x] Comprehensive testing
- [x] Documentation automation
- [x] Gas optimization

### üöß In Progress (v0.2)

- [ ] Frontend integration
- [ ] Gas optimization improvements
- [ ] Enhanced error handling

### üìÖ Planned (v0.3)

- [ ] Manager contract implementation
- [ ] Router contract with permit support
- [ ] Oracle integration (price feeds for automatic settlement)

---

## ü§ù Contributing

### üîß Development Setup

```bash
# Clone repository
git clone https://github.com/your-org/signals-v0.git
cd signals-v0

# Install dependencies
npm install

# Run tests to verify setup
npm test

# Start developing!
```

### üìù Code Standards

- **Solidity**: 0.8.24, via-IR optimization
- **TypeScript**: Strict mode, comprehensive typing
- **Testing**: 100% coverage requirement
- **Documentation**: Auto-generated, always up-to-date

### üêõ Bug Reports

When reporting bugs:

1. Write reproducible test case
2. Describe expected vs actual behavior
3. Include environment info (Node.js, npm versions)

---

## üìÑ License

MIT License - see [LICENSE](./LICENSE) for details.

---

## üèÜ Current Achievements

- üéØ **324 Tests Passing** - Complete test coverage
- üõ°Ô∏è **Security Hardened** - Critical vulnerabilities fixed
- ‚ö° **Gas Optimized** - Efficient chunk-split algorithms
- üìö **Well Documented** - Auto-generated comprehensive docs
- üåê **Production Deployed** - Live on Base Mainnet

---

## üåê Live Deployments

**‚úÖ PRODUCTION READY** - Successfully deployed on multiple networks!

### üî∑ Base Mainnet

Successfully deployed and operational on Base Mainnet:

### üìã Contract Addresses

| Contract               | Address                                                                                                                      | Verified |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------- | -------- |
| **CLMSRMarketCore**    | [`0x4424687a25302db5d1D3A9f7504e4710b0ab17E9`](https://basescan.org/address/0x4424687a25302db5d1D3A9f7504e4710b0ab17E9#code) | ‚úÖ       |
| **CLMSRPosition**      | [`0x93E61D408456D27d5AB3fC4281B56Eb69A8296e7`](https://basescan.org/address/0x93E61D408456D27d5AB3fC4281B56Eb69A8296e7#code) | ‚úÖ       |
| **SUSD Token**         | [`0x19593B3AF55ad58Ce74514924a2F253FDF89CA34`](https://basescan.org/address/0x19593B3AF55ad58Ce74514924a2F253FDF89CA34#code) | ‚úÖ       |
| **FixedPointMathU**    | [`0xA8Af982597D7A17c651c801B801EC86C92171A5d`](https://basescan.org/address/0xA8Af982597D7A17c651c801B801EC86C92171A5d#code) | ‚úÖ       |
| **LazyMulSegmentTree** | [`0x1Ba59a311Fb42D475dBC55C9bc780e3883E25A53`](https://basescan.org/address/0x1Ba59a311Fb42D475dBC55C9bc780e3883E25A53#code) | ‚úÖ       |

### üìä Subgraph API

- **Studio**: https://thegraph.com/studio/subgraph/signals-v-0
- **Query Endpoint**: `https://api.studio.thegraph.com/query/116469/signals-v-0/1.0.2`

### üéØ Active Market (Base)

- **Market ID**: 1
- **Network**: Base Mainnet (Chain ID: 8453)
- **Tick Range**: 100,000 - 140,000 (400 bins)
- **Liquidity Parameter**: 1000.0
- **Payment Token**: SUSD (Signals USD)

### üü† Citrea Testnet Tangerine

**üöÄ READY FOR DEPLOYMENT** - Configured for Citrea Testnet:

```
Network: Citrea Testnet Tangerine
Chain ID: 5115
RPC: https://rpc.testnet.citrea.xyz
Explorer: https://explorer.testnet.citrea.xyz
```

**Deployment Commands:**

```bash
# Deploy to Citrea Development
yarn deploy:citrea:dev

# Deploy to Citrea Production
yarn deploy:citrea:prod
```

**Indexer:** GoldSky (TheGraph not supported on Citrea)

```bash
cd clmsr-subgraph
npm run deploy:goldsky:citrea:dev
npm run deploy:goldsky:citrea:prod
```

üìñ **Full Guide**: [CITREA_DEPLOYMENT.md](./CITREA_DEPLOYMENT.md)

## üö® Development Status

The core CLMSR functionality is **production ready** and successfully deployed on Base Mainnet. All contracts are verified and operational.

---

_This project is continuously improving. Run `./combine_all_files.sh` for the latest documentation._

```


---

## Statistics

- **Total Files**: 122
- **Total Lines**: 36823
- **Generated**: 2025-12-01 12:32:48

---

_Auto-generated by CLMSR Codebase Compiler (Optimized for AI)_

